{
  "openapi": "3.0.3",
  "info": {
    "title": "Trieve API",
    "description": "Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.",
    "contact": {
      "name": "Trieve Team",
      "url": "https://trieve.ai",
      "email": "developers@trieve.ai"
    },
    "license": {
      "name": "BSL",
      "url": "https://github.com/devflowinc/trieve/blob/main/LICENSE.txt"
    },
    "version": "0.13.0"
  },
  "servers": [
    {
      "url": "https://api.trieve.ai",
      "description": "Production server"
    },
    {
      "url": "http://localhost:8090",
      "description": "Local development server"
    }
  ],
  "paths": {
    "/api/analytics": {
      "post": {
        "tags": [
          "Analytics"
        ],
        "summary": "Get Analytics",
        "description": "This route allows you to view the analytics for a dataset using a structured query.",
        "operationId": "get_analytics",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to filter the graph",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AnalyticsQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The analytics for the dataset",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/analytics/ctr": {
      "put": {
        "tags": [
          "Analytics"
        ],
        "summary": "Send CTR Data",
        "description": "This route allows you to send clickstream data to the system. Clickstream data is used to fine-tune the re-ranking of search results and recommendations.",
        "operationId": "send_ctr_data",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to send CTR data",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CTRDataRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "The CTR data was successfully sent"
          },
          "400": {
            "description": "Service error relating to sending CTR data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/analytics/events": {
      "put": {
        "tags": [
          "Analytics"
        ],
        "summary": "Send User Event Data",
        "description": "This route allows you to send user event data to the system.",
        "operationId": "send_event_data",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to send event data",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventTypes"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "The event data was successfully sent"
          },
          "400": {
            "description": "Service error relating to sending event data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/analytics/events/all": {
      "post": {
        "tags": [
          "Analytics"
        ],
        "summary": "Get All User Events",
        "description": "This route allows you to view all user events.",
        "operationId": "get_all_events",
        "requestBody": {
          "description": "JSON request payload to filter the events",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEventsRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The events for the request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetEventsResponseBody"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting events",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/analytics/events/component": {
      "post": {
        "tags": [
          "Analytics"
        ],
        "summary": "Get Component Analytics",
        "description": "This route allows you to view the component analytics for a dataset.",
        "operationId": "get_component_analytics",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to filter the graph",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ComponentAnalytics"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The component analytics for the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ComponentAnalyticsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting component analytics",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/analytics/events/ctr": {
      "post": {
        "tags": [
          "Analytics"
        ],
        "summary": "Get CTR Analytics",
        "description": "This route allows you to view the CTR analytics for a dataset.",
        "operationId": "get_ctr_analytics",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to filter the graph",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CTRAnalytics"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The CTR analytics for the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CTRAnalyticsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting CTR analytics",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/analytics/events/{event_id}": {
      "get": {
        "tags": [
          "Analytics"
        ],
        "summary": "Get User Event By ID",
        "description": "This route allows you to view an user event by its ID. You can pass in any type of event and get the details for that event.",
        "operationId": "get_event_by_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "event_id",
            "in": "path",
            "description": "The event id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The event for the request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventData"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting an event",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/analytics/rag": {
      "post": {
        "tags": [
          "Analytics"
        ],
        "summary": "Get RAG Analytics",
        "description": "This route allows you to view the RAG analytics for a dataset.",
        "operationId": "get_rag_analytics",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to filter the graph",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RAGAnalytics"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The RAG analytics for the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RAGAnalyticsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting RAG analytics",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "Analytics"
        ],
        "summary": "Rate RAG",
        "description": "This route allows you to Rate a RAG query.",
        "operationId": "set_rag_query_rating",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to rate a RAG query",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RateQueryRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "The RAG query was successfully rated"
          },
          "400": {
            "description": "Service error relating to rating a RAG query",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/analytics/recommendations": {
      "post": {
        "tags": [
          "Analytics"
        ],
        "summary": "Get Recommendation Analytics",
        "description": "This route allows you to view the recommendation analytics for a dataset.",
        "operationId": "get_recommendation_analytics",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to filter the graph",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecommendationAnalytics"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The recommendation analytics for the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecommendationAnalyticsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting recommendation analytics",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/analytics/search": {
      "post": {
        "tags": [
          "Analytics"
        ],
        "summary": "Get Search Analytics",
        "description": "This route allows you to view the search analytics for a dataset.",
        "operationId": "get_search_analytics",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to filter the graph",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchAnalytics"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The search analytics for the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchAnalyticsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting search analytics",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "Analytics"
        ],
        "summary": "Rate Search",
        "description": "This route allows you to Rate a search query.",
        "operationId": "set_search_query_rating",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to rate a search query",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RateQueryRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "The search query was successfully rated"
          },
          "400": {
            "description": "Service error relating to rating a search query",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/analytics/search/cluster": {
      "post": {
        "tags": [
          "Analytics"
        ],
        "summary": "Get Cluster Analytics",
        "description": "This route allows you to view the cluster analytics for a dataset.",
        "operationId": "get_cluster_analytics",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to filter the graph",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ClusterAnalytics"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The cluster analytics for the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterAnalyticsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting cluster analytics",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/analytics/top": {
      "post": {
        "tags": [
          "Analytics"
        ],
        "summary": "Get Top Datasets",
        "description": "This route allows you to view the top datasets for a given type.",
        "operationId": "get_top_datasets",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to filter the top datasets",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetTopDatasetsRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The top datasets for the request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TopDatasetsResponse"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting top datasets",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/auth": {
      "get": {
        "tags": [
          "Auth"
        ],
        "summary": "Login",
        "description": "This will redirect you to the OAuth provider for authentication with email/pass, SSO, Google, Github, etc.",
        "operationId": "login",
        "parameters": [
          {
            "name": "organization_id",
            "in": "query",
            "description": "ID of organization to authenticate into",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid",
              "nullable": true
            }
          },
          {
            "name": "redirect_uri",
            "in": "query",
            "description": "URL to redirect to after successful login",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            }
          },
          {
            "name": "inv_code",
            "in": "query",
            "description": "Code sent via email as a result of successful call to send_invitation",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid",
              "nullable": true
            }
          }
        ],
        "responses": {
          "303": {
            "description": "Response that redirects to OAuth provider through a Location header to be handled by browser."
          },
          "400": {
            "description": "OAuth error likely with OIDC provider.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Auth"
        ],
        "summary": "Logout",
        "description": "Invalidate your current auth credential stored typically stored in a cookie. This does not invalidate your API key.",
        "operationId": "logout",
        "responses": {
          "204": {
            "description": "Confirmation that your current auth token has been invalidated. This does not invalidate your API key."
          }
        }
      }
    },
    "/api/auth/callback": {
      "get": {
        "tags": [
          "Auth"
        ],
        "summary": "OpenID Connect callback",
        "description": "This is the callback route for the OAuth provider, it should not be called directly. Redirects to browser with set-cookie header.",
        "operationId": "oidc_callback",
        "responses": {
          "200": {
            "description": "Response that returns with set-cookie header",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlimUser"
                }
              }
            }
          },
          "400": {
            "description": "Email or password empty or incorrect",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/auth/create_api_only_user": {
      "post": {
        "tags": [
          "Auth"
        ],
        "operationId": "create_api_only_user",
        "requestBody": {
          "description": "",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateApiUserBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The user id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateApiUserResponse"
                }
              }
            }
          },
          "400": {
            "description": "Error message indicitating you are not currently signed in",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/auth/me": {
      "get": {
        "tags": [
          "Auth"
        ],
        "summary": "Get Me",
        "description": "Get the user corresponding to your current auth credentials.",
        "operationId": "get_me",
        "responses": {
          "200": {
            "description": "The user corresponding to your current auth credentials",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlimUser"
                }
              }
            }
          },
          "400": {
            "description": "Error message indicitating you are not currently signed in",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk": {
      "post": {
        "tags": [
          "Chunk"
        ],
        "summary": "Create or Upsert Chunk or Chunks",
        "description": "Create new chunk(s). If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.\nIf uploading in bulk, the maximum amount of chunks that can be uploaded at once is 120 chunks. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "create_chunk",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to create a new chunk (chunk)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateChunkReqPayloadEnum"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "JSON response payload containing the created chunk",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReturnQueuedChunk"
                }
              }
            }
          },
          "400": {
            "description": "Error typically due to deserialization issues",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "413": {
            "description": "Error when more than 120 chunks are provided in bulk",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "426": {
            "description": "Error when upgrade is needed to process more chunks",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "Chunk"
        ],
        "summary": "Update Chunk",
        "description": "Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "update_chunk",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to update a chunk (chunk)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateChunkReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "No content Ok response indicating the chunk was updated as requested"
          },
          "400": {
            "description": "Service error relating to to updating chunk, likely due to conflicting tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Chunk"
        ],
        "summary": "Bulk Delete Chunks",
        "description": "Delete multiple chunks using a filter. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "bulk_delete_chunk",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to speicy a filter to bulk delete chunks",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BulkDeleteChunkPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Confirmation that the chunk with the id specified was deleted"
          },
          "400": {
            "description": "Service error relating to finding a chunk by tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk/autocomplete": {
      "post": {
        "tags": [
          "Chunk"
        ],
        "summary": "Autocomplete",
        "description": "This route provides the primary autocomplete functionality for the API. This prioritize prefix matching with semantic or full-text search.",
        "operationId": "autocomplete",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "X-API-Version",
            "in": "header",
            "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/APIVersion"
                }
              ],
              "nullable": true
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to semantically search for chunks (chunks)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AutocompleteReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Chunks with embedding vectors which are similar to those in the request body",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResponseTypes"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to searching",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk/count": {
      "post": {
        "tags": [
          "Chunk"
        ],
        "summary": "Count chunks above threshold",
        "description": "This route can be used to determine the number of chunk results that match a search query including score threshold and filters. It may be high latency for large limits. There is a dataset configuration imposed restriction on the maximum limit value (default 10,000) which is used to prevent DDOS attacks. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "count_chunks",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to count chunks for a search query",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CountChunksReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Number of chunks satisfying the query",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CountChunkQueryResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Failed to count chunks",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk/generate": {
      "post": {
        "tags": [
          "Chunk"
        ],
        "summary": "RAG on Specified Chunks",
        "description": "This endpoint exists as an alternative to the topic+message resource pattern where our Trieve handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt and the conversation is ephemeral.",
        "operationId": "generate_off_chunks",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to perform RAG on some chunks (chunks)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenerateOffChunksReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "This will be a JSON response of a string containing the LLM's generated inference. Response if not streaming.",
            "headers": {
              "TR-QueryID": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": "Query ID that is used for tracking analytics"
              }
            },
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to to updating chunk, likely due to conflicting tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk/recommend": {
      "post": {
        "tags": [
          "Chunk"
        ],
        "summary": "Get Recommended Chunks",
        "description": "Get recommendations of chunks similar to the positive samples in the request and dissimilar to the negative.",
        "operationId": "get_recommended_chunks",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "X-API-Version",
            "in": "header",
            "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/APIVersion"
                }
              ],
              "nullable": true
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to get recommendations of chunks similar to the chunks in the request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecommendChunksRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Chunks with embedding vectors which are similar to positives and dissimilar to negatives",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecommendResponseTypes"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to to getting similar chunks",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk/search": {
      "post": {
        "tags": [
          "Chunk"
        ],
        "summary": "Search",
        "description": "This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results' `chunk_html` values will be modified with `<mark><b>` or custom specified tags for sub-sentence highlighting.",
        "operationId": "search_chunks",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "X-API-Version",
            "in": "header",
            "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/APIVersion"
                }
              ],
              "nullable": true
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to semantically search for chunks (chunks)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchChunksReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Chunks with embedding vectors which are similar to those in the request body",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResponseTypes"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to searching",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk/split": {
      "post": {
        "tags": [
          "Chunk"
        ],
        "summary": "Split HTML Content into Chunks",
        "description": "This endpoint receives a single html string and splits it into chunks based on the headings and\nbody content. The headings are split based on heading html tags. chunk_html has a maximum size\nof 256Kb.",
        "operationId": "split_html_content",
        "requestBody": {
          "description": "JSON request payload to perform RAG on some chunks (chunks)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChunkHtmlContentReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "This will be a JSON response of the chunks split from the HTML content with the headings and body",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SplitHtmlResponse"
                }
              }
            }
          },
          "413": {
            "description": "Payload too large, if the HTML contnet is greater than 256Kb",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/chunk/suggestions": {
      "post": {
        "tags": [
          "Chunk"
        ],
        "summary": "Generate suggested queries",
        "description": "This endpoint will generate 3 suggested queries based off a hybrid search using RAG with the query provided in the request body and return them as a JSON object.",
        "operationId": "get_suggested_queries",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to get alternative suggested queries",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SuggestedQueriesReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A JSON object containing a list of alternative suggested queries",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuggestedQueriesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to to updating chunk, likely due to conflicting tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk/tracking_id/update": {
      "put": {
        "tags": [
          "Chunk"
        ],
        "summary": "Update Chunk By Tracking Id",
        "description": "Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "update_chunk_by_tracking_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to update a chunk by tracking_id (chunks)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateChunkByTrackingIdData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Confirmation that the chunk has been updated as per your request"
          },
          "400": {
            "description": "Service error relating to to updating chunk",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk/tracking_id/{tracking_id}": {
      "get": {
        "tags": [
          "Chunk"
        ],
        "summary": "Get Chunk By Tracking Id",
        "description": "Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.",
        "operationId": "get_chunk_by_tracking_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "X-API-Version",
            "in": "header",
            "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/APIVersion"
                }
              ],
              "nullable": true
            }
          },
          {
            "name": "tracking_id",
            "in": "path",
            "description": "tracking_id of the chunk you want to fetch",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "chunk with the tracking_id that you were searching for",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChunkReturnTypes"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to fidning a chunk by tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Chunk not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Chunk"
        ],
        "summary": "Delete Chunk By Tracking Id",
        "description": "Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "delete_chunk_by_tracking_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "tracking_id",
            "in": "path",
            "description": "tracking_id of the chunk you want to delete",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation that the chunk with the tracking_id specified was deleted"
          },
          "400": {
            "description": "Service error relating to finding a chunk by tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk/{chunk_id}": {
      "get": {
        "tags": [
          "Chunk"
        ],
        "summary": "Get Chunk By Id",
        "description": "Get a singular chunk by id.",
        "operationId": "get_chunk_by_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "X-API-Version",
            "in": "header",
            "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/APIVersion"
                }
              ],
              "nullable": true
            }
          },
          {
            "name": "chunk_id",
            "in": "path",
            "description": "Id of the chunk you want to fetch.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "chunk with the id that you were searching for",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChunkReturnTypes"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to fidning a chunk by tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Chunk not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Chunk"
        ],
        "summary": "Delete Chunk",
        "description": "Delete a chunk by its id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "delete_chunk",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "chunk_id",
            "in": "path",
            "description": "Id of the chunk you want to fetch.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation that the chunk with the id specified was deleted"
          },
          "400": {
            "description": "Service error relating to finding a chunk by tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk_group": {
      "post": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Create or Upsert Group or Groups",
        "description": "Create new chunk_group(s). This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail. Only 1000 chunk groups can be created at a time. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "create_chunk_group",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to cretea a chunk_group(s)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateChunkGroupReqPayloadEnum"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the created chunk_group if a single chunk_group was specified or an array of all chunk_groups which were created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateChunkGroupResponseEnum"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating the chunk_group(s)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "413": {
            "description": "Service error indicating more 1000 chunk groups are trying to be created at once",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Update Group",
        "description": "Update a chunk_group. One of group_id or tracking_id must be provided. If you try to change the tracking_id to one that already exists, this operation will fail. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "update_chunk_group",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to update a chunkGroup",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateChunkGroupReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Confirmation that the chunkGroup was updated"
          },
          "400": {
            "description": "Service error relating to updating the chunkGroup",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/chunk/{group_id}": {
      "post": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Add Chunk to Group",
        "description": "Route to add a chunk to a group. One of chunk_id or chunk_tracking_id must be provided. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "add_chunk_to_group",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "group_id",
            "in": "path",
            "description": "Id of the group to add the chunk to as a bookmark",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to add a chunk to a group (bookmark it)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddChunkToGroupReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Confirmation that the chunk was added to the group (bookmark'ed)."
          },
          "400": {
            "description": "Service error relating to getting the groups that the chunk is in.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Remove Chunk from Group",
        "description": "Route to remove a chunk from a group. Auth'ed user or api key must be an admin or owner of the dataset's organization to remove a chunk from a group.",
        "operationId": "remove_chunk_from_group",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "group_id",
            "in": "path",
            "description": "Id of the group you want to remove the chunk from.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "chunk_id",
            "in": "query",
            "description": "Id of the chunk you want to remove from the group",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid",
              "nullable": true
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to remove a chunk from a group",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RemoveChunkFromGroupReqPayload"
                  }
                ],
                "nullable": true
              }
            }
          },
          "required": false
        },
        "responses": {
          "204": {
            "description": "Confirmation that the chunk was removed to the group"
          },
          "400": {
            "description": "Service error relating to removing the chunk from the group",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/chunks": {
      "post": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Get Groups for Chunks",
        "description": "Route to get the groups that a chunk is in.",
        "operationId": "get_groups_for_chunks",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to get the groups that a chunk is in",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetGroupsForChunksReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "JSON body representing the groups that the chunk is in",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/GroupsForChunk"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the groups that the chunk is in",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/count": {
      "post": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Count Chunks in a Group",
        "description": "Route to get the number of chunks that is in a group",
        "operationId": "count_group_chunks",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to add a chunk to a group (bookmark it)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetChunkGroupCountRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "JSON body representing the group with the count",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetChunkGroupCountResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the group with the given tracking id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Group not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/group_oriented_autocomplete": {
      "post": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Autocomplete Search Over Groups",
        "description": "This route provides the primary autocomplete functionality for the API. This prioritize prefix matching with semantic or full-text search.",
        "operationId": "autocomplete_search_over_groups",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "X-API-Version",
            "in": "header",
            "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/APIVersion"
                }
              ],
              "nullable": true
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to semantically search for groups",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AutocompleteSearchOverGroupsReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Groups with embedding vectors which are similar to those in the request body",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchOverGroupsResponseBody"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to searching",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/group_oriented_search": {
      "post": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Search Over Groups",
        "description": "This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the top chunk of each group will be re-ranked using scores from a cross encoder model. Compatible with semantic, fulltext, or hybrid search modes.",
        "operationId": "search_over_groups",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "X-API-Version",
            "in": "header",
            "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/APIVersion"
                }
              ],
              "nullable": true
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to semantically search over groups",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchOverGroupsReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Group chunks which are similar to the embedding vector of the search query",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchOverGroupsResponseTypes"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to searching over groups",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/recommend": {
      "post": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Get Recommended Groups",
        "description": "Route to get recommended groups. This route will return groups which are similar to the groups in the request body. You must provide at least one positive group id or group tracking id.",
        "operationId": "get_recommended_groups",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "X-API-Version",
            "in": "header",
            "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/APIVersion"
                }
              ],
              "nullable": true
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to get recommendations of chunks similar to the chunks in the request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecommendGroupsReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "JSON body representing the groups which are similar to the positive groups and dissimilar to the negative ones",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecommendGroupsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to to getting similar chunks",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/search": {
      "post": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Search Within Group",
        "description": "This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using scores from a cross encoder model.",
        "operationId": "search_within_group",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "X-API-Version",
            "in": "header",
            "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/APIVersion"
                }
              ],
              "nullable": true
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to semantically search a group",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchWithinGroupReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Group chunks which are similar to the embedding vector of the search query",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchGroupResponseTypes"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the groups that the chunk is in",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/tracking_id/{group_tracking_id}/{page}": {
      "get": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Get Chunks in Group by Tracking ID",
        "description": "Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon. Page is 1-indexed.",
        "operationId": "get_chunks_in_group_by_tracking_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "group_tracking_id",
            "in": "path",
            "description": "The id of the group to get the chunks from",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "X-API-Version",
            "in": "header",
            "description": "The version of the API to use for the request",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/APIVersion"
                }
              ],
              "nullable": true
            }
          },
          {
            "name": "page",
            "in": "path",
            "description": "The page of chunks to get from the group",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64",
              "minimum": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Chunks present within the specified group",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetChunksInGroupResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the groups that the chunk is in",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Group not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/tracking_id/{tracking_id}": {
      "get": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Get Group by Tracking ID",
        "description": "Fetch the group with the given tracking id.\nget_group_by_tracking_id",
        "operationId": "get_group_by_tracking_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "tracking_id",
            "in": "path",
            "description": "The tracking id of the group to fetch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "JSON body representing the group with the given tracking id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChunkGroupAndFileId"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the group with the given tracking id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Group not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      },
      "post": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Add Chunk to Group by Tracking ID",
        "description": "Route to add a chunk to a group by tracking id. One of chunk_id or chunk_tracking_id must be provided. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "add_chunk_to_group_by_tracking_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "tracking_id",
            "in": "path",
            "description": "Tracking id of the group to add the chunk to as a bookmark",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to add a chunk to a group via tracking_id",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddChunkToGroupReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Confirmation that the chunk was added to the group"
          },
          "400": {
            "description": "Service error related to adding the chunk group by tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Delete Group by Tracking ID",
        "description": "Delete a chunk_group with the given tracking id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "delete_group_by_tracking_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "tracking_id",
            "in": "path",
            "description": "Tracking id of the chunk_group to delete",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "delete_chunks",
            "in": "query",
            "description": "Delete the chunks within the group",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation that the chunkGroup was deleted"
          },
          "400": {
            "description": "Service error relating to deleting the chunkGroup",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/{group_id}": {
      "get": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Get Group",
        "description": "Fetch the group with the given id.",
        "operationId": "get_chunk_group",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "group_id",
            "in": "path",
            "description": "Id of the group you want to fetch.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "JSON body representing the group with the given tracking id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChunkGroupAndFileId"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the group with the given tracking id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Group not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Delete Group",
        "description": "This will delete a chunk_group. If you set delete_chunks to true, it will also delete the chunks within the group. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "delete_chunk_group",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "group_id",
            "in": "path",
            "description": "Id of the group you want to fetch.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "delete_chunks",
            "in": "query",
            "description": "Delete the chunks within the group",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation that the chunkGroup was deleted"
          },
          "400": {
            "description": "Service error relating to deleting the chunkGroup",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/{group_id}/{page}": {
      "get": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Get Chunks in Group",
        "description": "Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Page is 1-indexed.",
        "operationId": "get_chunks_in_group",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "group_id",
            "in": "path",
            "description": "Id of the group you want to fetch.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "X-API-Version",
            "in": "header",
            "description": "The version of the API to use for the request",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/APIVersion"
                }
              ],
              "nullable": true
            }
          },
          {
            "name": "page",
            "in": "path",
            "description": "The page of chunks to get from the group",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64",
              "nullable": true,
              "minimum": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Chunks present within the specified group",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetChunksInGroupResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the groups that the chunk is in",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Group not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunks": {
      "post": {
        "tags": [
          "Chunk"
        ],
        "summary": "Get Chunks By Ids",
        "description": "Get multiple chunks by multiple ids.",
        "operationId": "get_chunks_by_ids",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "X-API-Version",
            "in": "header",
            "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/APIVersion"
                }
              ],
              "nullable": true
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to get the chunks in the request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetChunksData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "chunks with the id that you were searching for",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ChunkReturnTypes"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to fidning a chunk by tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Any one of the specified chunks not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunks/scroll": {
      "post": {
        "tags": [
          "Chunk"
        ],
        "summary": "Scroll Chunks",
        "description": "Get paginated chunks from your dataset with filters and custom sorting. If sort by is not specified, the results will sort by the id's of the chunks in ascending order. Sort by and offset_chunk_id cannot be used together; if you want to scroll with a sort by then you need to use a must_not filter with the ids you have already seen. There is a limit of 1000 id's in a must_not filter at a time.",
        "operationId": "scroll_dataset_chunks",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to scroll through chunks (chunks)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ScrollChunksReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Number of chunks equivalent to page_size starting from offset_chunk_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScrollChunksResponseBody"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to scrolling chunks",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunks/tracking": {
      "post": {
        "tags": [
          "Chunk"
        ],
        "summary": "Get Chunks By Tracking Ids",
        "description": "Get multiple chunks by ids.",
        "operationId": "get_chunks_by_tracking_ids",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "X-API-Version",
            "in": "header",
            "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/APIVersion"
                }
              ],
              "nullable": true
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to get the chunks in the request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetTrackingChunksData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Chunks with one the ids which were specified",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ChunkReturnTypes"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to finding a chunk by tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/crawl": {
      "get": {
        "tags": [
          "Crawl"
        ],
        "summary": "Get all crawl requests for a dataset",
        "description": "This endpoint is used to get all crawl requests for a dataset.",
        "operationId": "get_crawl_requests_for_dataset",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "The page number to retrieve",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64",
              "nullable": true
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of items to retrieve per page",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64",
              "nullable": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Crawl requests retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CrawlRequest"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to retrieving the crawl requests",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "post": {
        "tags": [
          "Crawl"
        ],
        "summary": "Create a new crawl request",
        "description": "This endpoint is used to create a new crawl request for a dataset. The request payload should contain the crawl options to use for the crawl.",
        "operationId": "create_crawl",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to create a new crawl",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateCrawlReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Crawl created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CrawlRequest"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "Crawl"
        ],
        "summary": "Update a crawl request",
        "description": "This endpoint is used to update an existing crawl request for a dataset. The request payload should contain the crawl id and the crawl options to update for the crawl.",
        "operationId": "update_crawl_request",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to update a crawl",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateCrawlReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Crawl updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CrawlRequest"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to updating the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/crawl/{crawl_id}": {
      "delete": {
        "tags": [
          "Crawl"
        ],
        "summary": "Delete a crawl request",
        "description": "This endpoint is used to delete an existing crawl request for a dataset. The request payload should contain the crawl id to delete.",
        "operationId": "delete_crawl_request",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "crawl_id",
            "in": "path",
            "description": "The id of the crawl to delete",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Crawl deleted successfully"
          },
          "400": {
            "description": "Service error relating to deleting the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/dataset": {
      "post": {
        "tags": [
          "Dataset"
        ],
        "summary": "Create Dataset",
        "description": "Dataset will be created in the org specified via the TR-Organization header. Auth'ed user must be an owner of the organization to create a dataset.",
        "operationId": "create_dataset",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to create a new dataset",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateDatasetReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Dataset created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Dataset"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "Dataset"
        ],
        "summary": "Update Dataset by ID or Tracking ID",
        "description": "One of id or tracking_id must be provided. The auth'ed user must be an owner of the organization to update a dataset.",
        "operationId": "update_dataset",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to update a dataset",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateDatasetReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Dataset updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Dataset"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to updating the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Dataset not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/dataset/batch_create_datasets": {
      "post": {
        "tags": [
          "Dataset"
        ],
        "summary": "Batch Create Datasets",
        "description": "Datasets will be created in the org specified via the TR-Organization header. Auth'ed user must be an owner of the organization to create datasets. If a tracking_id is ignored due to it already existing on the org, the response will not contain a dataset with that tracking_id and it can be assumed that a dataset with the missing tracking_id already exists.",
        "operationId": "batch_create_datasets",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to bulk create datasets",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateDatasetBatchReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Page of tags requested with all tags and the number of chunks in the dataset with that tag plus the total number of unique tags for the whole datset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Datasets"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to finding items by tag",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/dataset/clear/{dataset_id}": {
      "put": {
        "tags": [
          "Dataset"
        ],
        "summary": "Clear Dataset",
        "description": "Removes all chunks, files, and groups from the dataset while retaining the analytics and dataset itself. The auth'ed user must be an owner of the organization to clear a dataset.",
        "operationId": "clear_dataset",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "dataset_id",
            "in": "path",
            "description": "The id of the dataset you want to clear.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Dataset cleared successfully"
          },
          "400": {
            "description": "Service error relating to deleting the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Dataset not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/dataset/clone": {
      "post": {
        "tags": [
          "Dataset"
        ],
        "summary": "Clone Dataset",
        "description": "Clones a dataset and creates a new dataset with the same configuration and chunks. The auth'ed user must be an owner of the organization to clone a dataset.",
        "operationId": "clone_dataset",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to clone a dataset",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CloneDatasetRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Dataset cloned successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Dataset"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to cloning the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Dataset not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/dataset/events": {
      "post": {
        "tags": [
          "Dataset"
        ],
        "summary": "Get events for the dataset",
        "description": "Get events for the dataset specified by the TR-Dataset header.",
        "operationId": "get_events",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to get events for a dataset",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEventsData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Events for the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventReturn"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting events for the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/dataset/files/{dataset_id}/{page}": {
      "get": {
        "tags": [
          "File"
        ],
        "summary": "Get Files and Group IDs for Dataset",
        "description": "Get all files and their group ids which belong to a given dataset specified by the dataset_id parameter. 10 files and group ids are returned per page. This route may return the same file multiple times if the file is associated with multiple groups.",
        "operationId": "get_dataset_files_and_group_ids_handler",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "dataset_id",
            "in": "path",
            "description": "The id of the dataset to fetch files for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "page",
            "in": "path",
            "description": "The page number of files you wish to fetch. Each page contains at most 10 files.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64",
              "minimum": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "JSON body representing the files and their group ids in the current dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileData"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the files in the current datase",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/dataset/get_all_tags": {
      "post": {
        "tags": [
          "Dataset"
        ],
        "summary": "Get All Tags",
        "description": "Scroll through all tags in the dataset and get the number of chunks in the dataset with that tag plus the total number of unique tags for the whole datset.",
        "operationId": "get_all_tags",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to get items with the tag in the request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetAllTagsReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Page of tags requested with all tags and the number of chunks in the dataset with that tag plus the total number of unique tags for the whole datset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetAllTagsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to finding items by tag",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/dataset/groups/{dataset_id}/{page}": {
      "get": {
        "tags": [
          "Chunk Group"
        ],
        "summary": "Get Groups for Dataset",
        "description": "Fetch the groups which belong to a dataset specified by its id.",
        "operationId": "get_groups_for_dataset",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "dataset_id",
            "in": "path",
            "description": "The id of the dataset to fetch groups for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "page",
            "in": "path",
            "description": "The page of groups to fetch. Page is 1-indexed. Only used if `use_cursor` = `false`.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64",
              "nullable": true
            }
          },
          {
            "name": "use_cursor",
            "in": "query",
            "description": "Flag to enable `cursor` mode, this runs faster for large scroll operations. Defaults to false",
            "required": false,
            "schema": {
              "type": "boolean",
              "nullable": true
            }
          },
          {
            "name": "cursor",
            "in": "query",
            "description": "The cursor offset for. Requires `use_cursor` = True. Defaults to `00000000-00000000-00000000-00000000`. Group ids are compared to the cursor using a greater than or equal to.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid",
              "nullable": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "JSON body representing the groups created by the given dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GroupData"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the groups created by the given dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/dataset/organization/{organization_id}": {
      "get": {
        "tags": [
          "Dataset"
        ],
        "summary": "Get Datasets from Organization",
        "description": "Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "get_datasets_from_organization",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "organization_id",
            "in": "path",
            "description": "id of the organization you want to retrieve datasets for",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of records to return",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64",
              "nullable": true
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "The number of records to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64",
              "nullable": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Datasets retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DatasetAndUsage"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to retrieving the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Could not find organization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/dataset/pagefind": {
      "get": {
        "tags": [
          "Dataset"
        ],
        "summary": "Get Pagefind Index Url for Dataset",
        "description": "Returns the root URL for your pagefind index, will error if pagefind is not enabled",
        "operationId": "get_pagefind_index_for_dataset",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Dataset indexed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetPagefindIndexResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating the index",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "Dataset"
        ],
        "summary": "Create Pagefind Index for Dataset",
        "description": "Uses pagefind to index the dataset and store the result into a CDN for retrieval. The auth'ed\nuser must be an admin of the organization to create a pagefind index for a dataset.",
        "operationId": "create_pagefind_index_for_dataset",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Dataset indexed successfully"
          },
          "400": {
            "description": "Service error relating to creating the index",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/dataset/scroll_files": {
      "get": {
        "tags": [
          "File"
        ],
        "summary": "Scroll Files with Groups",
        "description": "Scroll through the files along with their groups in a dataset. This is useful for paginating through files. The cursor is used to fetch the next page of files. The page size is used to specify how many files to fetch per page. The default page size is 10.",
        "operationId": "get_files_cursor_handler",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "cursor",
            "in": "query",
            "description": "The cursor to fetch files from. If not specified, will fetch from the beginning. File ids are compared to the cursor using a greater than or equal to.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid",
              "nullable": true
            }
          },
          {
            "name": "page_size",
            "in": "query",
            "description": "The page size of files you wish to fetch. Defaults to 10.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64",
              "nullable": true,
              "minimum": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "JSON body representing the files along with their associated groups in the current dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetFilesCursorResponseBody"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the files in the current datase",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/dataset/tracking_id/{tracking_id}": {
      "get": {
        "tags": [
          "Dataset"
        ],
        "summary": "Get Dataset by Tracking ID",
        "description": "Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "get_dataset_by_tracking_id",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "tracking_id",
            "in": "path",
            "description": "The tracking id of the dataset you want to retrieve.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Dataset retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Dataset"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to retrieving the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Dataset not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Dataset"
        ],
        "summary": "Delete Dataset by Tracking ID",
        "description": "Auth'ed user must be an owner of the organization to delete a dataset.",
        "operationId": "delete_dataset_by_tracking_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "tracking_id",
            "in": "path",
            "description": "The tracking id of the dataset you want to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Dataset deleted successfully"
          },
          "400": {
            "description": "Service error relating to deleting the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Dataset not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/dataset/usage/{dataset_id}": {
      "get": {
        "tags": [
          "Dataset"
        ],
        "summary": "Get Usage By Dataset ID",
        "description": "Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "get_usage_by_dataset_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "dataset_id",
            "in": "path",
            "description": "The id of the dataset you want to retrieve usage for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Dataset usage retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatasetUsageCount"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to retrieving the dataset usage",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Dataset not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/dataset/{dataset_id}": {
      "get": {
        "tags": [
          "Dataset"
        ],
        "summary": "Get Dataset By ID",
        "description": "Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "get_dataset",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "dataset_id",
            "in": "path",
            "description": "The id of the dataset you want to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Dataset retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Dataset"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to retrieving the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Dataset not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Dataset"
        ],
        "summary": "Delete Dataset",
        "description": "Auth'ed user must be an owner of the organization to delete a dataset.",
        "operationId": "delete_dataset",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "dataset_id",
            "in": "path",
            "description": "The id of the dataset you want to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Dataset deleted successfully"
          },
          "400": {
            "description": "Service error relating to deleting the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Dataset not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/etl/create_job": {
      "post": {
        "tags": [
          "Dataset"
        ],
        "summary": "Create ETL Job",
        "description": "This endpoint is used to create a new ETL job for a dataset.",
        "operationId": "create_etl_job",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to create a new ETL Job",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateSchemaReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "ETL Job created successfully"
          },
          "400": {
            "description": "Service error relating to creating the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/experiment": {
      "get": {
        "tags": [
          "Experiment"
        ],
        "summary": "Get Experiments",
        "description": "Get all experiments for a dataset. Auth'ed user must be an owner of the organization to get experiments.",
        "operationId": "get_experiments",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Experiments retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Experiment"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the experiments",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      },
      "post": {
        "tags": [
          "Experiment"
        ],
        "summary": "Create Experiment",
        "description": "Experiment will be created in the dataset specified via the TR-Dataset header. Auth'ed user must be an owner of the organization to create an experiment.",
        "operationId": "create_experiment",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to create a new experiment",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateExperimentReqBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Experiment created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Experiment"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating the experiment",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "Experiment"
        ],
        "summary": "Update Experiment",
        "description": "Update an experiment. Auth'ed user must be an owner of the organization to update an experiment.",
        "operationId": "update_experiment",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to update an experiment",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateExperimentReqBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Experiment updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Experiment"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to updating the experiment",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/experiment/ab-test": {
      "post": {
        "tags": [
          "Experiment"
        ],
        "summary": "Ab Test",
        "description": "Get a user's treatment for an experiment. Auth'ed user must be an owner of the organization to get a user's treatment.",
        "operationId": "ab_test",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to get a user's treatment",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AbTestReqBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "User treatment response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserTreatmentResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the user's treatment",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/experiment/{experiment_id}": {
      "get": {
        "tags": [
          "Experiment"
        ],
        "summary": "Get Experiment by ID",
        "description": "Get an experiment by ID. Auth'ed user must be an owner of the organization to get an experiment.",
        "operationId": "get_experiment",
        "parameters": [
          {
            "name": "experiment_id",
            "in": "path",
            "description": "The experiment id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Experiment retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Experiment"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the experiment",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Experiment"
        ],
        "summary": "Delete Experiment",
        "description": "Delete an experiment. Auth'ed user must be an owner of the organization to delete an experiment.",
        "operationId": "delete_experiment",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "experiment_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Experiment deleted successfully"
          },
          "400": {
            "description": "Service error relating to deleting the experiment",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/file": {
      "post": {
        "tags": [
          "File"
        ],
        "summary": "Upload File",
        "description": "Upload a file to S3 bucket attached to your dataset. You can select between a naive chunking strategy where the text is extracted with Apache Tika and split into segments with a target number of segments per chunk OR you can use a vision LLM to convert the file to markdown and create chunks per page. You must specifically use a base64url encoding. Auth'ed user must be an admin or owner of the dataset's organization to upload a file.",
        "operationId": "upload_file_handler",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to upload a file",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UploadFileReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Confirmation that the file is uploading",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadFileResponseBody"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to uploading the file",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/file/csv_or_jsonl": {
      "post": {
        "tags": [
          "File"
        ],
        "summary": "Create Presigned CSV/JSONL S3 PUT URL",
        "description": "This route is useful for uploading very large CSV or JSONL files. Once you have completed the upload, chunks will be automatically created from the file for each line in the CSV or JSONL file. The chunks will be indexed and searchable. Auth'ed user must be an admin or owner of the dataset's organization to upload a file.",
        "operationId": "create_presigned_url_for_csv_jsonl",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to upload a CSV or JSONL file",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreatePresignedUrlForCsvJsonlReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "File object information and signed put URL",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreatePresignedUrlForCsvJsonResponseBody"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to uploading the file",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/file/html_page": {
      "post": {
        "tags": [
          "File"
        ],
        "summary": "Upload HTML Page",
        "description": "Chunk HTML by headings and queue for indexing into the specified dataset.",
        "operationId": "upload_html_page",
        "requestBody": {
          "description": "JSON request payload to upload a file",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UploadHtmlPageReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Confirmation that html is being processed"
          },
          "400": {
            "description": "Service error relating to processing the file",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/file/{file_id}": {
      "get": {
        "tags": [
          "File"
        ],
        "summary": "Get File with Signed URL",
        "description": "Get all of the information for a file along with a signed s3 url corresponding to the file_id requested such that you can download the file.",
        "operationId": "get_file_handler",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "file_id",
            "in": "path",
            "description": "The id of the file to fetch",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "ttl",
            "in": "query",
            "description": "The time to live of the signed url in seconds",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "nullable": true,
              "minimum": 0
            }
          },
          {
            "name": "content_type",
            "in": "query",
            "description": "Optional field to override the presigned url's Content-Type header",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The file's information and s3_url where the original file can be downloaded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileDTO"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to finding the file",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "File"
        ],
        "summary": "Delete File",
        "description": "Delete a file from S3 attached to the server based on its id. This will disassociate chunks from the file, but only delete them all together if you specify delete_chunks to be true. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "delete_file_handler",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "file_id",
            "in": "path",
            "description": "The id of the file to delete",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "delete_chunks",
            "in": "query",
            "description": "Delete the chunks within the group",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation that the file has been deleted"
          },
          "400": {
            "description": "Service error relating to finding or deleting the file",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/health": {
      "get": {
        "tags": [
          "Health"
        ],
        "summary": "Health Check",
        "description": "Confirmation that the service is healthy and can make embedding vectors",
        "operationId": "health_check",
        "responses": {
          "200": {
            "description": "Confirmation that the service is healthy and can make embedding vectors"
          },
          "400": {
            "description": "Service error relating to making an embedding or overall service health",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/invitation": {
      "post": {
        "tags": [
          "Invitation"
        ],
        "summary": "Send Invitation",
        "description": "Invitations act as a way to invite users to join an organization. After a user is invited, they will automatically be added to the organization with the role specified in the invitation once they set their. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "post_invitation",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to send an invitation",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InvitationData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Ok response. Indicates that invitation email was sent correctly."
          },
          "400": {
            "description": "Invalid email or some other error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/invitation/{invitation_id}": {
      "delete": {
        "tags": [
          "Invitation"
        ],
        "summary": "Delete Invitation",
        "description": "Delete an invitation by id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "delete_invitation",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "invitation_id",
            "in": "path",
            "description": "The id of the invitation to delete",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Ok response. Indicates that invitation was deleted."
          },
          "400": {
            "description": "Service error relating to deleting invitation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/invitations/{organization_id}": {
      "get": {
        "tags": [
          "Invitation"
        ],
        "summary": "Get Invitations",
        "description": "Get all invitations for the organization. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "get_invitations",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "organization_id",
            "in": "path",
            "description": "The organization id to get invitations for",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Invitations for the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Invitation"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting invitations for the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/message": {
      "post": {
        "tags": [
          "Message"
        ],
        "summary": "Create message",
        "description": "Create message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions.Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "create_message",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to create a message completion",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateMessageReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "This will be a JSON response of a string containing the LLM's generated inference. Response if not streaming.",
            "headers": {
              "TR-QueryID": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": "Query ID that is used for tracking analytics"
              }
            },
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting a chat completion",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "Message"
        ],
        "summary": "Edit message",
        "description": "This will delete the specified message and replace it with a new message. All messages after the message being edited in the sort order will be deleted. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "edit_message",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to edit a message and get a new stream",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EditMessageReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "This will be a HTTP stream, check the chat or search UI for an example how to process this",
            "headers": {
              "TR-QueryID": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": "Query ID that is used for tracking analytics"
              }
            }
          },
          "400": {
            "description": "Service error relating to getting a chat completion",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Message"
        ],
        "summary": "Regenerate message",
        "description": "Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "regenerate_message",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to delete an agent message then regenerate it in a strem",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegenerateMessageReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "This will be a JSON response of a string containing the LLM's generated inference. Response if not streaming.",
            "headers": {
              "TR-QueryID": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": "Query ID that is used for tracking analytics"
              }
            },
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting a chat completion",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "patch": {
        "tags": [
          "Message"
        ],
        "summary": "Regenerate message",
        "description": "Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "regenerate_message_patch",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to delete an agent message then regenerate it in a strem",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegenerateMessageReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "This will be a JSON response of a string containing the LLM's generated inference. Response if not streaming.",
            "headers": {
              "TR-QueryID": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": "Query ID that is used for tracking analytics"
              }
            },
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting a chat completion",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/message/edit_image": {
      "post": {
        "tags": [
          "Message"
        ],
        "summary": "Edit Image",
        "description": "Uses `gpt-image-1` to edit an images based on a given prompt. Note that the images must be\nbase64 encoded and all must have the same mime type.",
        "operationId": "edit_image",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to edit an image",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EditImageReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of base64 encoded images",
            "headers": {
              "TR-QueryID": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": "Query ID that is used for tracking analytics"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ImageEditResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to editing the image",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/message/generate_message_completions": {
      "post": {
        "tags": [
          "Message"
        ],
        "summary": "Generate Message Completions",
        "description": "Uses `openai` to generate a message completion for a given prompt.",
        "operationId": "generate_message_completions",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to generate a message completion",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenerateMessageCompletionsReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The generated message completion",
            "headers": {
              "TR-QueryID": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": "Query ID that is used for tracking analytics"
              }
            },
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to generating a message completion",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/message/get_tool_function_params": {
      "post": {
        "tags": [
          "Message"
        ],
        "summary": "Get tool function parameters",
        "description": "This endpoint will generate the parameters for a tool function based on the user's message and image URL provided in the request body. The response will include the parameters for the tool function as a JSON object.",
        "operationId": "get_tool_function_params",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to get the parameters for a tool function",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetToolFunctionParamsReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A JSON object containing the parameters for the tool function",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetToolFunctionParamsRespBody"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to to updating chunk, likely due to conflicting tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/message/transcribe_audio": {
      "post": {
        "tags": [
          "Message"
        ],
        "summary": "Transcribe Audio",
        "description": "Uses `whisper-1` to transcribe an audio file passed in as a base64 encoded string.",
        "operationId": "transcribe_audio",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to transcribe an audio file",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TranscribeAudioReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The transcribed text",
            "headers": {
              "TR-QueryID": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": "Query ID that is used for tracking analytics"
              }
            },
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to transcribing the audio",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/message/{message_id}": {
      "get": {
        "tags": [
          "Message"
        ],
        "summary": "Get a message by its ID",
        "description": "Quickly get the full object for a given message. From the message, you can get the topic and all messages which exist on that topic.",
        "operationId": "get_message_by_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "message_id",
            "in": "path",
            "description": "The ID of the message to get.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Message with the given ID",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Message"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the message",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/messages/{messages_topic_id}": {
      "get": {
        "tags": [
          "Message"
        ],
        "summary": "Get all messages for a given topic",
        "description": "If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.",
        "operationId": "get_all_topic_messages",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "messages_topic_id",
            "in": "path",
            "description": "The ID of the topic to get messages for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "All messages relating to the topic with the given ID",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Message"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the messages",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/organization": {
      "post": {
        "tags": [
          "Organization"
        ],
        "summary": "Create Organization",
        "description": "Create a new organization. The auth'ed user who creates the organization will be the default owner of the organization.",
        "operationId": "create_organization",
        "requestBody": {
          "description": "The organization data that you want to create",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrganizationReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Created organization object",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Organization"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating the organization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "Organization"
        ],
        "summary": "Update Organization",
        "description": "Update an organization. Only the owner of the organization can update it.",
        "operationId": "update_organization",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The organization data that you want to update",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateOrganizationReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Updated organization object",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Organization"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to updating the organization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/organization/api_key": {
      "get": {
        "tags": [
          "Organization"
        ],
        "summary": "Get Organization Api Keys",
        "description": "Get the api keys which belong to the organization. The actual api key values are not returned, only the ids, names, and creation dates.",
        "operationId": "get_organization_api_keys",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "cursor",
            "in": "query",
            "description": "The cursor to start the pagination from.",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of items to return per page.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "nullable": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "JSON body representing the api_key for the organization",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ApiKeyRespBody"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating api_key for the organization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      },
      "post": {
        "tags": [
          "Organization"
        ],
        "summary": "Create Organization Api Key",
        "description": "Create a new api key for the organization. Successful response will contain the newly created api key.",
        "operationId": "create_organization_api_key",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to create a new organization api key",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateApiKeyReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "JSON body representing the api_key for the organization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateApiKeyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating api_key for the organization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/organization/api_key/{api_key_id}": {
      "delete": {
        "tags": [
          "Organization"
        ],
        "summary": "Delete Organization Api Key",
        "description": "Delete an api key for the auth'ed organization.",
        "operationId": "delete_organization_api_key",
        "parameters": [
          {
            "name": "api_key_id",
            "in": "path",
            "description": "The id of the api key to delete",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation that the api key was deleted"
          },
          "400": {
            "description": "Service error relating to creating api_key for the organization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/organization/update_dataset_configs": {
      "post": {
        "tags": [
          "Organization"
        ],
        "summary": "Update All Dataset Configurations",
        "description": "Update the configurations for all datasets in an organization. Only the specified keys in the configuration object will be changed per dataset such that you can preserve dataset unique values. Auth'ed user or api key must have an owner role for the specified organization.",
        "operationId": "update_all_org_dataset_configs",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The organization data that you want to create",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateAllOrgDatasetConfigsReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Confirmation that the dataset ServerConfigurations were updated successfully"
          },
          "400": {
            "description": "Service error relating to updating the dataset ServerConfigurations",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/organization/usage/{organization_id}": {
      "post": {
        "tags": [
          "Organization"
        ],
        "summary": "Get Organization Usage",
        "description": "Fetch the current usage specification of an organization by its id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "get_organization_usage",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "organization_id",
            "in": "path",
            "description": "The id of the organization you want to fetch the usage of.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The organization usage timeframe that you want to fetch",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetOrganizationUsageReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The current usage of the specified organization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExtendedOrganizationUsageCount"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to finding the organization's usage by id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/organization/users/{organization_id}": {
      "get": {
        "tags": [
          "Organization"
        ],
        "summary": "Get Organization Users",
        "description": "Fetch the users of an organization by its id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "get_organization_users",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "organization_id",
            "in": "path",
            "description": "The id of the organization you want to fetch the users of.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Array of users who belong to the specified by organization",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SlimUser"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to finding the organization's users by id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/organization/{organization_id}": {
      "get": {
        "tags": [
          "Organization"
        ],
        "summary": "Get Organization",
        "description": "Fetch the details of an organization by its id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "get_organization",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "organization_id",
            "in": "path",
            "description": "The id of the organization you want to fetch.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Organization with the id that was requested",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationWithSubAndPlan"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to finding the organization by id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Organization not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Organization"
        ],
        "summary": "Delete Organization",
        "description": "Delete an organization by its id. The auth'ed user must be an owner of the organization to delete it.",
        "operationId": "delete_organization",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "organization_id",
            "in": "path",
            "description": "The id of the organization you want to fetch.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation that the organization was deleted"
          },
          "400": {
            "description": "Service error relating to deleting the organization by id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/public_page/{dataset_id}": {
      "get": {
        "tags": [
          "Public"
        ],
        "operationId": "public_page",
        "parameters": [
          {
            "name": "dataset_id",
            "in": "path",
            "description": "The id or tracking_id of the dataset you want to get the demo page for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Public Page associated to the dataset"
          },
          "400": {
            "description": "Service error relating to loading the public page",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          },
          "404": {
            "description": "Dataset not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/shopify/plan_change": {
      "post": {
        "tags": [
          "Shopify"
        ],
        "operationId": "handle_shopify_plan_change",
        "requestBody": {
          "description": "",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ShopifyPlanChangePayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "No content"
          },
          "400": {
            "description": "Service error relating to Shopify plan change",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/shopify/user_event": {
      "post": {
        "tags": [
          "Public"
        ],
        "summary": "Send a Shopify user event",
        "description": "This endpoint is used to send a Shopify user event to all users in the organization.",
        "operationId": "send_shopify_user_event",
        "requestBody": {
          "description": "The shopify customer data to add to this user",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ShopifyCustomerEvent"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Public Page associated to the dataset"
          },
          "400": {
            "description": "Service error relating to linking your organization to the Shopify store",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/stripe/checkout/setup/{organization_id}": {
      "post": {
        "tags": [
          "Stripe"
        ],
        "summary": "Update Payment Method",
        "description": "Update a your payment method to a new one",
        "operationId": "update_payment_method",
        "parameters": [
          {
            "name": "organization_id",
            "in": "path",
            "description": "The id of the organization to create setup checkout session for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Checkout session (setup) response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateSetupCheckoutSessionResPayload"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating setup checkout session",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/stripe/estimate_bill/{plan_id}": {
      "get": {
        "tags": [
          "Stripe"
        ],
        "summary": "Estimate Bill From Range",
        "description": "Return the amount you will be billed from a date range if you were on usage based pricing",
        "operationId": "estimate_bill_from_range",
        "parameters": [
          {
            "name": "plan_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DateRange"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Billing estimate",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BillingEstimate"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to calculating bill",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/stripe/invoices/{organization_id}": {
      "get": {
        "tags": [
          "Stripe"
        ],
        "summary": "Get All Invoices",
        "description": "Get a list of all invoices",
        "operationId": "get_all_invoices",
        "parameters": [
          {
            "name": "organization_id",
            "in": "path",
            "description": "The id of the organization to get invoices for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of all invoices",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StripeInvoice"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting all invoices",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/stripe/payment_link/{plan_id}/{organization_id}": {
      "get": {
        "tags": [
          "Stripe"
        ],
        "summary": "Checkout",
        "description": "Get a 303 SeeOther redirect link to the stripe checkout page for the plan and organization",
        "operationId": "direct_to_payment_link",
        "parameters": [
          {
            "name": "plan_id",
            "in": "path",
            "description": "id of the plan you want to subscribe to",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "organization_id",
            "in": "path",
            "description": "id of the organization you want to subscribe to the plan",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "303": {
            "description": "SeeOther response redirecting user to stripe checkout page"
          },
          "400": {
            "description": "Service error relating to creating a URL for a stripe checkout page",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/stripe/plans": {
      "get": {
        "tags": [
          "Stripe"
        ],
        "summary": "Get All Plans",
        "description": "Get a list of all plans",
        "operationId": "get_all_plans",
        "responses": {
          "200": {
            "description": "List of all plans",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StripePlan"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting all plans",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/stripe/subscription/{subscription_id}": {
      "delete": {
        "tags": [
          "Stripe"
        ],
        "summary": "Cancel Subscription",
        "description": "Cancel a subscription by its id",
        "operationId": "cancel_subscription",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "subscription_id",
            "in": "path",
            "description": "id of the subscription you want to cancel",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Confirmation that the subscription was cancelled"
          },
          "400": {
            "description": "Service error relating to creating a URL for a stripe checkout page",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/stripe/subscription_plan/{subscription_id}/{plan_id}": {
      "patch": {
        "tags": [
          "Stripe"
        ],
        "summary": "Update Subscription Plan",
        "description": "Update a subscription to a new plan",
        "operationId": "update_subscription_plan",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "subscription_id",
            "in": "path",
            "description": "id of the subscription you want to update",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "plan_id",
            "in": "path",
            "description": "id of the plan you want to subscribe to",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Confirmation that the subscription was updated to the new plan"
          },
          "400": {
            "description": "Service error relating to updating the subscription to the new plan",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/stripe/usage_plans": {
      "get": {
        "tags": [
          "Stripe"
        ],
        "summary": "Get All Usage Plans",
        "description": "Get a list of all usage_based plans",
        "operationId": "get_all_usage_plans",
        "responses": {
          "200": {
            "description": "List of all plans",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StripeUsageBasedPlan"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting all plans",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/topic": {
      "post": {
        "tags": [
          "Topic"
        ],
        "summary": "Create Topic",
        "description": "Create a new chat topic. Topics are attached to a owner_id's and act as a coordinator for conversation message history of gen-AI chat sessions. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "create_topic",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to create chat topic",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTopicReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The JSON response payload containing the created topic",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Topic"
                }
              }
            }
          },
          "400": {
            "description": "Topic name empty or a service error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "Topic"
        ],
        "summary": "Update Topic",
        "description": "Update an existing chat topic. Currently, only the name of the topic can be updated. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "update_topic",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to update a chat topic",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateTopicReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Confirmation that the topic was updated"
          },
          "400": {
            "description": "Service error relating to topic update",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/topic/clone": {
      "post": {
        "tags": [
          "Topic"
        ],
        "summary": "Clone Topic",
        "description": "Create a new chat topic from a `topic_id`. The new topic will be attched to the owner_id and act as a coordinator for conversation message history of gen-AI chat sessions. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "clone_topic",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to create chat topic",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CloneTopicReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The JSON response payload containing the created topic",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Topic"
                }
              }
            }
          },
          "400": {
            "description": "Topic name empty or a service error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/topic/owner/{owner_id}": {
      "get": {
        "tags": [
          "Topic"
        ],
        "summary": "Get All Topics for Owner ID",
        "description": "Get all topics belonging to an arbitary owner_id. This is useful for managing message history and chat sessions. It is common to use a browser fingerprint or your user's id as the owner_id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "get_all_topics_for_owner_id",
        "parameters": [
          {
            "name": "owner_id",
            "in": "path",
            "description": "The owner_id to get topics of; A common approach is to use a browser fingerprint or your user's id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "All topics belonging to a given owner_id",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Topic"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting topics for the owner_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/topic/{topic_id}": {
      "delete": {
        "tags": [
          "Topic"
        ],
        "summary": "Delete Topic",
        "description": "Delete an existing chat topic. When a topic is deleted, all associated chat messages are also deleted. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
        "operationId": "delete_topic",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "topic_id",
            "in": "path",
            "description": "The id of the topic you want to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation that the topic was deleted"
          },
          "400": {
            "description": "Service error relating to topic deletion",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/user": {
      "put": {
        "tags": [
          "User"
        ],
        "summary": "Update User Org Role",
        "description": "Update a user's information for the org specified via header. If the user_id is not provided, the auth'ed user will be updated. If the user_id is provided, the role of the auth'ed user or api key must be an admin (1) or owner (2) of the organization.",
        "operationId": "update_user",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to update user information for the auth'ed user",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateUserReqPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Confirmation that the user's role was updated"
          },
          "400": {
            "description": "Service error relating to updating the user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/user/api_key": {
      "get": {
        "tags": [
          "User"
        ],
        "summary": "Get User Api Keys",
        "description": "Get the api keys which belong to the auth'ed user. The actual api key values are not returned, only the ids, names, and creation dates.",
        "operationId": "get_user_api_keys",
        "responses": {
          "200": {
            "description": "JSON body representing the api_key for the user",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ApiKeyRespBody"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating api_key for the user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/user/api_key/{api_key_id}": {
      "delete": {
        "tags": [
          "User"
        ],
        "summary": "Delete User Api Key",
        "description": "Delete an api key for the auth'ed user.",
        "operationId": "delete_user_api_key",
        "parameters": [
          {
            "name": "api_key_id",
            "in": "path",
            "description": "The id of the api key to delete",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation that the api key was deleted"
          },
          "400": {
            "description": "Service error relating to creating api_key for the user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/metrics": {
      "post": {
        "tags": [
          "Metrics"
        ],
        "summary": "Get Prometheus Metrics",
        "description": "This route allows you to view the number of items in each queue in the Prometheus format.",
        "operationId": "get_metrics",
        "responses": {
          "200": {
            "description": "Prometheus metrics for the server",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "X-API-KEY": []
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "APIVersion": {
        "type": "string",
        "enum": [
          "V1",
          "V2"
        ]
      },
      "AbTestReqBody": {
        "type": "object",
        "required": [
          "experiment_id",
          "user_id"
        ],
        "properties": {
          "experiment_id": {
            "type": "string",
            "format": "uuid"
          },
          "user_id": {
            "type": "string"
          }
        }
      },
      "AddChunkToGroupReqPayload": {
        "type": "object",
        "properties": {
          "chunk_id": {
            "type": "string",
            "format": "uuid",
            "description": "Id of the chunk to make a member of the group.",
            "nullable": true
          },
          "chunk_tracking_id": {
            "type": "string",
            "description": "Tracking Id of the chunk to make a member of the group.",
            "nullable": true
          }
        }
      },
      "AggregationType": {
        "type": "string",
        "enum": [
          "SUM",
          "COUNT",
          "AVG",
          "MIN",
          "MAX"
        ]
      },
      "AnalyticsQuery": {
        "type": "object",
        "description": "Represents a complete Analytics query with parameters",
        "required": [
          "columns",
          "table"
        ],
        "properties": {
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Column"
            },
            "description": "Simple columns to select"
          },
          "cte_query": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CommonTableExpression"
              }
            ],
            "nullable": true
          },
          "expressions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Expression"
            },
            "description": "Complex expressions to select",
            "nullable": true
          },
          "filter_conditions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FilterCondition"
            },
            "description": "WHERE clause conditions",
            "nullable": true
          },
          "group_by": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GroupBy"
              }
            ],
            "nullable": true
          },
          "joins": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/JoinClause"
            },
            "description": "Tables to join with",
            "nullable": true
          },
          "limit": {
            "type": "integer",
            "format": "int32",
            "description": "LIMIT clause",
            "nullable": true,
            "minimum": 0
          },
          "offset": {
            "type": "integer",
            "format": "int32",
            "description": "OFFSET clause",
            "nullable": true,
            "minimum": 0
          },
          "order_by": {
            "allOf": [
              {
                "$ref": "#/components/schemas/OrderBy"
              }
            ],
            "nullable": true
          },
          "table": {
            "$ref": "#/components/schemas/TableName"
          }
        }
      },
      "ApiKeyRequestParams": {
        "type": "object",
        "description": "The default parameters which will be forcibly used when the api key is given on a request. If not provided, the api key will not have default parameters.",
        "properties": {
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "highlight_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/HighlightOptions"
              }
            ],
            "nullable": true
          },
          "no_result_message": {
            "type": "string",
            "description": "Options for handling the response for the llm to return when no results are found",
            "nullable": true
          },
          "page_size": {
            "type": "integer",
            "format": "int64",
            "description": "Page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.",
            "nullable": true,
            "minimum": 0
          },
          "remove_stop_words": {
            "type": "boolean",
            "description": "If true, stop words will be removed. Queries that are entirely stop words will be preserved.",
            "nullable": true
          },
          "score_threshold": {
            "type": "number",
            "format": "float",
            "description": "Set score_threshold to a float to filter out chunks with a score below the threshold.",
            "nullable": true
          },
          "search_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchMethod"
              }
            ],
            "nullable": true
          },
          "slim_chunks": {
            "type": "boolean",
            "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks.",
            "nullable": true
          },
          "typo_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TypoOptions"
              }
            ],
            "nullable": true
          },
          "use_quote_negated_terms": {
            "type": "boolean",
            "description": "If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively.",
            "nullable": true
          }
        }
      },
      "ApiKeyRespBody": {
        "type": "object",
        "required": [
          "id",
          "organization_id",
          "name",
          "role",
          "created_at",
          "updated_at"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid"
          },
          "organization_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "role": {
            "type": "integer",
            "format": "int32"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_ids": [
            "d0d0d0d0-d0d0-d0d0-d0d0-d0d0d0d0d0d0"
          ],
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "name": "Trieve",
          "organization_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "role": 1,
          "updated_at": "2021-01-01 00:00:00.000"
        }
      },
      "AuthQuery": {
        "type": "object",
        "properties": {
          "inv_code": {
            "type": "string",
            "format": "uuid",
            "description": "Code sent via email as a result of successful call to send_invitation",
            "nullable": true
          },
          "organization_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of organization to authenticate into",
            "nullable": true
          },
          "redirect_uri": {
            "type": "string",
            "description": "URL to redirect to after successful login",
            "nullable": true
          }
        },
        "example": {
          "inv_code": "00000000-0000-0000-0000-000000000000",
          "organization_id": "00000000-0000-0000-0000-000000000000",
          "redirect_uri": "https://api.trieve.ai"
        }
      },
      "AutoGenerationConfig": {
        "type": "object",
        "description": "Controls the processing and generation for the segment.\n- `crop_image` controls whether to crop the file's images to the segment's bounding box.\nThe cropped image will be stored in the segment's `image` field. Use `All` to always crop,\nor `Auto` to only crop when needed for post-processing.\n- `html` is the HTML output for the segment, generated either through huerstics (`Auto`) or using Chunkr fine-tuned models (`LLM`)\n- `llm` is the LLM-generated output for the segment, this uses off-the-shelf models to generate a custom output for the segment\n- `markdown` is the Markdown output for the segment, generated either through huerstics (`Auto`) or using Chunkr fine-tuned models (`LLM`)\n- `embed_sources` defines which content sources will be included in the chunk's embed field and counted towards the chunk length.\nThe array's order determines the sequence in which content appears in the embed field (e.g., [Markdown, LLM] means Markdown content\nis followed by LLM content). This directly affects what content is available for embedding and retrieval.",
        "properties": {
          "crop_image": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CroppingStrategy"
              }
            ],
            "default": "Auto"
          },
          "embed_sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EmbedSource"
            },
            "default": "[Markdown]"
          },
          "html": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GenerationStrategy"
              }
            ],
            "default": "Auto"
          },
          "llm": {
            "type": "string",
            "description": "Prompt for the LLM mode",
            "nullable": true
          },
          "markdown": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GenerationStrategy"
              }
            ],
            "default": "Auto"
          }
        }
      },
      "AutocompleteReqPayload": {
        "type": "object",
        "required": [
          "search_type",
          "query"
        ],
        "properties": {
          "content_only": {
            "type": "boolean",
            "description": "Set content_only to true to only returning the chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.",
            "nullable": true
          },
          "extend_results": {
            "type": "boolean",
            "description": "If specified to true, this will extend the search results to include non-exact prefix matches of the same search_type such that a full page_size of results are returned. Default is false.",
            "nullable": true
          },
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "highlight_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/HighlightOptions"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "description": "Metadata is any metadata you want to associate w/ the event that is created from this request",
            "nullable": true
          },
          "page_size": {
            "type": "integer",
            "format": "int64",
            "description": "Page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.",
            "nullable": true,
            "minimum": 0
          },
          "query": {
            "$ref": "#/components/schemas/SearchModalities"
          },
          "remove_stop_words": {
            "type": "boolean",
            "description": "If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.",
            "nullable": true
          },
          "score_threshold": {
            "type": "number",
            "format": "float",
            "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
            "nullable": true
          },
          "scoring_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScoringOptions"
              }
            ],
            "nullable": true
          },
          "search_type": {
            "$ref": "#/components/schemas/SearchMethod"
          },
          "slim_chunks": {
            "type": "boolean",
            "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.",
            "nullable": true
          },
          "sort_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SortOptions"
              }
            ],
            "nullable": true
          },
          "typo_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TypoOptions"
              }
            ],
            "nullable": true
          },
          "use_quote_negated_terms": {
            "type": "boolean",
            "description": "If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.",
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "description": "User ID is the id of the user who is making the request. This is used to track user interactions with the search results.",
            "nullable": true
          }
        },
        "example": {
          "filters": {
            "must": [
              {
                "field": "metadata.key2",
                "match": [
                  "value3",
                  "value4"
                ],
                "range": {
                  "gt": 0.0,
                  "gte": 0.0,
                  "lt": 1.0,
                  "lte": 1.0
                }
              }
            ],
            "must_not": [
              {
                "field": "metadata.key3",
                "match": [
                  "value5",
                  "value6"
                ],
                "range": {
                  "gt": 0.0,
                  "gte": 0.0,
                  "lt": 1.0,
                  "lte": 1.0
                }
              }
            ],
            "should": [
              {
                "field": "metadata.key1",
                "match": [
                  "value1",
                  "value2"
                ],
                "range": {
                  "gt": 0.0,
                  "gte": 0.0,
                  "lt": 1.0,
                  "lte": 1.0
                }
              }
            ]
          },
          "highlight_delimiters": [
            "?",
            ",",
            ".",
            "!"
          ],
          "highlight_results": true,
          "page": 1,
          "page_size": 10,
          "query": "Some search query",
          "recency_bias": 1.0,
          "score_threshold": 0.5,
          "search_type": "semantic",
          "use_weights": true
        }
      },
      "AutocompleteSearchOverGroupsReqPayload": {
        "type": "object",
        "required": [
          "search_type",
          "query"
        ],
        "properties": {
          "extend_results": {
            "type": "boolean",
            "description": "If specified to true, this will extend the search results to include non-exact prefix matches of the same search_type such that a full page_size of results are returned. Default is false.",
            "nullable": true
          },
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "group_size": {
            "type": "integer",
            "format": "int64",
            "description": "Group_size is the number of chunks to fetch for each group. The default is 3. If a group has less than group_size chunks, all chunks will be returned. If this is set to a large number, we recommend setting slim_chunks to true to avoid returning the content and chunk_html of the chunks so as to lower the amount of time required for content download and serialization.",
            "nullable": true,
            "minimum": 0
          },
          "highlight_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/HighlightOptions"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "description": "Metadata is any metadata you want to associate w/ the event that is created from this request",
            "nullable": true
          },
          "page_size": {
            "type": "integer",
            "format": "int64",
            "description": "Page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.",
            "nullable": true,
            "minimum": 0
          },
          "query": {
            "$ref": "#/components/schemas/SearchModalities"
          },
          "remove_stop_words": {
            "type": "boolean",
            "description": "If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.",
            "nullable": true
          },
          "score_threshold": {
            "type": "number",
            "format": "float",
            "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
            "nullable": true
          },
          "scoring_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScoringOptions"
              }
            ],
            "nullable": true
          },
          "search_type": {
            "$ref": "#/components/schemas/SearchMethod"
          },
          "slim_chunks": {
            "type": "boolean",
            "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.",
            "nullable": true
          },
          "sort_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SortOptions"
              }
            ],
            "nullable": true
          },
          "typo_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TypoOptions"
              }
            ],
            "nullable": true
          },
          "use_quote_negated_terms": {
            "type": "boolean",
            "description": "If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.",
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "description": "User ID is the id of the user who is making the request. This is used to track user interactions with the search results.",
            "nullable": true
          }
        },
        "example": {
          "filters": {
            "must": [
              {
                "field": "metadata.key2",
                "match": [
                  "value3",
                  "value4"
                ],
                "range": {
                  "gt": 0.0,
                  "gte": 0.0,
                  "lt": 1.0,
                  "lte": 1.0
                }
              }
            ],
            "must_not": [
              {
                "field": "metadata.key3",
                "match": [
                  "value5",
                  "value6"
                ],
                "range": {
                  "gt": 0.0,
                  "gte": 0.0,
                  "lt": 1.0,
                  "lte": 1.0
                }
              }
            ],
            "should": [
              {
                "field": "metadata.key1",
                "match": [
                  "value1",
                  "value2"
                ],
                "range": {
                  "gt": 0.0,
                  "gte": 0.0,
                  "lt": 1.0,
                  "lte": 1.0
                }
              }
            ]
          },
          "highlight_delimiters": [
            "?",
            ",",
            ".",
            "!"
          ],
          "highlight_results": true,
          "page": 1,
          "page_size": 10,
          "query": "Some search query",
          "recency_bias": 1.0,
          "score_threshold": 0.5,
          "search_type": "semantic",
          "use_weights": true
        }
      },
      "BatchQueuedChunkResponse": {
        "type": "object",
        "title": "batch",
        "required": [
          "chunk_metadata"
        ],
        "properties": {
          "chunk_metadata": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChunkMetadata"
            }
          }
        },
        "example": {
          "chunk_metadata": [
            {
              "content": "Some content",
              "file_id": "d290f1ee-6c54-4b01-90e6-d701748f0851",
              "link": "https://example.com",
              "metadata": {
                "key1": "value1",
                "key2": "value2"
              },
              "tag_set": [
                "tag1",
                "tag2"
              ],
              "time_stamp": "2021-01-01 00:00:00.000",
              "tracking_id": "tracking_id",
              "weight": 0.5
            },
            {
              "content": "Some content",
              "file_id": "d290f1ee-6c54-4b01-90e6-d701748f0851",
              "link": "https://example.com",
              "metadata": {
                "key1": "value1",
                "key2": "value2"
              },
              "tag_set": [
                "tag1",
                "tag2"
              ],
              "time_stamp": "2021-01-01 00:00:00.000",
              "tracking_id": "tracking_id",
              "weight": 0.5
            }
          ],
          "pos_in_queue": 2
        }
      },
      "BillItem": {
        "type": "object",
        "required": [
          "name",
          "clean_name",
          "usage_amount",
          "amount"
        ],
        "properties": {
          "amount": {
            "type": "number",
            "format": "double"
          },
          "clean_name": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "usage_amount": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          }
        }
      },
      "BillingEstimate": {
        "type": "object",
        "required": [
          "items",
          "total"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BillItem"
            }
          },
          "total": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "BulkDeleteChunkPayload": {
        "type": "object",
        "required": [
          "filter"
        ],
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/ChunkFilter"
          }
        }
      },
      "ButtonTrigger": {
        "type": "object",
        "required": [
          "selector",
          "mode"
        ],
        "properties": {
          "mode": {
            "type": "string"
          },
          "removeTriggers": {
            "type": "boolean",
            "nullable": true
          },
          "selector": {
            "type": "string"
          }
        }
      },
      "CTRAnalytics": {
        "oneOf": [
          {
            "type": "object",
            "title": "SearchCTRMetrics",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "search_ctr_metrics"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "SearchesWithClicks",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "searches_with_clicks"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "SearchesWithoutClicks",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "searches_without_clicks"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "RecommendationCTRMetrics",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RecommendationAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "recommendation_ctr_metrics"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "RecommendationsWithClicks",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RecommendationAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "recommendations_with_clicks"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "RecommendationsWithoutClicks",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RecommendationAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "recommendations_without_clicks"
                ]
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "CTRAnalyticsResponse": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SearchCTRMetrics"
          },
          {
            "$ref": "#/components/schemas/CTRSearchQueryWithoutClicksResponse"
          },
          {
            "$ref": "#/components/schemas/CTRSearchQueryWithClicksResponse"
          },
          {
            "$ref": "#/components/schemas/RecommendationCTRMetrics"
          },
          {
            "$ref": "#/components/schemas/CTRRecommendationsWithoutClicksResponse"
          },
          {
            "$ref": "#/components/schemas/CTRRecommendationsWithClicksResponse"
          }
        ]
      },
      "CTRDataRequestBody": {
        "type": "object",
        "required": [
          "request_id",
          "ctr_type",
          "position"
        ],
        "properties": {
          "clicked_chunk_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of chunk that was clicked",
            "nullable": true
          },
          "clicked_chunk_tracking_id": {
            "type": "string",
            "description": "The tracking ID of the chunk that was clicked",
            "nullable": true
          },
          "ctr_type": {
            "$ref": "#/components/schemas/CTRType"
          },
          "metadata": {
            "description": "Any metadata you want to include with the event i.e. action, user_id, etc.",
            "nullable": true
          },
          "position": {
            "type": "integer",
            "format": "int32",
            "description": "The position of the clicked chunk"
          },
          "request_id": {
            "type": "string",
            "format": "uuid",
            "description": "The request id for the CTR data"
          }
        }
      },
      "CTRMetricsOverTimeResponse": {
        "type": "object",
        "required": [
          "total_ctr",
          "points"
        ],
        "properties": {
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FloatTimePoint"
            }
          },
          "total_ctr": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "CTRRecommendationsWithClicksResponse": {
        "type": "object",
        "title": "RecommendationsWithClicks",
        "required": [
          "recommendations"
        ],
        "properties": {
          "recommendations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RecommendationsWithClicksCTRResponse"
            }
          }
        }
      },
      "CTRRecommendationsWithoutClicksResponse": {
        "type": "object",
        "title": "RecommendationsWithoutClicks",
        "required": [
          "recommendations"
        ],
        "properties": {
          "recommendations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RecommendationsWithoutClicksCTRResponse"
            }
          }
        }
      },
      "CTRSearchQueryWithClicksResponse": {
        "type": "object",
        "title": "SearchesWithClicks",
        "required": [
          "queries"
        ],
        "properties": {
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchQueriesWithClicksCTRResponse"
            }
          }
        }
      },
      "CTRSearchQueryWithoutClicksResponse": {
        "type": "object",
        "title": "SearchesWithoutClicks",
        "required": [
          "queries"
        ],
        "properties": {
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchQueriesWithoutClicksCTRResponse"
            }
          }
        }
      },
      "CTRType": {
        "type": "string",
        "enum": [
          "search",
          "rag",
          "recommendation"
        ]
      },
      "ChatAverageRatingResponse": {
        "type": "object",
        "required": [
          "avg_chat_rating",
          "points"
        ],
        "properties": {
          "avg_chat_rating": {
            "type": "number",
            "format": "double"
          },
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FloatTimePoint"
            }
          }
        }
      },
      "ChatConversionRateResponse": {
        "type": "object",
        "required": [
          "conversion_rate",
          "points"
        ],
        "properties": {
          "conversion_rate": {
            "type": "number",
            "format": "double"
          },
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FloatTimePoint"
            }
          }
        }
      },
      "ChatMessageProxy": {
        "type": "object",
        "required": [
          "role",
          "content"
        ],
        "properties": {
          "content": {
            "type": "string"
          },
          "role": {
            "$ref": "#/components/schemas/RoleProxy"
          }
        },
        "example": {
          "content": "Hello, world!",
          "role": "user"
        }
      },
      "ChatRevenueResponse": {
        "type": "object",
        "required": [
          "revenue",
          "points"
        ],
        "properties": {
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FloatTimePoint"
            }
          },
          "revenue": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "ChunkFilter": {
        "type": "object",
        "description": "ChunkFilter is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata.",
        "properties": {
          "must": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConditionType"
            },
            "description": "All of these field conditions have to match for the chunk to be included in the result set.",
            "nullable": true
          },
          "must_not": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConditionType"
            },
            "description": "None of these field conditions can match for the chunk to be included in the result set.",
            "nullable": true
          },
          "should": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConditionType"
            },
            "description": "Only one of these field conditions has to match for the chunk to be included in the result set.",
            "nullable": true
          }
        },
        "example": {
          "must": [
            {
              "field": "tag_set",
              "match_all": [
                "A",
                "B"
              ]
            },
            {
              "field": "num_value",
              "range": {
                "gte": 10,
                "lte": 25
              }
            }
          ]
        }
      },
      "ChunkGroup": {
        "type": "object",
        "required": [
          "id",
          "name",
          "description",
          "created_at",
          "updated_at",
          "dataset_id"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "description": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "metadata": {
            "nullable": true
          },
          "name": {
            "type": "string"
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "description": "All versions and colorways of the oversized t-shirt",
          "metadata": {
            "foo": "bar"
          },
          "name": "Versions of Oversized T-Shirt",
          "tag_set": [
            "tshirt",
            "oversized",
            "clothing"
          ],
          "tracking_id": "SNOVERSIZEDTSHIRT",
          "updated_at": "2021-01-01 00:00:00.000"
        }
      },
      "ChunkGroupAndFileId": {
        "type": "object",
        "required": [
          "id",
          "dataset_id",
          "name",
          "description",
          "created_at",
          "updated_at"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "description": {
            "type": "string"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "metadata": {
            "nullable": true
          },
          "name": {
            "type": "string"
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "description": "A group of chunks",
          "file_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "name": "Trieve",
          "tracking_id": "3",
          "updated_at": "2021-01-01 00:00:00.000"
        }
      },
      "ChunkGroups": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/ChunkGroup"
        },
        "example": [
          {
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "description": "All versions and colorways of the oversized t-shirt",
            "metadata": {
              "foo": "bar"
            },
            "name": "Versions of Oversized T-Shirt",
            "tag_set": [
              "tshirt",
              "oversized",
              "clothing"
            ],
            "tracking_id": "SNOVERSIZEDTSHIRT",
            "updated_at": "2021-01-01 00:00:00.000"
          },
          {
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "description": "All versions and colorways of the slim-fit t-shirt",
            "metadata": {
              "foo": "bar"
            },
            "name": "Versions of Slim-Fit T-Shirt",
            "tag_set": [
              "tshirt",
              "slim",
              "clothing"
            ],
            "tracking_id": "SNSLIMFITTSHIRT",
            "updated_at": "2021-01-01 00:00:00.000"
          }
        ]
      },
      "ChunkHtmlContentReqPayload": {
        "type": "object",
        "required": [
          "chunk_html"
        ],
        "properties": {
          "body_remove_strings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Text strings to remove from body when creating chunks for each page",
            "nullable": true
          },
          "chunk_html": {
            "type": "string",
            "description": "The HTML content to be split into chunks"
          },
          "heading_remove_strings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Text strings to remove from headings when creating chunks for each page",
            "nullable": true
          }
        },
        "example": {
          "body_remove_strings": [
            "Warning:",
            "Note:"
          ],
          "chunk_html": "",
          "heading_remove_strings": [
            "###",
            "##",
            "#"
          ]
        }
      },
      "ChunkMetadata": {
        "type": "object",
        "title": "V2",
        "required": [
          "id",
          "created_at",
          "updated_at",
          "dataset_id",
          "weight"
        ],
        "properties": {
          "chunk_html": {
            "type": "string",
            "description": "HTML content of the chunk, can also be an arbitrary string which is not HTML",
            "nullable": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of the creation of the chunk"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the dataset which the chunk belongs to"
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the chunk, auto-generated uuid created by Trieve"
          },
          "image_urls": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "description": "Image URLs of the chunk, can be any list of strings. Used for image search and RAG.",
            "nullable": true
          },
          "link": {
            "type": "string",
            "description": "Link to the chunk, should be a URL",
            "nullable": true
          },
          "location": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GeoInfo"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "description": "Metadata of the chunk, can be any JSON object",
            "nullable": true
          },
          "num_value": {
            "type": "number",
            "format": "double",
            "description": "Numeric value of the chunk, can be any float. Can represent the most relevant numeric value of the chunk, such as a price, quantity in stock, rating, etc.",
            "nullable": true
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "description": "Tag set of the chunk, can be any list of strings. Used for tag-filtered searches.",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of the chunk, can be any timestamp. Specified by the user.",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "description": "Tracking ID of the chunk, can be any string, determined by the user. Tracking ID's are unique identifiers for chunks within a dataset. They are designed to match the unique identifier of the chunk in the user's system.",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of the last update of the chunk"
          },
          "weight": {
            "type": "number",
            "format": "double",
            "description": "Weight of the chunk, can be any float. Used as a multiplier on a chunk's relevance score for ranking purposes."
          }
        },
        "example": {
          "chunk_html": "<p>Hello, world!</p>",
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "link": "https://trieve.ai",
          "metadata": {
            "key": "value"
          },
          "tag_set": "[tag1,tag2]",
          "time_stamp": "2021-01-01 00:00:00.000",
          "tracking_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "updated_at": "2021-01-01 00:00:00.000",
          "weight": 0.5
        }
      },
      "ChunkMetadataStringTagSet": {
        "type": "object",
        "title": "V1",
        "required": [
          "id",
          "created_at",
          "updated_at",
          "dataset_id",
          "weight"
        ],
        "properties": {
          "chunk_html": {
            "type": "string",
            "nullable": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "image_urls": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "link": {
            "type": "string",
            "nullable": true
          },
          "location": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GeoInfo"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "nullable": true
          },
          "num_value": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "tag_set": {
            "type": "string",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "weight": {
            "type": "number",
            "format": "double"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "link": "https://trieve.ai",
          "metadata": {
            "key": "value"
          },
          "tag_set": "tag1,tag2",
          "time_stamp": "2021-01-01 00:00:00.000",
          "tracking_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "updated_at": "2021-01-01 00:00:00.000",
          "weight": 0.5
        }
      },
      "ChunkMetadataTypes": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SlimChunkMetadata"
          },
          {
            "$ref": "#/components/schemas/ChunkMetadataStringTagSet"
          },
          {
            "$ref": "#/components/schemas/ContentChunkMetadata"
          }
        ]
      },
      "ChunkMetadataWithPosition": {
        "type": "object",
        "required": [
          "chunk",
          "position"
        ],
        "properties": {
          "chunk": {
            "$ref": "#/components/schemas/ChunkMetadata"
          },
          "position": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "ChunkMetadataWithScore": {
        "type": "object",
        "title": "V1",
        "required": [
          "id",
          "created_at",
          "updated_at",
          "dataset_id",
          "weight",
          "score"
        ],
        "properties": {
          "chunk_html": {
            "type": "string",
            "nullable": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "link": {
            "type": "string",
            "nullable": true
          },
          "metadata": {
            "nullable": true
          },
          "score": {
            "type": "number",
            "format": "float"
          },
          "tag_set": {
            "type": "string",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "weight": {
            "type": "number",
            "format": "double"
          }
        },
        "example": {
          "chunk_html": "<p>Hello, world!</p>",
          "content": "Hello, world!",
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "link": "https://trieve.ai",
          "metadata": {
            "key": "value"
          },
          "score": 0.9,
          "tag_set": "tag1,tag2",
          "time_stamp": "2021-01-01 00:00:00.000",
          "tracking_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "updated_at": "2021-01-01 00:00:00.000",
          "weight": 0.5
        }
      },
      "ChunkProcessing": {
        "type": "object",
        "description": "Controls the setting for the chunking and post-processing of each chunk.",
        "properties": {
          "ignore_headers_and_footers": {
            "type": "boolean",
            "description": "Whether to ignore headers and footers in the chunking process.\nThis is recommended as headers and footers break reading order across pages.",
            "default": true
          },
          "target_length": {
            "type": "integer",
            "format": "int32",
            "description": "The target number of words in each chunk. If 0, each chunk will contain a single segment.",
            "default": 512,
            "minimum": 0
          },
          "tokenizer": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TokenizerType"
              }
            ],
            "default": "Word"
          }
        }
      },
      "ChunkReqPayload": {
        "type": "object",
        "title": "single",
        "description": "Request payload for creating a new chunk",
        "properties": {
          "chunk_html": {
            "type": "string",
            "description": "HTML content of the chunk. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content.",
            "nullable": true
          },
          "convert_html_to_text": {
            "type": "boolean",
            "description": "Convert HTML to raw text before processing to avoid adding noise to the vector embeddings. By default this is true. If you are using HTML content that you want to be included in the vector embeddings, set this to false.",
            "nullable": true
          },
          "fulltext_boost": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FullTextBoost"
              }
            ],
            "nullable": true
          },
          "fulltext_content": {
            "type": "string",
            "description": "If fulltext_content is present, it will be used for creating the fulltext and bm25 sparse vectors instead of the innerText `chunk_html`. `chunk_html` will still be the only thing stored and used for semantic functionality unless the corresponding `semantic_content` field is defined. `chunk_html` must still be present for the chunk to be created properly.",
            "nullable": true
          },
          "group_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Group ids are the Trieve generated ids of the groups that the chunk should be placed into. This is useful for when you want to create a chunk and add it to a group or multiple groups in one request. Groups with these Trieve generated ids must be created first, it cannot be arbitrarily created through this route.",
            "nullable": true
          },
          "group_tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Group tracking_ids are the user-assigned tracking_ids of the groups that the chunk should be placed into. This is useful for when you want to create a chunk and add it to a group or multiple groups in one request. If a group with the tracking_id does not exist, it will be created.",
            "nullable": true
          },
          "high_priority": {
            "type": "boolean",
            "description": "High Priority allows you to place this chunk into a priority queue with its own ingestion workers. Can only be used by users with a Custom Pro plan.",
            "nullable": true
          },
          "image_urls": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Image urls are a list of urls to images that are associated with the chunk. This is useful for when you want to associate images with a chunk.",
            "nullable": true
          },
          "link": {
            "type": "string",
            "description": "Link to the chunk. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation.",
            "nullable": true
          },
          "location": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GeoInfo"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "description": "Metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata.",
            "nullable": true
          },
          "num_value": {
            "type": "number",
            "format": "double",
            "description": "Num value is an arbitrary numerical value that can be used to filter chunks. This is useful for when you want to filter chunks by numerical value. There is no performance hit for filtering on num_value.",
            "nullable": true
          },
          "semantic_boost": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SemanticBoost"
              }
            ],
            "nullable": true
          },
          "semantic_content": {
            "type": "string",
            "description": "If semantic_content is present, it will be used for creating semantic embeddings instead of the innerText `chunk_html`. `chunk_html` will still be the only thing stored and used for fulltext functionality unless the corresponding `fulltext_content` field is defined. `chunk_html` must still be present for the chunk to be created properly.",
            "nullable": true
          },
          "split_avg": {
            "type": "boolean",
            "description": "Split avg is a boolean which tells the server to split the text in the chunk_html into smaller chunks and average their resulting vectors. This is useful for when you want to create a chunk from a large piece of text and want to split it into smaller chunks to create a more fuzzy average dense vector. The sparse vector will be generated normally with no averaging. By default this is false.",
            "nullable": true
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tag set is a list of tags. This can be used to filter chunks by tag. Unlike with metadata filtering, HNSW indices will exist for each tag such that there is not a performance hit for filtering on them.",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "description": "Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results.",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "description": "Tracking_id is a string which can be used to identify a chunk. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.",
            "nullable": true
          },
          "upsert_by_tracking_id": {
            "type": "boolean",
            "description": "Upsert when a chunk with the same tracking_id exists. By default this is false, and chunks will be ignored if another with the same tracking_id exists. If this is true, the chunk will be updated if a chunk with the same tracking_id exists.",
            "nullable": true
          },
          "weight": {
            "type": "number",
            "format": "double",
            "description": "Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk's dataset dataset.",
            "nullable": true
          }
        },
        "example": {
          "chunk_html": "<p>Some HTML content</p>",
          "fulltext_boost": {
            "boost_factor": 5.0,
            "phrase": "foo"
          },
          "group_ids": [
            "d290f1ee-6c54-4b01-90e6-d701748f0851"
          ],
          "group_tracking_ids": [
            "group_tracking_id"
          ],
          "image_urls": [
            "https://example.com/red",
            "https://example.com/blue"
          ],
          "link": "https://example.com",
          "location": {
            "lat": -34,
            "lon": 151
          },
          "metadata": {
            "key1": "value1",
            "key2": "value2"
          },
          "semantic_boost": {
            "distance_factor": 0.5,
            "phrase": "flagship"
          },
          "tag_set": [
            "tag1",
            "tag2"
          ],
          "time_stamp": "2021-01-01 00:00:00.000",
          "tracking_id": "tracking_id"
        }
      },
      "ChunkReqPayloadFields": {
        "type": "string",
        "description": "The key in the ChunkReqPayload which you can map a column or field from the CSV or JSONL file to.",
        "enum": [
          "link",
          "tag_set",
          "num_value",
          "tracking_id",
          "group_tracking_ids",
          "time_stamp",
          "lat",
          "lon",
          "image_urls",
          "weight",
          "boost_phrase"
        ]
      },
      "ChunkReqPayloadMapping": {
        "type": "object",
        "description": "Express a mapping between a column or field in a CSV or JSONL field and a key in the ChunkReqPayload created for each row or object.",
        "required": [
          "csv_jsonl_field",
          "chunk_req_payload_field"
        ],
        "properties": {
          "chunk_req_payload_field": {
            "$ref": "#/components/schemas/ChunkReqPayloadFields"
          },
          "csv_jsonl_field": {
            "type": "string",
            "description": "The column or field in the CSV or JSONL file that you want to map to a key in the ChunkReqPayload"
          }
        }
      },
      "ChunkReqPayloadMappings": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/ChunkReqPayloadMapping"
        },
        "description": "Specify all of the mappings between columns or fields in a CSV or JSONL file and keys in the ChunkReqPayload. Array fields like tag_set, image_urls, and group_tracking_ids can have multiple mappings. Boost phrase can also have multiple mappings which get concatenated. Other fields can only have one mapping and only the last mapping will be used."
      },
      "ChunkReturnTypes": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/ChunkMetadata"
          },
          {
            "$ref": "#/components/schemas/ChunkMetadataStringTagSet"
          }
        ]
      },
      "ChunkWithPosition": {
        "type": "object",
        "required": [
          "chunk_id",
          "position"
        ],
        "properties": {
          "chunk_id": {
            "type": "string",
            "format": "uuid"
          },
          "position": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "ChunkedContent": {
        "type": "object",
        "required": [
          "headings",
          "body"
        ],
        "properties": {
          "body": {
            "type": "string",
            "description": "The body of the content"
          },
          "headings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The headings of the content in order of when they appear"
          }
        },
        "example": {
          "body": "This is the body of the content",
          "headings": [
            "Title Heading",
            "Sub Heading 1",
            "Last SubHeading"
          ]
        }
      },
      "ClickhouseRagTypes": {
        "type": "string",
        "enum": [
          "chosen_chunks",
          "all_chunks"
        ]
      },
      "ClickhouseRecommendationTypes": {
        "type": "string",
        "enum": [
          "Chunk",
          "Group"
        ]
      },
      "ClickhouseSearchTypes": {
        "type": "string",
        "enum": [
          "search",
          "search_over_groups",
          "autocomplete",
          "rag"
        ]
      },
      "ClickhouseTopicAnalyticsSummary": {
        "type": "object",
        "required": [
          "id",
          "name",
          "topic_id",
          "owner_id",
          "created_at",
          "updated_at",
          "message_count",
          "avg_top_score",
          "avg_hallucination_score",
          "event_names"
        ],
        "properties": {
          "avg_hallucination_score": {
            "type": "number",
            "format": "double"
          },
          "avg_query_rating": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "avg_top_score": {
            "type": "number",
            "format": "double"
          },
          "created_at": {
            "type": "string"
          },
          "event_names": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "All event_names that are  associated with the topic, may contain duplicate names"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "message_count": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "name": {
            "type": "string"
          },
          "owner_id": {
            "type": "string"
          },
          "topic_id": {
            "type": "string",
            "format": "uuid"
          },
          "updated_at": {
            "type": "string"
          }
        }
      },
      "CloneDatasetRequest": {
        "type": "object",
        "required": [
          "dataset_to_clone",
          "dataset_name"
        ],
        "properties": {
          "clone_chunks": {
            "type": "boolean",
            "description": "Parameter to Clone Chunks from the original dataset to the new dataset. defaults to true.",
            "nullable": true
          },
          "dataset_name": {
            "type": "string",
            "description": "Name of the dataset."
          },
          "dataset_to_clone": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the dataset you want to clone."
          },
          "tracking_id": {
            "type": "string",
            "description": "Optional tracking ID for the dataset. Can be used to track the dataset in external systems. Must be unique within the organization. Strongly recommended to not use a valid uuid value as that will not work with the TR-Dataset header.",
            "nullable": true
          }
        },
        "example": {
          "dataset_name": "My Dataset",
          "dataset_to_clone": "00000000-0000-0000-0000-000000000000",
          "organization_id": "00000000-0000-0000-0000-000000000000",
          "server_configuration": {
            "AIMON_RERANKER_TASK_DEFINITION": "Your task is to grade the relevance of context document(s) against the specified user query.",
            "BM25_AVG_LEN": 256.0,
            "BM25_B": 0.75,
            "BM25_ENABLED": true,
            "BM25_K": 0.75,
            "DISTANCE_METRIC": "cosine",
            "EMBEDDING_BASE_URL": "https://api.openai.com/v1",
            "EMBEDDING_MODEL_NAME": "text-embedding-3-small",
            "EMBEDDING_QUERY_PREFIX": "",
            "EMBEDDING_SIZE": 1536,
            "FREQUENCY_PENALTY": 0.0,
            "FULLTEXT_ENABLED": true,
            "INDEXED_ONLY": false,
            "LLM_BASE_URL": "https://api.openai.com/v1",
            "LLM_DEFAULT_MODEL": "gpt-3.5-turbo-1106",
            "LOCKED": false,
            "MAX_LIMIT": 10000,
            "MESSAGE_TO_QUERY_PROMPT": "Write a 1-2 sentence semantic search query along the lines of a hypothetical response to: \n\n",
            "N_RETRIEVALS_TO_INCLUDE": 8,
            "PRESENCE_PENALTY": 0.0,
            "QDRANT_ONLY": false,
            "RAG_PROMPT": "Use the following retrieved documents to respond briefly and accurately:",
            "SEMANTIC_ENABLED": true,
            "STOP_TOKENS": [
              "\n\n",
              "\n"
            ],
            "SYSTEM_PROMPT": "You are a helpful assistant",
            "TEMPERATURE": 0.5,
            "USE_MESSAGE_TO_QUERY_PROMPT": false
          }
        }
      },
      "CloneTopicReqPayload": {
        "type": "object",
        "required": [
          "topic_id",
          "owner_id"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the topic. If this is not provided, the topic name is the same as the previous topic",
            "nullable": true
          },
          "owner_id": {
            "type": "string",
            "description": "The owner_id of the topic. This is typically a browser fingerprint or your user's id. It is used to group topics together for a user."
          },
          "topic_id": {
            "type": "string",
            "format": "uuid",
            "description": "The topic_id to clone from"
          }
        }
      },
      "ClusterAnalytics": {
        "oneOf": [
          {
            "type": "object",
            "title": "ClusterTopics",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClusterAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "cluster_topics"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "ClusterQueries",
            "required": [
              "cluster_id",
              "type"
            ],
            "properties": {
              "cluster_id": {
                "type": "string",
                "format": "uuid"
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "cluster_queries"
                ]
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "ClusterAnalyticsFilter": {
        "type": "object",
        "properties": {
          "date_range": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DateRange"
              }
            ],
            "nullable": true
          }
        }
      },
      "ClusterAnalyticsResponse": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SearchClusterResponse"
          },
          {
            "$ref": "#/components/schemas/SearchQueryResponse"
          }
        ]
      },
      "Column": {
        "type": "object",
        "description": "Represents a column with optional aggregation and alias",
        "required": [
          "name"
        ],
        "properties": {
          "aggregation": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AggregationType"
              }
            ],
            "nullable": true
          },
          "alias": {
            "type": "string",
            "nullable": true
          },
          "distinct": {
            "type": "boolean",
            "nullable": true
          },
          "name": {
            "type": "string"
          }
        }
      },
      "CommonTableExpression": {
        "type": "object",
        "required": [
          "alias",
          "query"
        ],
        "properties": {
          "alias": {
            "type": "string"
          },
          "query": {
            "$ref": "#/components/schemas/SubQuery"
          }
        }
      },
      "ComponentAnalytics": {
        "oneOf": [
          {
            "type": "object",
            "title": "TotalUniqueUsers",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ComponentAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "total_unique_users"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "TopPages",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ComponentAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "top_pages"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "TopComponents",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ComponentAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "top_components"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "ComponentNames",
            "required": [
              "type"
            ],
            "properties": {
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "component_names"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "ComponentInteractionTime",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ComponentAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "component_interaction_time"
                ]
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "ComponentAnalyticsFilter": {
        "type": "object",
        "properties": {
          "component_name": {
            "type": "string",
            "nullable": true
          },
          "date_range": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DateRange"
              }
            ],
            "nullable": true
          }
        }
      },
      "ComponentAnalyticsResponse": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/TotalUniqueUsersResponse"
          },
          {
            "$ref": "#/components/schemas/TopPagesResponse"
          },
          {
            "$ref": "#/components/schemas/TopComponentsResponse"
          },
          {
            "$ref": "#/components/schemas/ComponentNamesResponse"
          },
          {
            "$ref": "#/components/schemas/ComponentInteractionTimeResponse"
          }
        ]
      },
      "ComponentInteractionTimeResponse": {
        "type": "object",
        "required": [
          "avg_interaction_time",
          "points"
        ],
        "properties": {
          "avg_interaction_time": {
            "type": "number",
            "format": "double"
          },
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FloatTimePoint"
            }
          }
        }
      },
      "ComponentNamesResponse": {
        "type": "object",
        "required": [
          "component_names"
        ],
        "properties": {
          "component_names": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ConditionType": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/FieldCondition"
          },
          {
            "$ref": "#/components/schemas/HasChunkIDCondition"
          }
        ],
        "description": "Filters can be constructed using either fields on the chunk objects, ids or tracking ids of chunks, and finally ids or tracking ids of groups."
      },
      "ContentChunkMetadata": {
        "type": "object",
        "title": "ContentChunkMetadata",
        "required": [
          "id",
          "weight"
        ],
        "properties": {
          "chunk_html": {
            "type": "string",
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "image_urls": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "num_value": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "nullable": true
          },
          "weight": {
            "type": "number",
            "format": "double"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "link": "https://trieve.ai",
          "metadata": {
            "key": "value"
          },
          "tag_set": "tag1,tag2",
          "time_stamp": "2021-01-01 00:00:00.000",
          "tracking_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "updated_at": "2021-01-01 00:00:00.000",
          "weight": 0.5
        }
      },
      "ContextOptions": {
        "type": "object",
        "description": "Context options to use for the completion. If not specified, all options will default to false.",
        "properties": {
          "include_links": {
            "type": "boolean",
            "description": "Include links in the context. If not specified, this defaults to false.",
            "nullable": true
          }
        }
      },
      "CountChunkQueryResponseBody": {
        "type": "object",
        "required": [
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "format": "int32",
            "minimum": 0
          }
        }
      },
      "CountChunksReqPayload": {
        "type": "object",
        "required": [
          "search_type",
          "query"
        ],
        "properties": {
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "Set limit to restrict the maximum number of chunks to count. This is useful for when you want to reduce the latency of the count operation. By default the limit will be the number of chunks in the dataset.",
            "nullable": true,
            "minimum": 0
          },
          "query": {
            "$ref": "#/components/schemas/QueryTypes"
          },
          "score_threshold": {
            "type": "number",
            "format": "float",
            "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
            "nullable": true
          },
          "search_type": {
            "$ref": "#/components/schemas/CountSearchMethod"
          },
          "use_quote_negated_terms": {
            "type": "boolean",
            "description": "If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.",
            "nullable": true
          }
        },
        "example": {
          "query": "Some search query",
          "score_threshold": 0.5,
          "search_type": "semantic"
        }
      },
      "CountSearchMethod": {
        "type": "string",
        "enum": [
          "fulltext",
          "semantic",
          "bm25"
        ]
      },
      "CrawlInterval": {
        "type": "string",
        "description": "Interval at which specified site should be re-scraped",
        "enum": [
          "daily",
          "weekly",
          "monthly"
        ]
      },
      "CrawlOpenAPIOptions": {
        "type": "object",
        "title": "CrawlOpenAPIOptions",
        "description": "Options for including an openapi spec in the crawl",
        "required": [
          "openapi_schema_url",
          "openapi_tag"
        ],
        "properties": {
          "openapi_schema_url": {
            "type": "string",
            "description": "OpenAPI json schema to be processed alongside the site crawl"
          },
          "openapi_tag": {
            "type": "string",
            "description": "Tag to look for to determine if a page should create an openapi route chunk instead of chunks from heading-split of the HTML"
          }
        }
      },
      "CrawlOptions": {
        "type": "object",
        "description": "Options for setting up the crawl which will populate the dataset.",
        "properties": {
          "add_chunks_to_dataset": {
            "type": "boolean",
            "description": "Add chunks to the dataset that the crawl is created for, defaults to true",
            "nullable": true
          },
          "allow_external_links": {
            "type": "boolean",
            "description": "Option for allowing the crawl to follow links to external websites.",
            "nullable": true
          },
          "body_remove_strings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Text strings to remove from body when creating chunks for each page",
            "nullable": true
          },
          "boost_titles": {
            "type": "boolean",
            "description": "Boost titles such that keyword matches in titles are prioritized in search results. Strongly recommended to leave this on. Defaults to true.",
            "nullable": true
          },
          "exclude_paths": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "URL Patterns to exclude from the crawl",
            "nullable": true
          },
          "exclude_tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Specify the HTML tags, classes and ids to exclude from the response.",
            "nullable": true
          },
          "heading_remove_strings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Text strings to remove from headings when creating chunks for each page",
            "nullable": true
          },
          "ignore_sitemap": {
            "type": "boolean",
            "description": "Ignore the website sitemap when crawling, defaults to true.",
            "nullable": true
          },
          "include_paths": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "URL Patterns to include in the crawl",
            "nullable": true
          },
          "include_tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Specify the HTML tags, classes and ids to include in the response.",
            "nullable": true
          },
          "interval": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CrawlInterval"
              }
            ],
            "nullable": true
          },
          "limit": {
            "type": "integer",
            "format": "int32",
            "description": "How many pages to crawl, defaults to 1000",
            "nullable": true
          },
          "scrape_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScrapeOptions"
              }
            ],
            "nullable": true
          },
          "site_url": {
            "type": "string",
            "description": "The URL to crawl",
            "nullable": true
          },
          "webhook_metadata": {
            "description": "Metadata to send back with the webhook call for each successful page scrape",
            "nullable": true
          },
          "webhook_urls": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Host to call back on the webhook for each successful page scrape",
            "nullable": true
          }
        },
        "example": {
          "crawl_options": {
            "allow_external_links": false,
            "boost_titles": true,
            "exclude_tags": [
              "#ad",
              "#footer",
              "header",
              "head",
              "navbar",
              "footer",
              "aside",
              "nav",
              "form"
            ],
            "heading_remove_strings": [
              "Advertisement",
              "Sponsored"
            ],
            "ignore_sitemap": true,
            "include_tags": [],
            "interval": "daily",
            "limit": 50,
            "site_url": "nedzo.ai"
          }
        }
      },
      "CrawlRequest": {
        "type": "object",
        "required": [
          "id",
          "url",
          "status",
          "crawl_type",
          "crawl_options",
          "scrape_id",
          "dataset_id",
          "created_at",
          "attempt_number"
        ],
        "properties": {
          "attempt_number": {
            "type": "integer",
            "format": "int32"
          },
          "crawl_options": {
            "$ref": "#/components/schemas/CrawlOptions"
          },
          "crawl_type": {
            "$ref": "#/components/schemas/CrawlType"
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "interval": {
            "type": "string",
            "nullable": true
          },
          "next_crawl_at": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "scrape_id": {
            "type": "string",
            "format": "uuid"
          },
          "status": {
            "$ref": "#/components/schemas/CrawlStatus"
          },
          "url": {
            "type": "string"
          }
        }
      },
      "CrawlShopifyOptions": {
        "type": "object",
        "title": "CrawlShopifyOptions",
        "description": "Options for Crawling Shopify",
        "properties": {
          "group_variants": {
            "type": "boolean",
            "description": "This option will ingest all variants as individual chunks and place them in groups by product id. Turning this off will only scrape 1 variant per product. default: true",
            "nullable": true
          },
          "tag_regexes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          }
        }
      },
      "CrawlStatus": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "Pending"
            ]
          },
          {
            "type": "object",
            "required": [
              "Processing"
            ],
            "properties": {
              "Processing": {
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          {
            "type": "string",
            "enum": [
              "Completed"
            ]
          },
          {
            "type": "string",
            "enum": [
              "Failed"
            ]
          }
        ]
      },
      "CrawlType": {
        "type": "string",
        "enum": [
          "firecrawl",
          "openapi",
          "shopify",
          "youtube"
        ]
      },
      "CrawlYoutubeOptions": {
        "type": "object",
        "title": "CrawlYoutubeOptions",
        "description": "Options for Crawling Youtube"
      },
      "CreateApiKeyReqPayload": {
        "type": "object",
        "required": [
          "name",
          "role"
        ],
        "properties": {
          "dataset_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "The dataset ids which the api key will have access to. If not provided or empty, the api key will have access to all datasets in the dataset.",
            "nullable": true
          },
          "default_params": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiKeyRequestParams"
              }
            ],
            "nullable": true
          },
          "expires_at": {
            "type": "string",
            "description": "The expiration date of the api key. If not provided, the api key will not expire. This should be provided in UTC time.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "The name which will be assigned to the new api key."
          },
          "role": {
            "type": "integer",
            "format": "int32",
            "description": "The role which will be assigned to the new api key. Either 0 (read), 1 (Admin) or 2 (Owner). The auth'ed user must have a role greater than or equal to the role being assigned."
          },
          "scopes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The routes which the api key will have access to. If not provided or empty, the api key will have access to all routes. Specify the routes as a list of strings. For example, [\"GET /api/dataset\", \"POST /api/dataset\"].",
            "nullable": true
          }
        }
      },
      "CreateApiKeyResponse": {
        "type": "object",
        "required": [
          "api_key"
        ],
        "properties": {
          "api_key": {
            "type": "string",
            "description": "The api key which was created. This is the value which should be used in the Authorization header."
          }
        }
      },
      "CreateApiUserBody": {
        "type": "object",
        "required": [
          "user_email",
          "user_name"
        ],
        "properties": {
          "user_email": {
            "type": "string"
          },
          "user_name": {
            "type": "string"
          }
        }
      },
      "CreateApiUserResponse": {
        "type": "object",
        "required": [
          "user",
          "organization_id",
          "api_key"
        ],
        "properties": {
          "api_key": {
            "type": "string"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid"
          },
          "user": {
            "$ref": "#/components/schemas/SlimUser"
          }
        }
      },
      "CreateBatchChunkGroupReqPayload": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/CreateSingleChunkGroupReqPayload"
        },
        "example": [
          {
            "description": "All versions and colorways of the oversized t-shirt",
            "metadata": {
              "foo": "bar"
            },
            "name": "Versions of Oversized T-Shirt",
            "tag_set": [
              "tshirt",
              "oversized",
              "clothing"
            ],
            "tracking_id": "SNOVERSIZEDTSHIRT",
            "upsert_by_tracking_id": false
          },
          {
            "description": "All versions and colorways of the slim-fit t-shirt",
            "metadata": {
              "foo": "bar"
            },
            "name": "Versions of Slim-Fit T-Shirt",
            "tag_set": [
              "tshirt",
              "slim",
              "clothing"
            ],
            "tracking_id": "SNSLIMFITTSHIRT",
            "upsert_by_tracking_id": false
          }
        ]
      },
      "CreateBatchChunkReqPayload": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/ChunkReqPayload"
        },
        "example": [
          {
            "chunk_html": "<p>Some HTML content</p>",
            "group_ids": [
              "d290f1ee-6c54-4b01-90e6-d701748f0851"
            ],
            "group_tracking_ids": [
              "group_tracking_id"
            ],
            "image_urls": [
              "https://example.com/red",
              "https://example.com/blue"
            ],
            "link": "https://example.com",
            "location": {
              "lat": -34,
              "lon": 151
            },
            "metadata": {
              "key1": "value1",
              "key2": "value2"
            },
            "tag_set": [
              "tag1",
              "tag2"
            ],
            "time_stamp": "2021-01-01 00:00:00.000",
            "tracking_id": "tracking_id",
            "upsert_by_tracking_id": true
          },
          {
            "chunk_html": "<p>Some more HTML content</p>",
            "group_ids": [
              "d290f1ee-6c54-4b01-90e6-d701748f0851"
            ],
            "group_tracking_ids": [
              "group_tracking_id"
            ],
            "image_urls": [],
            "link": "https://explain.com",
            "location": {
              "lat": -34,
              "lon": 151
            },
            "metadata": {
              "key1": "value1",
              "key2": "value2"
            },
            "tag_set": [
              "tag3",
              "tag4"
            ],
            "time_stamp": "2021-01-01 00:00:00.000",
            "tracking_id": "tracking_id",
            "upsert_by_tracking_id": true,
            "weight": 0.5
          }
        ]
      },
      "CreateBatchDataset": {
        "type": "object",
        "required": [
          "dataset_name"
        ],
        "properties": {
          "dataset_name": {
            "type": "string",
            "description": "Name of the dataset."
          },
          "server_configuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DatasetConfigurationDTO"
              }
            ],
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "description": "Optional tracking ID for the dataset. Can be used to track the dataset in external systems. Must be unique within the organization. Strongly recommended to not use a valid uuid value as that will not work with the TR-Dataset header.",
            "nullable": true
          }
        }
      },
      "CreateChunkGroupReqPayloadEnum": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/CreateSingleChunkGroupReqPayload"
          },
          {
            "$ref": "#/components/schemas/CreateBatchChunkGroupReqPayload"
          }
        ]
      },
      "CreateChunkGroupResponseEnum": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/ChunkGroup"
          },
          {
            "$ref": "#/components/schemas/ChunkGroups"
          }
        ]
      },
      "CreateChunkReqPayloadEnum": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/CreateSingleChunkReqPayload"
          },
          {
            "$ref": "#/components/schemas/CreateBatchChunkReqPayload"
          }
        ]
      },
      "CreateCrawlReqPayload": {
        "type": "object",
        "required": [
          "crawl_options"
        ],
        "properties": {
          "crawl_options": {
            "$ref": "#/components/schemas/CrawlOptions"
          }
        }
      },
      "CreateDatasetBatchReqPayload": {
        "type": "object",
        "required": [
          "datasets"
        ],
        "properties": {
          "datasets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateBatchDataset"
            },
            "description": "List of datasets to create"
          },
          "upsert": {
            "type": "boolean",
            "description": "Upsert when a dataset with one of the specified tracking_ids already exists. By default this is false and specified datasets with a tracking_id that already exists in the org will not be ignored. If true, the existing dataset will be updated with the new dataset's details.",
            "nullable": true
          }
        }
      },
      "CreateDatasetReqPayload": {
        "type": "object",
        "required": [
          "dataset_name"
        ],
        "properties": {
          "dataset_name": {
            "type": "string",
            "description": "Name of the dataset."
          },
          "server_configuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DatasetConfigurationDTO"
              }
            ],
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "description": "Optional tracking ID for the dataset. Can be used to track the dataset in external systems. Must be unique within the organization. Strongly recommended to not use a valid uuid value as that will not work with the TR-Dataset header.",
            "nullable": true
          }
        },
        "example": {
          "dataset_name": "My Dataset",
          "organization_id": "00000000-0000-0000-0000-000000000000",
          "server_configuration": {
            "AIMON_RERANKER_TASK_DEFINITION": "Your task is to grade the relevance of context document(s) against the specified user query.",
            "BM25_AVG_LEN": 256.0,
            "BM25_B": 0.75,
            "BM25_ENABLED": true,
            "BM25_K": 0.75,
            "DISTANCE_METRIC": "cosine",
            "EMBEDDING_BASE_URL": "https://api.openai.com/v1",
            "EMBEDDING_MODEL_NAME": "text-embedding-3-small",
            "EMBEDDING_QUERY_PREFIX": "",
            "EMBEDDING_SIZE": 1536,
            "FREQUENCY_PENALTY": 0.0,
            "FULLTEXT_ENABLED": true,
            "INDEXED_ONLY": false,
            "LLM_BASE_URL": "https://api.openai.com/v1",
            "LLM_DEFAULT_MODEL": "gpt-3.5-turbo-1106",
            "LOCKED": false,
            "MAX_LIMIT": 10000,
            "MESSAGE_TO_QUERY_PROMPT": "Write a 1-2 sentence semantic search query along the lines of a hypothetical response to: \n\n",
            "N_RETRIEVALS_TO_INCLUDE": 8,
            "PRESENCE_PENALTY": 0.0,
            "QDRANT_ONLY": false,
            "RAG_PROMPT": "Use the following retrieved documents to respond briefly and accurately:",
            "SEMANTIC_ENABLED": true,
            "STOP_TOKENS": [
              "\n\n",
              "\n"
            ],
            "SYSTEM_PROMPT": "You are a helpful assistant",
            "TEMPERATURE": 0.5,
            "USE_MESSAGE_TO_QUERY_PROMPT": false
          }
        }
      },
      "CreateExperimentReqBody": {
        "type": "object",
        "required": [
          "name",
          "experiment_config"
        ],
        "properties": {
          "experiment_config": {
            "$ref": "#/components/schemas/ExperimentConfig"
          },
          "name": {
            "type": "string"
          }
        }
      },
      "CreateFormWithoutFile": {
        "type": "object",
        "description": "Will use [chunkr.ai](https://chunkr.ai) to process the file when this object is defined. See [docs.chunkr.ai/api-references/task/create-task](https://docs.chunkr.ai/api-references/task/create-task) for detailed information about what each field on this request payload does.",
        "properties": {
          "chunk_processing": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkProcessing"
              }
            ],
            "nullable": true
          },
          "error_handling": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ErrorHandlingStrategy"
              }
            ],
            "nullable": true
          },
          "expires_in": {
            "type": "integer",
            "format": "int32",
            "description": "The number of seconds until task is deleted.\nExpried tasks can **not** be updated, polled or accessed via web interface.",
            "nullable": true
          },
          "high_resolution": {
            "type": "boolean",
            "description": "Whether to use high-resolution images for cropping and post-processing. (Latency penalty: ~7 seconds per page)",
            "default": false,
            "nullable": true
          },
          "llm_processing": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LlmProcessing"
              }
            ],
            "nullable": true
          },
          "ocr_strategy": {
            "allOf": [
              {
                "$ref": "#/components/schemas/OcrStrategy"
              }
            ],
            "default": "All",
            "nullable": true
          },
          "pipeline": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PipelineType"
              }
            ],
            "default": "Azure",
            "nullable": true
          },
          "segment_processing": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SegmentProcessing"
              }
            ],
            "nullable": true
          },
          "segmentation_strategy": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SegmentationStrategy"
              }
            ],
            "default": "LayoutAnalysis",
            "nullable": true
          }
        }
      },
      "CreateMessageReqPayload": {
        "type": "object",
        "required": [
          "topic_id"
        ],
        "properties": {
          "audio_input": {
            "type": "string",
            "description": "The base64 encoded audio input of the user message to attach to the topic and then generate an assistant message in response to.",
            "nullable": true
          },
          "concat_user_messages_query": {
            "type": "boolean",
            "description": "If concat user messages query is set to true, all of the user messages in the topic will be concatenated together and used as the search query. If not specified, this defaults to false. Default is false.",
            "nullable": true
          },
          "context_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContextOptions"
              }
            ],
            "nullable": true
          },
          "currency": {
            "type": "string",
            "description": "The currency to use for the completion. If not specified, this defaults to \"USD\".",
            "nullable": true
          },
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "highlight_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/HighlightOptions"
              }
            ],
            "nullable": true
          },
          "image_urls": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The URL of the image(s) to attach to the message.",
            "nullable": true
          },
          "llm_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LLMOptions"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "description": "Metadata is any metadata you want to associate w/ the event that is created from this request",
            "nullable": true
          },
          "new_message_content": {
            "type": "string",
            "description": "The content of the user message to attach to the topic and then generate an assistant message in response to.",
            "nullable": true
          },
          "no_result_message": {
            "type": "string",
            "description": "No result message for when there are no chunks found above the score threshold.",
            "nullable": true
          },
          "only_include_docs_used": {
            "type": "boolean",
            "description": "Only include docs used in the completion. If not specified, this defaults to false.",
            "nullable": true
          },
          "page_size": {
            "type": "integer",
            "format": "int64",
            "description": "Page size is the number of chunks to fetch during RAG. If 0, then no search will be performed. If specified, this will override the N retrievals to include in the dataset configuration. Default is None.",
            "nullable": true,
            "minimum": 0
          },
          "rag_context": {
            "type": "string",
            "description": "Overrides what the way chunks are placed into the context window",
            "nullable": true
          },
          "remove_stop_words": {
            "type": "boolean",
            "description": "If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.",
            "nullable": true
          },
          "score_threshold": {
            "type": "number",
            "format": "float",
            "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
            "nullable": true
          },
          "search_query": {
            "type": "string",
            "description": "Query is the search query. This can be any string. The search_query will be used to create a dense embedding vector and/or sparse vector which will be used to find the result set. If not specified, will default to the last user message or HyDE if HyDE is enabled in the dataset configuration. Default is None.",
            "nullable": true
          },
          "search_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchMethod"
              }
            ],
            "nullable": true
          },
          "sort_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SortOptions"
              }
            ],
            "nullable": true
          },
          "topic_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the topic to attach the message to."
          },
          "typo_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TypoOptions"
              }
            ],
            "nullable": true
          },
          "use_group_search": {
            "type": "boolean",
            "description": "If use_group_search is set to true, the search will be conducted using the `search_over_groups` api. If not specified, this defaults to false.",
            "nullable": true
          },
          "use_quote_negated_terms": {
            "type": "boolean",
            "description": "If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.",
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "description": "The user_id is the id of the user who is making the request. This is used to track user interactions with the RAG results.",
            "nullable": true
          }
        }
      },
      "CreateOrganizationReqPayload": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The arbitrary name which will be used to identify the organization. This name must be unique."
          }
        }
      },
      "CreatePresignedUrlForCsvJsonResponseBody": {
        "type": "object",
        "required": [
          "file_metadata",
          "presigned_put_url"
        ],
        "properties": {
          "file_metadata": {
            "$ref": "#/components/schemas/File"
          },
          "presigned_put_url": {
            "type": "string",
            "description": "Signed URL to upload the file to."
          }
        }
      },
      "CreatePresignedUrlForCsvJsonlReqPayload": {
        "type": "object",
        "required": [
          "file_name"
        ],
        "properties": {
          "description": {
            "type": "string",
            "description": "Description is an optional convience field so you do not have to remember what the file contains or is about. It will be included on the group resulting from the file which will hold its chunk.",
            "nullable": true
          },
          "file_name": {
            "type": "string",
            "description": "Name of the file being uploaded, including the extension. Will be used to determine CSV or JSONL for processing."
          },
          "fulltext_boost_factor": {
            "type": "number",
            "format": "double",
            "description": "Amount to multiplicatevly increase the frequency of the tokens in the boost phrase for each row's chunk by. Applies to fulltext (SPLADE) and keyword (BM25) search.",
            "nullable": true
          },
          "group_tracking_id": {
            "type": "string",
            "description": "Group tracking id is an optional field which allows you to specify the tracking id of the group that is created from the file. Chunks created will be created with the tracking id of `group_tracking_id|<index of chunk>`",
            "nullable": true
          },
          "link": {
            "type": "string",
            "description": "Link to the file. This can also be any string. This can be used to filter when searching for the file's resulting chunks. The link value will not affect embedding creation.",
            "nullable": true
          },
          "mappings": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkReqPayloadMappings"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "description": "Metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. Will be passed down to the file's chunks.",
            "nullable": true
          },
          "semantic_boost_factor": {
            "type": "number",
            "format": "double",
            "description": "Arbitrary float (positive or negative) specifying the multiplicate factor to apply before summing the phrase vector with the chunk_html embedding vector. Applies to semantic (embedding model) search.",
            "nullable": true
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tag set is a comma separated list of tags which will be passed down to the chunks made from the file. Each tag will be joined with what's creatd per row of the CSV or JSONL file.",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "description": "Time stamp should be an ISO 8601 combined date and time without timezone. Time_stamp is used for time window filtering and recency-biasing search results. Will be passed down to the file's chunks.",
            "nullable": true
          },
          "upsert_by_tracking_id": {
            "type": "boolean",
            "description": "Upsert by tracking_id. If true, chunks will be upserted by tracking_id. If false, chunks with the same tracking_id as another already existing chunk will be ignored. Defaults to true.",
            "nullable": true
          }
        },
        "example": {
          "description": "This is an example file",
          "file_name": "example.pdf",
          "link": "https://example.com",
          "metadata": {
            "key1": "value1",
            "key2": "value2"
          },
          "tag_set": [
            "tag1",
            "tag2"
          ],
          "time_stamp": "2021-01-01 00:00:00.000Z"
        }
      },
      "CreateSchemaReqPayload": {
        "type": "object",
        "required": [
          "prompt"
        ],
        "properties": {
          "include_images": {
            "type": "boolean",
            "nullable": true
          },
          "model": {
            "type": "string",
            "nullable": true
          },
          "prompt": {
            "type": "string"
          },
          "tag_enum": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          }
        }
      },
      "CreateSetupCheckoutSessionResPayload": {
        "type": "object",
        "required": [
          "url"
        ],
        "properties": {
          "url": {
            "type": "string"
          }
        }
      },
      "CreateSingleChunkGroupReqPayload": {
        "type": "object",
        "title": "single",
        "properties": {
          "description": {
            "type": "string",
            "description": "Description to assign to the chunk_group. Convenience field for you to avoid having to remember what the group is for.",
            "nullable": true
          },
          "metadata": {
            "description": "Optional metadata to assign to the chunk_group. This is a JSON object that can store any additional information you want to associate with the chunks inside of the chunk_group.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Name to assign to the chunk_group. Does not need to be unique.",
            "nullable": true
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Optional tags to assign to the chunk_group. This is a list of strings that can be used to categorize the chunks inside the chunk_group.",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "description": "Optional tracking id to assign to the chunk_group. This is a unique identifier for the chunk_group.",
            "nullable": true
          },
          "upsert_by_tracking_id": {
            "type": "boolean",
            "description": "Upsert when a chunk_group with the same tracking_id exists. By default this is false, and the request will fail if a chunk_group with the same tracking_id exists. If this is true, the chunk_group will be updated if a chunk_group with the same tracking_id exists.",
            "nullable": true
          }
        },
        "example": {
          "description": "All versions and colorways of the oversized t-shirt",
          "metadata": {
            "color": "black",
            "size": "large"
          },
          "name": "Versions of Oversized T-Shirt",
          "tag_set": [
            "tshirt",
            "oversized",
            "clothing"
          ],
          "tracking_id": "SNOVERSIZEDTSHIRT",
          "upsert_by_tracking_id": false
        }
      },
      "CreateSingleChunkReqPayload": {
        "$ref": "#/components/schemas/ChunkReqPayload"
      },
      "CreateTopicReqPayload": {
        "type": "object",
        "required": [
          "owner_id"
        ],
        "properties": {
          "first_user_message": {
            "type": "string",
            "description": "The first message which will belong to the topic. The topic name is generated based on this message similar to how it works in the OpenAI chat UX if a name is not explicitly provided on the name request body key.",
            "nullable": true
          },
          "metadata": {
            "description": "Metadata is any metadata you want to associate w/ the event that is created from this request",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "The name of the topic. If this is not provided, the topic name is generated from the first_user_message.",
            "nullable": true
          },
          "owner_id": {
            "type": "string",
            "description": "The owner_id of the topic. This is typically a browser fingerprint or your user's id. It is used to group topics together for a user."
          }
        }
      },
      "CroppingStrategy": {
        "type": "string",
        "description": "Controls the cropping strategy for an item (e.g. segment, chunk, etc.)\n- `All` crops all images in the item\n- `Auto` crops images only if required for post-processing",
        "enum": [
          "All",
          "Auto"
        ]
      },
      "Dataset": {
        "type": "object",
        "required": [
          "id",
          "name",
          "created_at",
          "updated_at",
          "organization_id",
          "server_configuration",
          "deleted"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of the creation of the dataset"
          },
          "deleted": {
            "type": "integer",
            "format": "int32",
            "description": "Flag to indicate if the dataset has been deleted. Deletes are handled async after the flag is set so as to avoid expensive search index compaction."
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the dataset, auto-generated uuid created by Trieve"
          },
          "name": {
            "type": "string",
            "description": "Name of the dataset"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the organization that owns the dataset"
          },
          "server_configuration": {
            "description": "Configuration of the dataset for RAG, embeddings, BM25, etc."
          },
          "tracking_id": {
            "type": "string",
            "description": "Tracking ID of the dataset, can be any string, determined by the user. Tracking ID's are unique identifiers for datasets within an organization. They are designed to match the unique identifier of the dataset in the user's system.",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of the last update of the dataset"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "name": "Trieve",
          "organization_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "server_configuration": {
            "AIMON_RERANKER_TASK_DEFINITION": "Your task is to grade the relevance of context document(s) against the specified user query.",
            "BM25_AVG_LEN": 256.0,
            "BM25_B": 0.75,
            "BM25_ENABLED": true,
            "BM25_K": 0.75,
            "DISTANCE_METRIC": "cosine",
            "EMBEDDING_BASE_URL": "https://embedding.trieve.ai",
            "EMBEDDING_MODEL_NAME": "jina-base-en",
            "EMBEDDING_QUERY_PREFIX": "",
            "EMBEDDING_SIZE": 768,
            "FREQUENCY_PENALTY": 0.0,
            "FULLTEXT_ENABLED": true,
            "INDEXED_ONLY": false,
            "LLM_BASE_URL": "https://api.openai.com/v1",
            "LLM_DEFAULT_MODEL": "gpt-4o",
            "LOCKED": false,
            "MAX_LIMIT": 10000,
            "MESSAGE_TO_QUERY_PROMPT": "Write a 1-2 sentence semantic search query along the lines of a hypothetical response to: \n\n",
            "N_RETRIEVALS_TO_INCLUDE": 8,
            "PRESENCE_PENALTY": 0.0,
            "QDRANT_ONLY": false,
            "RAG_PROMPT": "Use the following retrieved documents to respond briefly and accurately:",
            "SEMANTIC_ENABLED": true,
            "STOP_TOKENS": [
              "\n\n",
              "\n"
            ],
            "SYSTEM_PROMPT": "You are a helpful assistant",
            "TEMPERATURE": 0.5,
            "USE_MESSAGE_TO_QUERY_PROMPT": false
          },
          "tracking_id": "foobar-dataset",
          "updated_at": "2021-01-01 00:00:00.000"
        }
      },
      "DatasetAnalytics": {
        "type": "object",
        "title": "SearchMetricsResponse",
        "required": [
          "total_queries",
          "avg_latency",
          "p99",
          "p95",
          "p50",
          "total_positive_ratings",
          "total_negative_ratings"
        ],
        "properties": {
          "avg_latency": {
            "type": "number",
            "format": "double",
            "description": "Average latency of search queries"
          },
          "p50": {
            "type": "number",
            "format": "double",
            "description": "50th percentile latency of search queries"
          },
          "p95": {
            "type": "number",
            "format": "double",
            "description": "95th percentile latency of search queries"
          },
          "p99": {
            "type": "number",
            "format": "double",
            "description": "99th percentile latency of search queries"
          },
          "total_negative_ratings": {
            "type": "number",
            "format": "double",
            "description": "Total number of searches with a negative rating"
          },
          "total_positive_ratings": {
            "type": "number",
            "format": "double",
            "description": "Total number of searches with a positive rating"
          },
          "total_queries": {
            "type": "integer",
            "format": "int64",
            "description": "Total number of search queries"
          }
        }
      },
      "DatasetAndUsage": {
        "type": "object",
        "required": [
          "dataset",
          "dataset_usage"
        ],
        "properties": {
          "dataset": {
            "$ref": "#/components/schemas/DatasetDTO"
          },
          "dataset_usage": {
            "$ref": "#/components/schemas/DatasetUsageCount"
          }
        },
        "example": {
          "dataset": {
            "created_at": "2021-01-01 00:00:00.000",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "name": "Trieve",
            "organization_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "server_configuration": {},
            "updated_at": "2021-01-01 00:00:00.000"
          },
          "dataset_usage": {
            "chunk_count": 100,
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3"
          }
        }
      },
      "DatasetConfigurationDTO": {
        "type": "object",
        "description": "Lets you specify the configuration for a dataset",
        "properties": {
          "AIMON_RERANKER_TASK_DEFINITION": {
            "type": "string",
            "nullable": true
          },
          "BM25_AVG_LEN": {
            "type": "number",
            "format": "float",
            "description": "The average length of the chunks in the index for BM25",
            "nullable": true
          },
          "BM25_B": {
            "type": "number",
            "format": "float",
            "description": "The BM25 B parameter",
            "nullable": true
          },
          "BM25_ENABLED": {
            "type": "boolean",
            "description": "Whether to use BM25",
            "nullable": true
          },
          "BM25_K": {
            "type": "number",
            "format": "float",
            "description": "The BM25 K parameter",
            "nullable": true
          },
          "DISABLE_ANALYTICS": {
            "type": "boolean",
            "description": "Whether to disable analytics",
            "nullable": true
          },
          "DISTANCE_METRIC": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DistanceMetric"
              }
            ],
            "nullable": true
          },
          "EMBEDDING_BASE_URL": {
            "type": "string",
            "description": "The base URL for the embedding API",
            "nullable": true
          },
          "EMBEDDING_MODEL_NAME": {
            "type": "string",
            "description": "The name of the embedding model to use",
            "nullable": true
          },
          "EMBEDDING_QUERY_PREFIX": {
            "type": "string",
            "description": "The prefix to use for the embedding query",
            "nullable": true
          },
          "EMBEDDING_SIZE": {
            "type": "integer",
            "description": "The size of the embeddings",
            "nullable": true,
            "minimum": 0
          },
          "FREQUENCY_PENALTY": {
            "type": "number",
            "format": "double",
            "description": "The frequency penalty to use",
            "nullable": true
          },
          "FULLTEXT_ENABLED": {
            "type": "boolean",
            "description": "Whether to use fulltext search",
            "nullable": true
          },
          "INDEXED_ONLY": {
            "type": "boolean",
            "description": "Whether to only use indexed chunks",
            "nullable": true
          },
          "LLM_BASE_URL": {
            "type": "string",
            "description": "The base URL for the LLM API",
            "nullable": true
          },
          "LLM_DEFAULT_MODEL": {
            "type": "string",
            "description": "The default model to use for the LLM",
            "nullable": true
          },
          "LOCKED": {
            "type": "boolean",
            "description": "Whether the dataset is locked to prevent changes or deletion",
            "nullable": true
          },
          "MAX_LIMIT": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum limit for the number of chunks for counting",
            "nullable": true,
            "minimum": 0
          },
          "MAX_TOKENS": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum number of tokens to use in LLM Response",
            "nullable": true,
            "minimum": 0
          },
          "MESSAGE_TO_QUERY_PROMPT": {
            "type": "string",
            "description": "The prompt to use for converting a message to a query",
            "nullable": true
          },
          "N_RETRIEVALS_TO_INCLUDE": {
            "type": "integer",
            "description": "The number of retrievals to include with the RAG model",
            "nullable": true,
            "minimum": 0
          },
          "PAGEFIND_ENABLED": {
            "type": "boolean",
            "description": "Whether to enable pagefind indexing",
            "nullable": true
          },
          "PRESENCE_PENALTY": {
            "type": "number",
            "format": "double",
            "description": "The presence penalty to use",
            "nullable": true
          },
          "PUBLIC_DATASET": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PublicDatasetOptions"
              }
            ],
            "nullable": true
          },
          "QDRANT_ONLY": {
            "type": "boolean",
            "description": "Whether or not to insert chunks into Postgres",
            "nullable": true
          },
          "RAG_PROMPT": {
            "type": "string",
            "description": "The prompt to use for the RAG model",
            "nullable": true
          },
          "RERANKER_BASE_URL": {
            "type": "string",
            "description": "The base URL for the reranker API",
            "nullable": true
          },
          "RERANKER_MODEL_NAME": {
            "type": "string",
            "description": "The model name for the Reranker API",
            "nullable": true
          },
          "SEMANTIC_ENABLED": {
            "type": "boolean",
            "description": "Whether to use semantic search",
            "nullable": true
          },
          "STOP_TOKENS": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The stop tokens to use",
            "nullable": true
          },
          "SYSTEM_PROMPT": {
            "type": "string",
            "description": "The system prompt to use for the LLM",
            "nullable": true
          },
          "TEMPERATURE": {
            "type": "number",
            "format": "double",
            "description": "The temperature to use",
            "nullable": true
          },
          "USE_MESSAGE_TO_QUERY_PROMPT": {
            "type": "boolean",
            "description": "Whether to use the message to query prompt",
            "nullable": true
          }
        },
        "example": {
          "AIMON_RERANKER_TASK_DEFINITION": "Your task is to grade the relevance of context document(s) against the specified user query.",
          "BM25_AVG_LEN": 256.0,
          "BM25_B": 0.75,
          "BM25_ENABLED": true,
          "BM25_K": 0.75,
          "DISTANCE_METRIC": "cosine",
          "EMBEDDING_BASE_URL": "https://embedding.trieve.ai",
          "EMBEDDING_MODEL_NAME": "jina-base-en",
          "EMBEDDING_QUERY_PREFIX": "",
          "EMBEDDING_SIZE": 768,
          "FREQUENCY_PENALTY": 0.0,
          "FULLTEXT_ENABLED": true,
          "INDEXED_ONLY": false,
          "LLM_BASE_URL": "https://api.openai.com/v1",
          "LLM_DEFAULT_MODEL": "gpt-4o",
          "LOCKED": false,
          "MAX_LIMIT": 10000,
          "MESSAGE_TO_QUERY_PROMPT": "Write a 1-2 sentence semantic search query along the lines of a hypothetical response to: \n\n",
          "N_RETRIEVALS_TO_INCLUDE": 8,
          "PRESENCE_PENALTY": 0.0,
          "QDRANT_ONLY": false,
          "RAG_PROMPT": "Use the following retrieved documents to respond briefly and accurately:",
          "SEMANTIC_ENABLED": true,
          "STOP_TOKENS": [
            "\n\n",
            "\n"
          ],
          "SYSTEM_PROMPT": "You are a helpful assistant",
          "TEMPERATURE": 0.5,
          "USE_MESSAGE_TO_QUERY_PROMPT": false
        }
      },
      "DatasetDTO": {
        "type": "object",
        "required": [
          "id",
          "name",
          "created_at",
          "updated_at",
          "organization_id"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid"
          },
          "tracking_id": {
            "type": "string",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "name": "Trieve",
          "organization_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "tracking_id": "3",
          "updated_at": "2021-01-01 00:00:00.000"
        }
      },
      "DatasetFilePathParams": {
        "type": "object",
        "required": [
          "dataset_id",
          "page"
        ],
        "properties": {
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "page": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          }
        }
      },
      "DatasetUsageCount": {
        "type": "object",
        "required": [
          "id",
          "dataset_id",
          "chunk_count"
        ],
        "properties": {
          "chunk_count": {
            "type": "integer",
            "format": "int32"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "example": {
          "chunk_count": 100,
          "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3"
        }
      },
      "Datasets": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/Dataset"
        },
        "description": "Datasets"
      },
      "DateRange": {
        "type": "object",
        "description": "DateRange is a JSON object which can be used to filter chunks by a range of dates. This leverages the time_stamp field on chunks in your dataset. You can specify this if you want values in a certain range. You must provide ISO 8601 combined date and time without timezone.",
        "properties": {
          "gt": {
            "type": "string",
            "nullable": true
          },
          "gte": {
            "type": "string",
            "nullable": true
          },
          "lt": {
            "type": "string",
            "nullable": true
          },
          "lte": {
            "type": "string",
            "nullable": true
          }
        },
        "example": {
          "gt": "2021-01-01 00:00:00.000",
          "gte": "2021-01-01 00:00:00.000",
          "lt": "2021-01-01 00:00:00.000",
          "lte": "2021-01-01 00:00:00.000"
        }
      },
      "DefaultSearchQuery": {
        "type": "object",
        "properties": {
          "imageUrl": {
            "type": "string",
            "nullable": true
          },
          "query": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "DefaultSearchQueryType": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/DefaultSearchQuery"
          }
        ]
      },
      "DeleteTopicData": {
        "type": "object",
        "required": [
          "topic_id"
        ],
        "properties": {
          "topic_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the topic to target."
          }
        }
      },
      "DeprecatedSearchOverGroupsResponseBody": {
        "type": "object",
        "title": "V1",
        "required": [
          "group_chunks",
          "total_chunk_pages"
        ],
        "properties": {
          "corrected_query": {
            "type": "string",
            "nullable": true
          },
          "group_chunks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GroupScoreChunk"
            }
          },
          "total_chunk_pages": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "Direction": {
        "type": "string",
        "enum": [
          "asc",
          "desc"
        ]
      },
      "DistanceMetric": {
        "type": "string",
        "enum": [
          "euclidean",
          "cosine",
          "manhattan",
          "dot"
        ]
      },
      "Document": {
        "type": "object",
        "required": [
          "metadata"
        ],
        "properties": {
          "extract": {
            "type": "string",
            "nullable": true
          },
          "html": {
            "type": "string",
            "nullable": true
          },
          "links": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "markdown": {
            "type": "string",
            "nullable": true
          },
          "metadata": {
            "$ref": "#/components/schemas/Metadata"
          },
          "rawHtml": {
            "type": "string",
            "nullable": true
          },
          "screenshot": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "EditImageReqPayload": {
        "type": "object",
        "required": [
          "input_images",
          "prompt"
        ],
        "properties": {
          "input_images": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ImageUpload"
            },
            "description": "The images to edit"
          },
          "mime_type": {
            "type": "string",
            "description": "The mime type of the uploaded image(s)",
            "nullable": true
          },
          "n": {
            "type": "integer",
            "format": "int32",
            "description": "The number of images to generate (default: 1)",
            "nullable": true,
            "minimum": 0
          },
          "prompt": {
            "type": "string",
            "description": "The prompt describing the desired edit"
          },
          "quality": {
            "allOf": [
              {
                "$ref": "#/components/schemas/InputImageQuality"
              }
            ],
            "nullable": true
          },
          "size": {
            "allOf": [
              {
                "$ref": "#/components/schemas/InputImageSize"
              }
            ],
            "nullable": true
          }
        }
      },
      "EditMessageReqPayload": {
        "type": "object",
        "required": [
          "topic_id",
          "message_sort_order"
        ],
        "properties": {
          "audio_input": {
            "type": "string",
            "description": "The base64 encoded audio input of the user message to attach to the topic and then generate an assistant message in response to.",
            "nullable": true
          },
          "concat_user_messages_query": {
            "type": "boolean",
            "description": "If concat user messages query is set to true, all of the user messages in the topic will be concatenated together and used as the search query. If not specified, this defaults to false. Default is false.",
            "nullable": true
          },
          "context_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContextOptions"
              }
            ],
            "nullable": true
          },
          "currency": {
            "type": "string",
            "description": "The currency symbol to use for the completion. If not specified, this defaults to \"$\".",
            "nullable": true
          },
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "highlight_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/HighlightOptions"
              }
            ],
            "nullable": true
          },
          "image_urls": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The URL of the image(s) to attach to the message.",
            "nullable": true
          },
          "llm_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LLMOptions"
              }
            ],
            "nullable": true
          },
          "message_sort_order": {
            "type": "integer",
            "format": "int32",
            "description": "The sort order of the message to edit."
          },
          "metadata": {
            "description": "Metadata is any metadata you want to associate w/ the event that is created from this request",
            "nullable": true
          },
          "new_message_content": {
            "type": "string",
            "description": "The new content of the message to replace the old content with.",
            "nullable": true
          },
          "no_result_message": {
            "type": "string",
            "description": "No result message for when there are no chunks found above the score threshold.",
            "nullable": true
          },
          "only_include_docs_used": {
            "type": "boolean",
            "description": "Only include docs used in the completion. If not specified, this defaults to false.",
            "nullable": true
          },
          "page_size": {
            "type": "integer",
            "format": "int64",
            "description": "Page size is the number of chunks to fetch during RAG. If 0, then no search will be performed. If specified, this will override the N retrievals to include in the dataset configuration. Default is None.",
            "nullable": true,
            "minimum": 0
          },
          "rag_context": {
            "type": "string",
            "description": "Overrides what the way chunks are placed into the context window",
            "nullable": true
          },
          "remove_stop_words": {
            "type": "boolean",
            "description": "If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.",
            "nullable": true
          },
          "score_threshold": {
            "type": "number",
            "format": "float",
            "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
            "nullable": true
          },
          "search_query": {
            "type": "string",
            "description": "Query is the search query. This can be any string. The search_query will be used to create a dense embedding vector and/or sparse vector which will be used to find the result set. If not specified, will default to the last user message or HyDE if HyDE is enabled in the dataset configuration. Default is None.",
            "nullable": true
          },
          "search_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchMethod"
              }
            ],
            "nullable": true
          },
          "sort_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SortOptions"
              }
            ],
            "nullable": true
          },
          "topic_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the topic to edit the message at the given sort order for."
          },
          "typo_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TypoOptions"
              }
            ],
            "nullable": true
          },
          "use_group_search": {
            "type": "boolean",
            "nullable": true
          },
          "use_quote_negated_terms": {
            "type": "boolean",
            "description": "If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.",
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "description": "The user_id is the id of the user who is making the request. This is used to track user interactions with the RAG results.",
            "nullable": true
          }
        }
      },
      "EmbedSource": {
        "type": "string",
        "enum": [
          "HTML",
          "Markdown",
          "LLM",
          "Content"
        ]
      },
      "ErrorHandlingStrategy": {
        "type": "string",
        "description": "Controls how errors are handled during processing:\n- `Fail`: Stops processing and fails the task when any error occurs\n- `Continue`: Attempts to continue processing despite non-critical errors (eg. LLM refusals etc.)",
        "enum": [
          "Fail",
          "Continue"
        ]
      },
      "ErrorResponseBody": {
        "type": "object",
        "required": [
          "message"
        ],
        "properties": {
          "message": {
            "type": "string"
          }
        },
        "example": {
          "message": "Bad Request"
        }
      },
      "EventAnalyticsFilter": {
        "type": "object",
        "description": "Filter to apply to the events when querying for them",
        "properties": {
          "date_range": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DateRange"
              }
            ],
            "nullable": true
          },
          "event_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EventTypesFilter"
              }
            ],
            "nullable": true
          },
          "is_conversion": {
            "type": "boolean",
            "description": "Filter by conversions",
            "nullable": true
          },
          "metadata_filter": {
            "type": "string",
            "description": "Filter by metadata path i.e. path.attribute = \\\"value\\\"",
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "description": "Filter by user ID",
            "nullable": true
          }
        },
        "example": {
          "date_range": {
            "gt": "2021-08-10T00:00:00Z",
            "lt": "2021-08-11T00:00:00Z"
          },
          "event_type": "view",
          "is_conversion": true,
          "metadata_filter": "path = \"value\"",
          "user_id": "user1"
        }
      },
      "EventData": {
        "type": "object",
        "title": "EventData",
        "description": "EventData represents a single analytics event",
        "required": [
          "id",
          "event_type",
          "event_name",
          "items",
          "dataset_id",
          "created_at",
          "updated_at"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "description": "The time the event was created."
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid",
            "description": "The unique identifier for the dataset the event is associated with."
          },
          "event_name": {
            "type": "string",
            "description": "The name of the event, e.g. \"Added to Cart\", \"Purchased\", \"Viewed Home Page\", \"Clicked\", \"Filter Clicked\", \"Followup Query\"."
          },
          "event_type": {
            "type": "string",
            "description": "The type of event, \"add_to_cart\", \"purchase\", \"view\", \"click\", \"filter_clicked\", \"followup_query\""
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "The unique identifier for the event"
          },
          "is_conversion": {
            "type": "boolean",
            "description": "Whether the event is a conversion event.",
            "nullable": true
          },
          "items": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The items associated with the event. This could be a list of stringified json chunks for search events, or a list of items for add_to_cart, purchase, view, and click events."
          },
          "metadata": {
            "description": "Additional metadata associated with the event. This can be custom data that is specific to the event.",
            "nullable": true
          },
          "request_id": {
            "type": "string",
            "description": "The unique identifier for the request the event is associated with.",
            "nullable": true
          },
          "request_type": {
            "type": "string",
            "description": "The type of request the event is associated with.",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "description": "The time the event was last updated."
          },
          "user_id": {
            "type": "string",
            "description": "The user identifier associated with the event.",
            "nullable": true
          }
        },
        "example": {
          "created_at": "2021-08-10T00:00:00Z",
          "dataset_id": "00000000-0000-0000-0000-000000000000",
          "event_name": "Viewed Home Page",
          "event_type": "view",
          "is_conversion": true,
          "items": [
            "item1",
            "item2"
          ],
          "metadata": "metadata",
          "request_id": "00000000-0000-0000-0000-000000000000",
          "updated_at": "2021-08-10T00:00:00Z",
          "user_id": "user1"
        }
      },
      "EventNameAndCounts": {
        "type": "object",
        "required": [
          "event_name",
          "event_count"
        ],
        "properties": {
          "event_count": {
            "type": "integer",
            "format": "int64"
          },
          "event_name": {
            "type": "string"
          }
        }
      },
      "EventNameAndCountsResponse": {
        "type": "object",
        "required": [
          "event_names"
        ],
        "properties": {
          "event_names": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EventNameAndCounts"
            }
          }
        }
      },
      "EventNamesFilter": {
        "type": "string",
        "enum": [
          "component_close",
          "component_open",
          "View",
          "site-followup_query",
          "Click",
          "site-add_to_cart",
          "site-checkout_end"
        ]
      },
      "EventReturn": {
        "type": "object",
        "required": [
          "events",
          "event_types",
          "page_count"
        ],
        "properties": {
          "event_types": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkerEvent"
            }
          },
          "page_count": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "EventTypeRequest": {
        "type": "string",
        "enum": [
          "file_uploaded",
          "file_upload_failed",
          "chunks_uploaded",
          "chunk_action_failed",
          "chunk_updated",
          "bulk_chunks_deleted",
          "chunk_update_failed",
          "dataset_delete_failed",
          "qdrant_upload_failed",
          "bulk_chunk_upload_failed",
          "group_chunks_updated",
          "group_chunks_action_failed",
          "crawl_completed",
          "crawl_failed",
          "crawl_started",
          "csv_jsonl_processing_failed",
          "csv_jsonl_processing_checkpoint",
          "csv_jsonl_processing_completed",
          "video_uploaded",
          "pagefind_indexing_started",
          "pagefind_indexing_finished",
          "etl_started",
          "etl_completed",
          "etl_failed"
        ]
      },
      "EventTypes": {
        "oneOf": [
          {
            "type": "object",
            "title": "View",
            "required": [
              "event_name",
              "items",
              "event_type"
            ],
            "properties": {
              "event_name": {
                "type": "string",
                "description": "The name of the event"
              },
              "event_type": {
                "type": "string",
                "enum": [
                  "view"
                ]
              },
              "items": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "The items that were viewed"
              },
              "location": {
                "type": "string",
                "description": "The location of the event",
                "nullable": true
              },
              "metadata": {
                "description": "Any other metadata associated with the event",
                "nullable": true
              },
              "request": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RequestInfo"
                  }
                ],
                "nullable": true
              },
              "user_id": {
                "type": "string",
                "description": "The user id of the user who viewed the items",
                "nullable": true
              }
            }
          },
          {
            "type": "object",
            "title": "AddToCart",
            "required": [
              "event_name",
              "items",
              "event_type"
            ],
            "properties": {
              "event_name": {
                "type": "string",
                "description": "The name of the event"
              },
              "event_type": {
                "type": "string",
                "enum": [
                  "add_to_cart"
                ]
              },
              "is_conversion": {
                "type": "boolean",
                "description": "Whether the event is a conversion event",
                "nullable": true
              },
              "items": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "The items that were added to the cart"
              },
              "location": {
                "type": "string",
                "description": "The location of the event",
                "nullable": true
              },
              "metadata": {
                "description": "Any other metadata associated with the event",
                "nullable": true
              },
              "request": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RequestInfo"
                  }
                ],
                "nullable": true
              },
              "user_id": {
                "type": "string",
                "description": "The user id of the user who added the items to the cart",
                "nullable": true
              }
            }
          },
          {
            "type": "object",
            "title": "Click",
            "required": [
              "event_name",
              "event_type"
            ],
            "properties": {
              "clicked_items": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChunkWithPosition"
                  }
                ],
                "nullable": true
              },
              "event_name": {
                "type": "string",
                "description": "The name of the event"
              },
              "event_type": {
                "type": "string",
                "enum": [
                  "click"
                ]
              },
              "is_conversion": {
                "type": "boolean",
                "description": "Whether the event is a conversion event",
                "nullable": true
              },
              "location": {
                "type": "string",
                "description": "The location of the event",
                "nullable": true
              },
              "metadata": {
                "description": "Metadata to include with click event",
                "nullable": true
              },
              "request": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RequestInfo"
                  }
                ],
                "nullable": true
              },
              "user_id": {
                "type": "string",
                "description": "The user id of the user who clicked the items",
                "nullable": true
              }
            }
          },
          {
            "type": "object",
            "title": "Purchase",
            "required": [
              "event_name",
              "items",
              "event_type"
            ],
            "properties": {
              "event_name": {
                "type": "string",
                "description": "The name of the event"
              },
              "event_type": {
                "type": "string",
                "enum": [
                  "purchase"
                ]
              },
              "is_conversion": {
                "type": "boolean",
                "description": "Whether the event is a conversion event",
                "nullable": true
              },
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/PurchaseItem"
                },
                "description": "The items that were purchased"
              },
              "location": {
                "type": "string",
                "description": "The location of the event",
                "nullable": true
              },
              "metadata": {
                "description": "Any other metadata associated with the event",
                "nullable": true
              },
              "request": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RequestInfo"
                  }
                ],
                "nullable": true
              },
              "user_id": {
                "type": "string",
                "description": "The user id of the user who purchased the items",
                "nullable": true
              }
            }
          },
          {
            "type": "object",
            "title": "FilterClicked",
            "required": [
              "event_name",
              "items",
              "event_type"
            ],
            "properties": {
              "event_name": {
                "type": "string",
                "description": "The name of the event"
              },
              "event_type": {
                "type": "string",
                "enum": [
                  "filter_clicked"
                ]
              },
              "is_conversion": {
                "type": "boolean",
                "description": "Whether the event is a conversion event",
                "nullable": true
              },
              "items": {
                "type": "object",
                "description": "The filter items that were clicked in a hashmap ie. {filter_name: filter_value} where filter_name is filter_type::field_name",
                "additionalProperties": {
                  "type": "string"
                }
              },
              "location": {
                "type": "string",
                "description": "The location of the event",
                "nullable": true
              },
              "request": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RequestInfo"
                  }
                ],
                "nullable": true
              },
              "user_id": {
                "type": "string",
                "description": "The user id of the user who clicked the items",
                "nullable": true
              }
            }
          },
          {
            "type": "object",
            "title": "Search",
            "required": [
              "query",
              "tokens",
              "event_type"
            ],
            "properties": {
              "event_type": {
                "type": "string",
                "enum": [
                  "search"
                ]
              },
              "latency": {
                "type": "number",
                "format": "float",
                "description": "Latency of the search",
                "nullable": true
              },
              "metadata": {
                "description": "Metadata to provide with each request",
                "nullable": true
              },
              "query": {
                "type": "string",
                "description": "The search query"
              },
              "query_rating": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchQueryRating"
                  }
                ],
                "nullable": true
              },
              "request_params": {
                "description": "The request params of the search",
                "nullable": true
              },
              "results": {
                "type": "array",
                "items": {},
                "description": "The results of the search",
                "nullable": true
              },
              "search_type": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClickhouseSearchTypes"
                  }
                ],
                "nullable": true
              },
              "tokens": {
                "type": "integer",
                "format": "int64",
                "description": "Number of tokens used in the search",
                "minimum": 0
              },
              "top_score": {
                "type": "number",
                "format": "float",
                "description": "The top score of the search",
                "nullable": true
              },
              "user_id": {
                "type": "string",
                "description": "The user id of the user who made the search",
                "nullable": true
              }
            }
          },
          {
            "type": "object",
            "title": "RAG",
            "required": [
              "user_message",
              "tokens",
              "event_type"
            ],
            "properties": {
              "detected_hallucinations": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "The detected hallucinations of the RAG event",
                "nullable": true
              },
              "event_type": {
                "type": "string",
                "enum": [
                  "rag"
                ]
              },
              "hallucination_score": {
                "type": "number",
                "format": "double",
                "description": "The hallucination score of the RAG event",
                "nullable": true
              },
              "llm_response": {
                "type": "string",
                "description": "The response from the LLM",
                "nullable": true
              },
              "metadata": {
                "description": "Metadata to provide with each request",
                "nullable": true
              },
              "query_rating": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchQueryRating"
                  }
                ],
                "nullable": true
              },
              "rag_type": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClickhouseRagTypes"
                  }
                ],
                "nullable": true
              },
              "results": {
                "type": "array",
                "items": {},
                "description": "The results of the RAG event",
                "nullable": true
              },
              "search_id": {
                "type": "string",
                "format": "uuid",
                "description": "The search id to associate the RAG event with a search",
                "nullable": true
              },
              "tokens": {
                "type": "integer",
                "format": "int64",
                "description": "The number of tokens used for this chat",
                "minimum": 0
              },
              "topic_id": {
                "type": "string",
                "format": "uuid",
                "description": "The topic id to associate the RAG event with a topic",
                "nullable": true
              },
              "user_id": {
                "type": "string",
                "description": "The user id of the user who made the RAG event",
                "nullable": true
              },
              "user_message": {
                "type": "string",
                "description": "The user message"
              }
            }
          },
          {
            "type": "object",
            "title": "Recommendation",
            "required": [
              "event_type"
            ],
            "properties": {
              "event_type": {
                "type": "string",
                "enum": [
                  "recommendation"
                ]
              },
              "metadata": {
                "description": "Metadata to provide with each request",
                "nullable": true
              },
              "negative_ids": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": "Negative ids used for the recommendation",
                "nullable": true
              },
              "negative_tracking_ids": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "Negative tracking ids used for the recommendation",
                "nullable": true
              },
              "positive_ids": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": "Positive ids used for the recommendation",
                "nullable": true
              },
              "positive_tracking_ids": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "Positive tracking ids used for the recommendation",
                "nullable": true
              },
              "recommendation_type": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClickhouseRecommendationTypes"
                  }
                ],
                "nullable": true
              },
              "request_params": {
                "description": "The request params of the recommendation",
                "nullable": true
              },
              "results": {
                "type": "array",
                "items": {},
                "description": "The results of the Recommendation event",
                "nullable": true
              },
              "top_score": {
                "type": "number",
                "format": "float",
                "description": "Top score of the recommendation",
                "nullable": true
              },
              "user_id": {
                "type": "string",
                "description": "The user id of the user who made the recommendation",
                "nullable": true
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "event_type"
        }
      },
      "EventTypesFilter": {
        "type": "string",
        "enum": [
          "view",
          "filter_clicked",
          "click",
          "add_to_cart",
          "purchase"
        ]
      },
      "EventsForTopicResponse": {
        "type": "object",
        "required": [
          "events"
        ],
        "properties": {
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EventData"
            }
          }
        }
      },
      "Experiment": {
        "type": "object",
        "required": [
          "id",
          "name",
          "area",
          "t1_name",
          "t1_split",
          "control_name",
          "control_split",
          "dataset_id",
          "created_at",
          "updated_at"
        ],
        "properties": {
          "area": {
            "type": "string"
          },
          "control_name": {
            "type": "string"
          },
          "control_split": {
            "type": "number",
            "format": "float"
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string"
          },
          "t1_name": {
            "type": "string"
          },
          "t1_split": {
            "type": "number",
            "format": "float"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "ExperimentConfig": {
        "type": "object",
        "required": [
          "area",
          "t1_name",
          "t1_split",
          "control_name",
          "control_split"
        ],
        "properties": {
          "area": {
            "type": "string"
          },
          "control_name": {
            "type": "string"
          },
          "control_split": {
            "type": "number",
            "format": "float"
          },
          "t1_name": {
            "type": "string"
          },
          "t1_split": {
            "type": "number",
            "format": "float"
          }
        }
      },
      "Expression": {
        "type": "object",
        "description": "Represents a SQL expression with optional alias",
        "required": [
          "expression"
        ],
        "properties": {
          "alias": {
            "type": "string",
            "nullable": true
          },
          "expression": {
            "$ref": "#/components/schemas/ExpressionType"
          }
        }
      },
      "ExpressionType": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "name",
              "type"
            ],
            "properties": {
              "name": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "column"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "value",
              "type"
            ],
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "literal"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/FilterValue"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "name",
              "args",
              "type"
            ],
            "properties": {
              "args": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ExpressionType"
                }
              },
              "name": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "function"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "sql",
              "type"
            ],
            "properties": {
              "sql": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "raw"
                ]
              }
            }
          }
        ],
        "description": "Structured expression type",
        "discriminator": {
          "propertyName": "type"
        }
      },
      "ExtendedOrganizationUsageCount": {
        "type": "object",
        "required": [
          "search_tokens",
          "message_tokens",
          "dataset_count",
          "user_count",
          "file_storage",
          "message_count",
          "search_count",
          "chunk_count",
          "bytes_ingested",
          "tokens_ingested",
          "ocr_pages_ingested",
          "website_pages_scraped",
          "events_ingested",
          "current_months_message_count"
        ],
        "properties": {
          "bytes_ingested": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "chunk_count": {
            "type": "integer",
            "format": "int32"
          },
          "current_months_message_count": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "dataset_count": {
            "type": "integer",
            "format": "int32"
          },
          "events_ingested": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "file_storage": {
            "type": "integer",
            "format": "int64"
          },
          "message_count": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "message_tokens": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "ocr_pages_ingested": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "search_count": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "search_tokens": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "tokens_ingested": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "user_count": {
            "type": "integer",
            "format": "int32"
          },
          "website_pages_scraped": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          }
        }
      },
      "FallbackStrategy": {
        "oneOf": [
          {
            "type": "string",
            "description": "No fallback will be used",
            "enum": [
              "None"
            ]
          },
          {
            "type": "string",
            "description": "Use the system default fallback model",
            "enum": [
              "Default"
            ]
          },
          {
            "type": "object",
            "required": [
              "Model"
            ],
            "properties": {
              "Model": {
                "type": "string",
                "description": "Use a specific model as fallback"
              }
            }
          }
        ],
        "description": "Specifies the fallback strategy for LLM processing\n\nThis can be:\n1. None - No fallback will be used\n2. Default - The system default fallback model will be used\n3. Model - A specific model ID will be used as fallback (check the documentation for the models.)"
      },
      "FieldCondition": {
        "type": "object",
        "description": "FieldCondition is a JSON object which can be used to filter chunks by a field. This is useful for when you want to filter chunks by arbitrary metadata. To access fields inside of the metadata that you provide with the card, prefix the field name with `metadata.`.",
        "required": [
          "field"
        ],
        "properties": {
          "boolean": {
            "type": "boolean",
            "description": "Boolean is a true false value for a field. This only works for boolean fields. You can specify this if you want values to be true or false.",
            "nullable": true
          },
          "date_range": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DateRange"
              }
            ],
            "nullable": true
          },
          "field": {
            "type": "string",
            "description": "Field is the name of the field to filter on. Commonly used fields are `timestamp`, `link`, `tag_set`, `location`, `num_value`, `group_ids`, and `group_tracking_ids`. The field value will be used to check for an exact substring match on the metadata values for each existing chunk. This is useful for when you want to filter chunks by arbitrary metadata. To access fields inside of the metadata that you provide with the card, prefix the field name with `metadata.`."
          },
          "geo_bounding_box": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LocationBoundingBox"
              }
            ],
            "nullable": true
          },
          "geo_polygon": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LocationPolygon"
              }
            ],
            "nullable": true
          },
          "geo_radius": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LocationRadius"
              }
            ],
            "nullable": true
          },
          "match_all": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MatchCondition"
            },
            "description": "Match all lets you pass in an array of values that will return results if all of the items match. The match value will be used to check for an exact substring match on the metadata values for each existing chunk. If both match_all and match_any are provided, the match_any condition will be used.",
            "nullable": true
          },
          "match_any": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MatchCondition"
            },
            "description": "Match any lets you pass in an array of values that will return results if any of the items match. The match value will be used to check for an exact substring match on the metadata values for each existing chunk. If both match_all and match_any are provided, the match_any condition will be used.",
            "nullable": true
          },
          "range": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Range"
              }
            ],
            "nullable": true
          }
        },
        "example": {
          "field": "metadata.key1",
          "match": [
            "value1",
            "value2"
          ],
          "range": {
            "gt": 0.0,
            "gte": 0.0,
            "lt": 1.0,
            "lte": 1.0
          }
        }
      },
      "File": {
        "type": "object",
        "required": [
          "id",
          "file_name",
          "created_at",
          "updated_at",
          "dataset_id",
          "size"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "file_name": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "link": {
            "type": "string",
            "nullable": true
          },
          "metadata": {
            "nullable": true
          },
          "size": {
            "type": "integer",
            "format": "int64"
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "file_name": "file.txt",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "link": "https://trieve.ai",
          "metadata": {
            "key": "value"
          },
          "size": 1000,
          "tag_set": "tag1,tag2",
          "time_stamp": "2021-01-01 00:00:00.000",
          "updated_at": "2021-01-01 00:00:00.000"
        }
      },
      "FileAndGroupId": {
        "type": "object",
        "required": [
          "file"
        ],
        "properties": {
          "file": {
            "$ref": "#/components/schemas/File"
          },
          "group_id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          }
        }
      },
      "FileDTO": {
        "type": "object",
        "required": [
          "id",
          "file_name",
          "created_at",
          "updated_at",
          "size",
          "s3_url"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "file_name": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "link": {
            "type": "string",
            "nullable": true
          },
          "metadata": {
            "nullable": true
          },
          "s3_url": {
            "type": "string"
          },
          "size": {
            "type": "integer",
            "format": "int64"
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "file_name": "file.txt",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "link": "https://trieve.ai",
          "metadata": {
            "key": "value"
          },
          "s3_url": "https://trieve.ai",
          "size": 1000,
          "updated_at": "2021-01-01 00:00:00.000"
        }
      },
      "FileData": {
        "type": "object",
        "required": [
          "file_and_group_ids",
          "total_pages"
        ],
        "properties": {
          "file_and_group_ids": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FileAndGroupId"
            }
          },
          "total_pages": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "FileWithChunkGroups": {
        "type": "object",
        "required": [
          "id",
          "file_name",
          "created_at",
          "updated_at",
          "size",
          "dataset_id"
        ],
        "properties": {
          "chunk_groups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChunkGroup"
            },
            "nullable": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "file_name": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "link": {
            "type": "string",
            "nullable": true
          },
          "metadata": {
            "nullable": true
          },
          "size": {
            "type": "integer",
            "format": "int64"
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        },
        "example": {
          "chunk_groups": [
            {
              "created_at": "2021-01-01 00:00:00.000",
              "dataset_id": "f83f08ef-c05d-421c-baf1-4f1509ea069b",
              "description": "",
              "id": "df1b73ec-1e62-44bc-b07e-b04485217842",
              "metadata": {},
              "name": "uploadme.pdf",
              "tag_set": [],
              "tracking_id": "file-upload-group",
              "updated_at": "2021-01-01 00:00:00.000"
            }
          ],
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "file_name": "file.txt",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "link": "https://trieve.ai",
          "metadata": {
            "key": "value"
          },
          "size": 1000,
          "tag_set": "tag1,tag2",
          "time_stamp": "2021-01-01 00:00:00.000",
          "updated_at": "2021-01-01 00:00:00.000"
        }
      },
      "FilterCondition": {
        "type": "object",
        "description": "Represents a query filter condition",
        "required": [
          "column",
          "operator",
          "value"
        ],
        "properties": {
          "and_filter": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FilterCondition"
            },
            "nullable": true
          },
          "column": {
            "type": "string"
          },
          "operator": {
            "$ref": "#/components/schemas/FilterOperator"
          },
          "or_filter": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FilterCondition"
            },
            "nullable": true
          },
          "value": {
            "$ref": "#/components/schemas/FilterValue"
          }
        }
      },
      "FilterOperator": {
        "type": "string",
        "enum": [
          "=",
          "!=",
          "<>",
          ">",
          "<",
          ">=",
          "<=",
          "like",
          "not like",
          "in",
          "not in",
          "is null",
          "is not null"
        ]
      },
      "FilterSidebarSection": {
        "type": "object",
        "required": [
          "key",
          "filterKey",
          "title",
          "selectionType",
          "filterType",
          "options"
        ],
        "properties": {
          "filterKey": {
            "type": "string"
          },
          "filterType": {
            "type": "string"
          },
          "key": {
            "type": "string"
          },
          "options": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagProp"
            }
          },
          "selectionType": {
            "type": "string"
          },
          "title": {
            "type": "string"
          }
        }
      },
      "FilterValue": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "number",
            "format": "double"
          },
          {
            "type": "boolean"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FilterValue"
            }
          }
        ]
      },
      "FloatRange": {
        "type": "object",
        "properties": {
          "gt": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "gte": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "lt": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "lte": {
            "type": "number",
            "format": "double",
            "nullable": true
          }
        }
      },
      "FloatTimePoint": {
        "type": "object",
        "required": [
          "time_stamp",
          "point"
        ],
        "properties": {
          "point": {
            "type": "number",
            "format": "double"
          },
          "time_stamp": {
            "type": "string"
          }
        }
      },
      "FollowupQueriesResponse": {
        "type": "object",
        "required": [
          "top_queries"
        ],
        "properties": {
          "top_queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FollowupQuery"
            }
          }
        }
      },
      "FollowupQuery": {
        "type": "object",
        "required": [
          "query",
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "format": "int64"
          },
          "query": {
            "type": "string"
          }
        }
      },
      "FullTextBoost": {
        "type": "object",
        "description": "Boost the presence of certain tokens for fulltext (SPLADE) and keyword (BM25) search. I.e. boosting title phrases to priortize title matches or making sure that the listing for AirBNB itself ranks higher than companies who make software for AirBNB hosts by boosting the in-document-frequency of the AirBNB token (AKA word) for its official listing. Conceptually it multiples the in-document-importance second value in the tuples of the SPLADE or BM25 sparse vector of the chunk_html innerText for all tokens present in the boost phrase by the boost factor like so: (token, in-document-importance) -> (token, in-document-importance*boost_factor).",
        "required": [
          "phrase",
          "boost_factor"
        ],
        "properties": {
          "boost_factor": {
            "type": "number",
            "format": "double",
            "description": "Amount to multiplicatevly increase the frequency of the tokens in the phrase by"
          },
          "phrase": {
            "type": "string",
            "description": "The phrase to boost in the fulltext document frequency index"
          }
        }
      },
      "GenerateMessageCompletionsReqPayload": {
        "type": "object",
        "required": [
          "system_message",
          "user_message"
        ],
        "properties": {
          "system_message": {
            "type": "string",
            "description": "The system message to use for the message completion."
          },
          "user_message": {
            "type": "string",
            "description": "The user message to use for the message completion."
          }
        }
      },
      "GenerateOffChunksReqPayload": {
        "type": "object",
        "required": [
          "prev_messages",
          "chunk_ids"
        ],
        "properties": {
          "audio_input": {
            "type": "string",
            "description": "Audio input to be used in the chat. This will be used to generate the audio tokens for the model. The default is None.",
            "nullable": true
          },
          "chunk_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "The ids of the chunks to be retrieved and injected into the context window for RAG."
          },
          "context_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContextOptions"
              }
            ],
            "nullable": true
          },
          "frequency_penalty": {
            "type": "number",
            "format": "float",
            "description": "Frequency penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim. Default is 0.7.",
            "nullable": true
          },
          "highlight_results": {
            "type": "boolean",
            "description": "Set highlight_results to false for a slight latency improvement (1-10ms). If not specified, this defaults to true. This will add `<mark><b>` tags to the chunk_html of the chunks to highlight matching splits.",
            "nullable": true
          },
          "image_config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ImageConfig"
              }
            ],
            "nullable": true
          },
          "image_urls": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Image URLs to be used in the chat. These will be used to generate the image tokens for the model. The default is None.",
            "nullable": true
          },
          "max_tokens": {
            "type": "integer",
            "format": "int32",
            "description": "The maximum number of tokens to generate in the chat completion. Default is None.",
            "nullable": true,
            "minimum": 0
          },
          "metadata": {
            "description": "Metadata is any metadata you want to associate w/ the event that is created from this request",
            "nullable": true
          },
          "presence_penalty": {
            "type": "number",
            "format": "float",
            "description": "Presence penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics. Default is 0.7.",
            "nullable": true
          },
          "prev_messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChatMessageProxy"
            },
            "description": "The previous messages to be placed into the chat history. There must be at least one previous message."
          },
          "prompt": {
            "type": "string",
            "description": "Prompt will be used to tell the model what to generate in the next message in the chat. The default is 'Respond to the previous instruction and include the doc numbers that you used in square brackets at the end of the sentences that you used the docs for:'. You can also specify an empty string to leave the final message alone such that your user's final message can be used as the prompt. See docs.trieve.ai or contact us for more information.",
            "nullable": true
          },
          "stop_tokens": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Stop tokens are up to 4 sequences where the API will stop generating further tokens. Default is None.",
            "nullable": true
          },
          "stream_response": {
            "type": "boolean",
            "description": "Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.",
            "nullable": true
          },
          "temperature": {
            "type": "number",
            "format": "float",
            "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. Default is 0.5.",
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "description": "User ID is the id of the user who is making the request. This is used to track user interactions with the RAG results.",
            "nullable": true
          }
        },
        "example": {
          "chunk_ids": [
            "d290f1ee-6c54-4b01-90e6-d701748f0851"
          ],
          "prev_messages": [
            {
              "content": "How do I setup RAG with Trieve?",
              "role": "user"
            }
          ],
          "prompt": "Respond to the instruction and include the doc numbers that you used in square brackets at the end of the sentences that you used the docs for:",
          "stream_response": true
        }
      },
      "GenerationStrategy": {
        "type": "string",
        "enum": [
          "LLM",
          "Auto"
        ]
      },
      "GeoInfo": {
        "type": "object",
        "description": "Location that you want to use as the center of the search.",
        "required": [
          "lat",
          "lon"
        ],
        "properties": {
          "lat": {
            "$ref": "#/components/schemas/GeoTypes"
          },
          "lon": {
            "$ref": "#/components/schemas/GeoTypes"
          }
        }
      },
      "GeoInfoWithBias": {
        "type": "object",
        "description": "Location bias lets you rank your results by distance from a location. If not specified, this has no effect. Bias allows you to determine how much of an effect the location of chunks will have on the search results. If not specified, this defaults to 0.0. We recommend setting this to 1.0 for a gentle reranking of the results, >3.0 for a strong reranking of the results.",
        "required": [
          "location",
          "bias"
        ],
        "properties": {
          "bias": {
            "type": "number",
            "format": "double",
            "description": "Bias lets you specify how much of an effect the location of chunks will have on the search results. If not specified, this defaults to 0.0. We recommend setting this to 1.0 for a gentle reranking of the results, >3.0 for a strong reranking of the results."
          },
          "location": {
            "$ref": "#/components/schemas/GeoInfo"
          }
        }
      },
      "GeoTypes": {
        "oneOf": [
          {
            "type": "integer",
            "format": "int64"
          },
          {
            "type": "number",
            "format": "double"
          }
        ]
      },
      "GetAllTagsReqPayload": {
        "type": "object",
        "properties": {
          "page": {
            "type": "integer",
            "format": "int64",
            "description": "Page number to return, 1-indexed. Default is 1.",
            "nullable": true
          },
          "page_size": {
            "type": "integer",
            "format": "int64",
            "description": "Number of items to return per page. Default is 20.",
            "nullable": true
          }
        }
      },
      "GetAllTagsResponse": {
        "type": "object",
        "required": [
          "tags",
          "total"
        ],
        "properties": {
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagsWithCount"
            },
            "description": "List of tags with the number of chunks in the dataset with that tag."
          },
          "total": {
            "type": "integer",
            "format": "int64",
            "description": "Total number of unique tags in the dataset."
          }
        }
      },
      "GetChunkGroupCountRequest": {
        "type": "object",
        "properties": {
          "group_id": {
            "type": "string",
            "format": "uuid",
            "description": "The Id of the group to get the count for, is not required if group_tracking_id is provided.",
            "nullable": true
          },
          "group_tracking_id": {
            "type": "string",
            "description": "The tracking id of the group to get the count for, is not required if group_id is provided.",
            "nullable": true
          }
        }
      },
      "GetChunkGroupCountResponse": {
        "type": "object",
        "required": [
          "group_id",
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "format": "int64",
            "description": "The count of chunks in the given group.",
            "minimum": 0
          },
          "group_id": {
            "type": "string",
            "format": "uuid",
            "description": "The Id of the group to get the count for."
          }
        }
      },
      "GetChunksData": {
        "type": "object",
        "required": [
          "ids"
        ],
        "properties": {
          "ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            }
          }
        }
      },
      "GetChunksInGroupResponse": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/GetChunksInGroupsResponseBody"
          },
          {
            "$ref": "#/components/schemas/GroupsBookmarkQueryResult"
          }
        ]
      },
      "GetChunksInGroupsResponseBody": {
        "type": "object",
        "title": "V2",
        "required": [
          "chunks",
          "group",
          "total_pages"
        ],
        "properties": {
          "chunks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChunkMetadata"
            }
          },
          "group": {
            "$ref": "#/components/schemas/ChunkGroupAndFileId"
          },
          "total_pages": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          }
        }
      },
      "GetCrawlRequestsReqPayload": {
        "type": "object",
        "properties": {
          "limit": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "page": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          }
        }
      },
      "GetDatasetsPagination": {
        "type": "object",
        "properties": {
          "limit": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "offset": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          }
        }
      },
      "GetEventCountsRequestBody": {
        "type": "object",
        "properties": {
          "filter": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EventAnalyticsFilter"
              }
            ],
            "nullable": true
          }
        }
      },
      "GetEventsData": {
        "type": "object",
        "properties": {
          "event_types": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EventTypeRequest"
            },
            "description": "The types of events to get. Leave undefined to get all events.",
            "nullable": true
          },
          "page": {
            "type": "integer",
            "format": "int64",
            "description": "The page number to get. Default is 1.",
            "nullable": true
          },
          "page_size": {
            "type": "integer",
            "format": "int64",
            "description": "The number of items per page. Default is 10.",
            "nullable": true
          }
        },
        "example": {
          "page": 1,
          "page_size": 10,
          "type": [
            "chunk_action_failed"
          ]
        }
      },
      "GetEventsRequestBody": {
        "type": "object",
        "properties": {
          "filter": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EventAnalyticsFilter"
              }
            ],
            "nullable": true
          },
          "page": {
            "type": "integer",
            "format": "int32",
            "description": "Page of results to return",
            "nullable": true,
            "minimum": 0
          }
        }
      },
      "GetEventsResponseBody": {
        "type": "object",
        "description": "Response body for the GetEvents endpoint",
        "required": [
          "events"
        ],
        "properties": {
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EventData"
            }
          }
        }
      },
      "GetFilesCursorReqQuery": {
        "type": "object",
        "properties": {
          "cursor": {
            "type": "string",
            "format": "uuid",
            "description": "File ids are compared to the cursor using a greater than or equal to. This is used to paginate through files.",
            "nullable": true
          },
          "page_size": {
            "type": "integer",
            "format": "int64",
            "description": "The page size of files you wish to fetch. Defaults to 10.",
            "nullable": true
          }
        }
      },
      "GetFilesCursorResponseBody": {
        "type": "object",
        "title": "GetFilesCursorResponseBody",
        "required": [
          "file_with_chunk_groups"
        ],
        "properties": {
          "file_with_chunk_groups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FileWithChunkGroups"
            },
            "description": "This is a paginated list of files and their associated groups. The page size is specified in the request. The cursor is used to fetch the next page of files."
          },
          "next_cursor": {
            "type": "string",
            "format": "uuid",
            "description": "Parameter for the next cursor offset. This is used to fetch the next page of files. If there are no more files, this will be None.",
            "nullable": true
          }
        }
      },
      "GetGroupsForChunksReqPayload": {
        "type": "object",
        "properties": {
          "chunk_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true
          },
          "chunk_tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          }
        }
      },
      "GetOrganizationApiKeysQuery": {
        "type": "object",
        "properties": {
          "cursor": {
            "type": "string",
            "format": "uuid",
            "description": "The cursor to start the pagination from.",
            "nullable": true
          },
          "limit": {
            "type": "integer",
            "format": "int32",
            "description": "The number of items to return per page.",
            "nullable": true
          }
        }
      },
      "GetOrganizationApiKeysResponse": {
        "type": "object",
        "required": [
          "api_keys"
        ],
        "properties": {
          "api_keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ApiKeyRespBody"
            },
            "description": "The api keys which belong to the organization."
          },
          "cursor": {
            "type": "string",
            "format": "uuid",
            "description": "The cursor to start the pagination from.",
            "nullable": true
          }
        }
      },
      "GetOrganizationUsageReqPayload": {
        "type": "object",
        "properties": {
          "date_range": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DateRange"
              }
            ],
            "nullable": true
          },
          "v1_usage": {
            "type": "boolean",
            "nullable": true
          }
        }
      },
      "GetPagefindIndexResponse": {
        "type": "object",
        "required": [
          "url"
        ],
        "properties": {
          "url": {
            "type": "string"
          }
        }
      },
      "GetToolFunctionParamsReqPayload": {
        "type": "object",
        "description": "Request payload for getting the parameters of a tool function",
        "required": [
          "tool_function"
        ],
        "properties": {
          "audio_input": {
            "type": "string",
            "description": "The base64 encoded audio input of the user message to attach to the topic and then generate an assistant message in response to.",
            "nullable": true
          },
          "image_url": {
            "type": "string",
            "description": "Image URL to attach to the message to generate the parameters for the tool function.",
            "deprecated": true,
            "nullable": true
          },
          "image_urls": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Image URLs to attach to the message to generate the parameters for the tool function.",
            "nullable": true
          },
          "model": {
            "type": "string",
            "description": "Model name to use for the completion. If not specified, this defaults to the dataset's model.",
            "nullable": true
          },
          "temperature": {
            "type": "number",
            "format": "double",
            "description": "Temperature to use for the completion. If not specified, this defaults to the dataset's temperature.",
            "nullable": true
          },
          "tool_function": {
            "$ref": "#/components/schemas/ToolFunction"
          },
          "user_message_text": {
            "type": "string",
            "description": "Text of the user's message to the assistant which will be used to generate the parameters for the tool function.",
            "nullable": true
          }
        },
        "example": {
          "image_url": "https://example.com/jacket.jpg",
          "tool_function": {
            "description": "Decide on which filters to apply to available catalog being used within the knowledge base to respond. Always get filters.",
            "name": "get_filters",
            "parameters": [
              {
                "description": "Whether or not the user is looking for jackets.",
                "name": "jackets",
                "parameter_type": "boolean"
              },
              {
                "description": "Whether or not the user is looking for shirts.",
                "name": "shirts",
                "parameter_type": "boolean"
              }
            ]
          },
          "user_message_text": "Get filters for the following message: \n\nI am looking for a jacket."
        }
      },
      "GetToolFunctionParamsRespBody": {
        "type": "object",
        "description": "Response body for getting the parameters of a tool function",
        "properties": {
          "parameters": {
            "description": "Parameters for the tool function.",
            "nullable": true
          }
        },
        "example": {
          "parameters": {
            "jackets": true,
            "shirts": false
          }
        }
      },
      "GetTopDatasetsRequestBody": {
        "type": "object",
        "required": [
          "type"
        ],
        "properties": {
          "date_range": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DateRange"
              }
            ],
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/TopDatasetsRequestTypes"
          }
        }
      },
      "GetTrackingChunksData": {
        "type": "object",
        "required": [
          "tracking_ids"
        ],
        "properties": {
          "tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "Granularity": {
        "type": "string",
        "enum": [
          "minute",
          "second",
          "hour",
          "day",
          "month"
        ]
      },
      "GroupBy": {
        "type": "object",
        "description": "Represents a GROUP BY clause",
        "required": [
          "columns"
        ],
        "properties": {
          "columns": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "having": {
            "allOf": [
              {
                "$ref": "#/components/schemas/HavingCondition"
              }
            ],
            "nullable": true
          }
        }
      },
      "GroupData": {
        "type": "object",
        "required": [
          "groups",
          "total_pages"
        ],
        "properties": {
          "groups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChunkGroupAndFileId"
            },
            "description": "The list of all the groups."
          },
          "next_cursor": {
            "type": "string",
            "format": "uuid",
            "description": "Parameter for the next cursor offset.",
            "nullable": true
          },
          "total_pages": {
            "type": "integer",
            "format": "int32",
            "description": "Total number of pages. Pages is groups_count / 10",
            "minimum": 0
          }
        }
      },
      "GroupScoreChunk": {
        "type": "object",
        "title": "V1",
        "required": [
          "group_id",
          "group_created_at",
          "group_updated_at",
          "group_dataset_id",
          "metadata"
        ],
        "properties": {
          "file_id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "group_created_at": {
            "type": "string",
            "format": "date-time"
          },
          "group_dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "group_description": {
            "type": "string",
            "nullable": true
          },
          "group_id": {
            "type": "string",
            "format": "uuid"
          },
          "group_metadata": {
            "nullable": true
          },
          "group_name": {
            "type": "string",
            "nullable": true
          },
          "group_tag_set": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "group_tracking_id": {
            "type": "string",
            "nullable": true
          },
          "group_updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "metadata": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScoreChunkDTO"
            }
          }
        }
      },
      "GroupsBookmarkQueryResult": {
        "type": "object",
        "title": "V1",
        "required": [
          "chunks",
          "group",
          "total_pages"
        ],
        "properties": {
          "chunks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChunkMetadataStringTagSet"
            }
          },
          "group": {
            "$ref": "#/components/schemas/ChunkGroupAndFileId"
          },
          "total_pages": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          }
        }
      },
      "GroupsForChunk": {
        "type": "object",
        "required": [
          "chunk_uuid",
          "slim_groups"
        ],
        "properties": {
          "chunk_uuid": {
            "type": "string",
            "format": "uuid"
          },
          "slim_groups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChunkGroupAndFileId"
            }
          }
        }
      },
      "HasChunkIDCondition": {
        "type": "object",
        "description": "HasChunkIDCondition is a JSON object which can be used to filter chunks by their ids or tracking ids. This is useful for when you want to filter chunks by their ids or tracking ids.",
        "properties": {
          "ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Ids of the chunks to apply a match_any condition with. Only chunks with one of these ids will be returned.",
            "nullable": true
          },
          "tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tracking ids of the chunks to apply a match_any condition with. Only chunks with one of these tracking ids will be returned.",
            "nullable": true
          }
        }
      },
      "HavingCondition": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "function",
              "column",
              "operator",
              "value",
              "type"
            ],
            "properties": {
              "column": {
                "type": "string"
              },
              "function": {
                "$ref": "#/components/schemas/AggregationType"
              },
              "operator": {
                "$ref": "#/components/schemas/FilterOperator"
              },
              "type": {
                "type": "string",
                "enum": [
                  "aggregate"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/FilterValue"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "conditions",
              "type"
            ],
            "properties": {
              "conditions": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/HavingCondition"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "and"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "conditions",
              "type"
            ],
            "properties": {
              "conditions": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/HavingCondition"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "or"
                ]
              }
            }
          }
        ],
        "description": "Structured HAVING condition",
        "discriminator": {
          "propertyName": "type"
        }
      },
      "HeadQueries": {
        "type": "object",
        "required": [
          "query",
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "format": "int64"
          },
          "query": {
            "type": "string"
          }
        }
      },
      "HeadQueryResponse": {
        "type": "object",
        "title": "HeadQueryResponse",
        "required": [
          "queries"
        ],
        "properties": {
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HeadQueries"
            }
          }
        }
      },
      "HeroPattern": {
        "type": "object",
        "properties": {
          "backgroundColor": {
            "type": "string",
            "nullable": true
          },
          "foregroundColor": {
            "type": "string",
            "nullable": true
          },
          "foregroundOpacity": {
            "type": "number",
            "format": "float",
            "nullable": true
          },
          "heroPatternName": {
            "type": "string",
            "nullable": true
          },
          "heroPatternSvg": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "HighlightOptions": {
        "type": "object",
        "description": "Highlight Options lets you specify different methods to highlight the chunks in the result set. If not specified, this defaults to the score of the chunks.",
        "properties": {
          "highlight_delimiters": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Set highlight_delimiters to a list of strings to use as delimiters for highlighting. If not specified, this defaults to [\"?\", \",\", \".\", \"!\"]. These are the characters that will be used to split the chunk_html into splits for highlighting. These are the characters that will be used to split the chunk_html into splits for highlighting.",
            "nullable": true
          },
          "highlight_max_length": {
            "type": "integer",
            "format": "int32",
            "description": "Set highlight_max_length to control the maximum number of tokens (typically whitespace separated strings, but sometimes also word stems) which can be present within a single highlight. If not specified, this defaults to 8. This is useful to shorten large splits which may have low scores due to length compared to the query. Set to something very large like 100 to highlight entire splits.",
            "nullable": true,
            "minimum": 0
          },
          "highlight_max_num": {
            "type": "integer",
            "format": "int32",
            "description": "Set highlight_max_num to control the maximum number of highlights per chunk. If not specified, this defaults to 3. It may be less than 3 if no snippets score above the highlight_threshold.",
            "nullable": true,
            "minimum": 0
          },
          "highlight_results": {
            "type": "boolean",
            "description": "Set highlight_results to false for a slight latency improvement (1-10ms). If not specified, this defaults to true. This will add `<mark><b>` tags to the chunk_html of the chunks to highlight matching splits and return the highlights on each scored chunk in the response.",
            "nullable": true
          },
          "highlight_strategy": {
            "allOf": [
              {
                "$ref": "#/components/schemas/HighlightStrategy"
              }
            ],
            "nullable": true
          },
          "highlight_threshold": {
            "type": "number",
            "format": "double",
            "description": "Set highlight_threshold to a lower or higher value to adjust the sensitivity of the highlights applied to the chunk html. If not specified, this defaults to 0.8. The range is 0.0 to 1.0.",
            "nullable": true
          },
          "highlight_window": {
            "type": "integer",
            "format": "int32",
            "description": "Set highlight_window to a number to control the amount of words that are returned around the matched phrases. If not specified, this defaults to 0. This is useful for when you want to show more context around the matched words. When specified, window/2 whitespace separated words are added before and after each highlight in the response's highlights array. If an extended highlight overlaps with another highlight, the overlapping words are only included once. This parameter can be overriden to respect the highlight_max_length param.",
            "nullable": true,
            "minimum": 0
          },
          "post_tag": {
            "type": "string",
            "description": "Custom html tag which should appear after highlights. If not specified, this defaults to '</mark></b>'.",
            "nullable": true
          },
          "pre_tag": {
            "type": "string",
            "description": "Custom html tag which should appear before highlights. If not specified, this defaults to '<mark><b>'.",
            "nullable": true
          }
        }
      },
      "HighlightStrategy": {
        "type": "string",
        "enum": [
          "exactmatch",
          "v1"
        ]
      },
      "ImageConfig": {
        "type": "object",
        "description": "Configuration for sending images to the llm",
        "properties": {
          "images_per_chunk": {
            "type": "integer",
            "description": "The number of Images to send to the llm per chunk that is fetched more images may slow down llm inference time. default: 5",
            "nullable": true,
            "minimum": 0
          },
          "use_images": {
            "type": "boolean",
            "description": "This sends images to the llm if chunk_metadata.image_urls has some value, the call will error if the model is not a vision LLM model. default: false",
            "nullable": true
          }
        },
        "example": {
          "images_per_chunk": 1,
          "use_images": true
        }
      },
      "ImageEditResponse": {
        "type": "object",
        "required": [
          "image_urls"
        ],
        "properties": {
          "image_urls": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The URL of the generated image"
          }
        }
      },
      "ImageResponseData": {
        "type": "object",
        "required": [
          "b64_json"
        ],
        "properties": {
          "b64_json": {
            "type": "string",
            "description": "The base64-encoded JSON of the generated image."
          }
        }
      },
      "ImageSourceType": {
        "oneOf": [
          {
            "type": "object",
            "title": "Base64",
            "required": [
              "base64"
            ],
            "properties": {
              "base64": {
                "type": "string",
                "description": "Base64 encoded image data"
              }
            }
          },
          {
            "type": "object",
            "title": "URL",
            "required": [
              "url"
            ],
            "properties": {
              "url": {
                "type": "string",
                "description": "URL of the image"
              }
            }
          }
        ]
      },
      "ImageUpload": {
        "type": "object",
        "required": [
          "image_src",
          "file_name"
        ],
        "properties": {
          "file_name": {
            "type": "string",
            "description": "The file name of the image"
          },
          "image_src": {
            "$ref": "#/components/schemas/ImageSourceType"
          }
        }
      },
      "InputImageQuality": {
        "type": "string",
        "enum": [
          "low",
          "medium",
          "high"
        ]
      },
      "InputImageSize": {
        "type": "string",
        "enum": [
          "1024x1024",
          "1024x1536",
          "1536x1024"
        ]
      },
      "IntegerTimePoint": {
        "type": "object",
        "required": [
          "time_stamp",
          "point"
        ],
        "properties": {
          "point": {
            "type": "integer",
            "format": "int64"
          },
          "time_stamp": {
            "type": "string"
          }
        }
      },
      "Invitation": {
        "type": "object",
        "required": [
          "id",
          "email",
          "organization_id",
          "used",
          "created_at",
          "updated_at",
          "role"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "email": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid"
          },
          "role": {
            "type": "integer",
            "format": "int32"
          },
          "scopes": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "used": {
            "type": "boolean"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "email": "trieve@trieve.ai",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "organization_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "role": 1,
          "updated_at": "2021-01-01 00:00:00.000",
          "used": false
        }
      },
      "InvitationData": {
        "type": "object",
        "required": [
          "user_role",
          "email",
          "app_url",
          "redirect_uri"
        ],
        "properties": {
          "app_url": {
            "type": "string",
            "description": "The url of the app that the user will be directed to in order to set their password. Usually admin.trieve.ai, but may differ for local dev or self-hosted setups."
          },
          "email": {
            "type": "string",
            "description": "The email of the user to invite. Must be a valid email as they will be sent an email to register."
          },
          "redirect_uri": {
            "type": "string",
            "description": "The url that the user will be redirected to after setting their password."
          },
          "scopes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The api route scopes the user will have in the organization.",
            "nullable": true
          },
          "user_role": {
            "type": "integer",
            "format": "int32",
            "description": "The role the user will have in the organization. 0 = User, 1 = Admin, 2 = Owner."
          }
        }
      },
      "JoinClause": {
        "type": "object",
        "description": "Represents a join between tables",
        "required": [
          "table",
          "condition"
        ],
        "properties": {
          "condition": {
            "$ref": "#/components/schemas/JoinCondition"
          },
          "join_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/JoinType"
              }
            ],
            "nullable": true
          },
          "table": {
            "$ref": "#/components/schemas/TableName"
          }
        }
      },
      "JoinCondition": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "left_column",
              "right_column",
              "type"
            ],
            "properties": {
              "left_column": {
                "type": "string"
              },
              "right_column": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "column_equals"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "columns",
              "type"
            ],
            "properties": {
              "columns": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "using"
                ]
              }
            }
          }
        ],
        "description": "Structured join condition instead of raw SQL",
        "discriminator": {
          "propertyName": "type"
        }
      },
      "JoinType": {
        "type": "string",
        "description": "Represents the type of join between tables",
        "enum": [
          "inner",
          "left",
          "right",
          "full",
          "cross",
          "anti"
        ]
      },
      "LLMOptions": {
        "type": "object",
        "description": "LLM options to use for the completion. If not specified, this defaults to the dataset's LLM options.",
        "properties": {
          "completion_first": {
            "type": "boolean",
            "description": "Completion first decides whether the stream should contain the stream of the completion response or the chunks first. Default is false. Keep in mind that || is used to separate the chunks from the completion response. If || is in the completion then you may want to split on ||{ instead.",
            "nullable": true
          },
          "frequency_penalty": {
            "type": "number",
            "format": "float",
            "description": "Frequency penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim. Default is 0.7.",
            "nullable": true
          },
          "image_config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ImageConfig"
              }
            ],
            "nullable": true
          },
          "max_tokens": {
            "type": "integer",
            "format": "int32",
            "description": "The maximum number of tokens to generate in the chat completion. Default is None.",
            "nullable": true,
            "minimum": 0
          },
          "presence_penalty": {
            "type": "number",
            "format": "float",
            "description": "Presence penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics. Default is 0.7.",
            "nullable": true
          },
          "stop_tokens": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Stop tokens are up to 4 sequences where the API will stop generating further tokens. Default is None.",
            "nullable": true
          },
          "stream_response": {
            "type": "boolean",
            "description": "Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.",
            "nullable": true
          },
          "system_prompt": {
            "type": "string",
            "description": "Optionally, override the system prompt in dataset server settings.",
            "nullable": true
          },
          "temperature": {
            "type": "number",
            "format": "float",
            "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. Default is 0.5.",
            "nullable": true
          }
        }
      },
      "LatencyGraphResponse": {
        "type": "object",
        "title": "LatencyGraphResponse",
        "required": [
          "points"
        ],
        "properties": {
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FloatTimePoint"
            }
          }
        }
      },
      "LlmGenerationConfig": {
        "type": "object",
        "description": "Controls the processing and generation for the segment.\n- `crop_image` controls whether to crop the file's images to the segment's bounding box.\nThe cropped image will be stored in the segment's `image` field. Use `All` to always crop,\nor `Auto` to only crop when needed for post-processing.\n- `html` is the HTML output for the segment, generated either through huerstics (`Auto`) or using Chunkr fine-tuned models (`LLM`)\n- `llm` is the LLM-generated output for the segment, this uses off-the-shelf models to generate a custom output for the segment\n- `markdown` is the Markdown output for the segment, generated either through huerstics (`Auto`) or using Chunkr fine-tuned models (`LLM`)\n- `embed_sources` defines which content sources will be included in the chunk's embed field and counted towards the chunk length.\nThe array's order determines the sequence in which content appears in the embed field (e.g., [Markdown, LLM] means Markdown content\nis followed by LLM content). This directly affects what content is available for embedding and retrieval.",
        "properties": {
          "crop_image": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CroppingStrategy"
              }
            ],
            "default": "Auto"
          },
          "embed_sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EmbedSource"
            },
            "default": "[Markdown]"
          },
          "html": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GenerationStrategy"
              }
            ],
            "default": "LLM"
          },
          "llm": {
            "type": "string",
            "description": "Prompt for the LLM model",
            "nullable": true
          },
          "markdown": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GenerationStrategy"
              }
            ],
            "default": "LLM"
          }
        }
      },
      "LlmProcessing": {
        "type": "object",
        "description": "Controls the LLM used for the task.",
        "properties": {
          "fallback_strategy": {
            "$ref": "#/components/schemas/FallbackStrategy"
          },
          "max_completion_tokens": {
            "type": "integer",
            "format": "int32",
            "description": "The maximum number of tokens to generate.",
            "nullable": true,
            "minimum": 0
          },
          "model_id": {
            "type": "string",
            "description": "The ID of the model to use for the task. If not provided, the default model will be used.\nPlease check the documentation for the model you want to use.",
            "nullable": true
          },
          "temperature": {
            "type": "number",
            "format": "float",
            "description": "The temperature to use for the LLM."
          }
        }
      },
      "LocationBoundingBox": {
        "type": "object",
        "required": [
          "top_left",
          "bottom_right"
        ],
        "properties": {
          "bottom_right": {
            "$ref": "#/components/schemas/GeoInfo"
          },
          "top_left": {
            "$ref": "#/components/schemas/GeoInfo"
          }
        }
      },
      "LocationPolygon": {
        "type": "object",
        "required": [
          "exterior"
        ],
        "properties": {
          "exterior": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GeoInfo"
            }
          },
          "interior": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/GeoInfo"
              }
            },
            "nullable": true
          }
        }
      },
      "LocationRadius": {
        "type": "object",
        "required": [
          "center",
          "radius"
        ],
        "properties": {
          "center": {
            "$ref": "#/components/schemas/GeoInfo"
          },
          "radius": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "MatchCondition": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "integer",
            "format": "int64"
          },
          {
            "type": "number",
            "format": "double"
          }
        ]
      },
      "Message": {
        "type": "object",
        "required": [
          "id",
          "topic_id",
          "sort_order",
          "content",
          "role",
          "deleted",
          "created_at",
          "updated_at",
          "dataset_id"
        ],
        "properties": {
          "completion_tokens": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "content": {
            "type": "string"
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "deleted": {
            "type": "boolean"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "prompt_tokens": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "role": {
            "type": "string"
          },
          "sort_order": {
            "type": "integer",
            "format": "int32"
          },
          "topic_id": {
            "type": "string",
            "format": "uuid"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        },
        "example": {
          "completion_tokens": 300,
          "content": "Hello, world!",
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "deleted": false,
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "prompt_tokens": 300,
          "role": "user",
          "sort_order": 1,
          "topic_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "updated_at": "2021-01-01 00:00:00.000"
        }
      },
      "MessagesPerUserResponse": {
        "type": "object",
        "required": [
          "avg_messages_per_user",
          "points"
        ],
        "properties": {
          "avg_messages_per_user": {
            "type": "number",
            "format": "double"
          },
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FloatTimePoint"
            }
          }
        }
      },
      "Metadata": {
        "type": "object",
        "properties": {
          "articleSection": {
            "type": "string",
            "nullable": true
          },
          "articleTag": {
            "type": "string",
            "nullable": true
          },
          "dcDate": {
            "type": "string",
            "nullable": true
          },
          "dcDateCreated": {
            "type": "string",
            "nullable": true
          },
          "dcDescription": {
            "type": "string",
            "nullable": true
          },
          "dcSubject": {
            "type": "string",
            "nullable": true
          },
          "dcTermsAudience": {
            "type": "string",
            "nullable": true
          },
          "dcTermsCreated": {
            "type": "string",
            "nullable": true
          },
          "dcTermsKeywords": {
            "type": "string",
            "nullable": true
          },
          "dcTermsSubject": {
            "type": "string",
            "nullable": true
          },
          "dcTermsType": {
            "type": "string",
            "nullable": true
          },
          "dcType": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "error": {
            "type": "string",
            "nullable": true
          },
          "keywords": {
            "type": "string",
            "nullable": true
          },
          "language": {
            "type": "string",
            "nullable": true
          },
          "modifiedTime": {
            "type": "string",
            "nullable": true
          },
          "ogAudio": {
            "type": "string",
            "nullable": true
          },
          "ogDescription": {
            "type": "string",
            "nullable": true
          },
          "ogDeterminer": {
            "type": "string",
            "nullable": true
          },
          "ogImage": {
            "type": "string",
            "nullable": true
          },
          "ogLocale": {
            "type": "string",
            "nullable": true
          },
          "ogLocaleAlternate": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "ogSiteName": {
            "type": "string",
            "nullable": true
          },
          "ogTitle": {
            "type": "string",
            "nullable": true
          },
          "ogUrl": {
            "type": "string",
            "nullable": true
          },
          "ogVideo": {
            "type": "string",
            "nullable": true
          },
          "publishedTime": {
            "type": "string",
            "nullable": true
          },
          "robots": {
            "type": "string",
            "nullable": true
          },
          "site_map": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Sitemap"
              }
            ],
            "nullable": true
          },
          "sourceURL": {
            "type": "string",
            "nullable": true
          },
          "statusCode": {
            "type": "integer",
            "format": "int32",
            "nullable": true,
            "minimum": 0
          },
          "title": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "MmrOptions": {
        "type": "object",
        "description": "MMR Options lets you specify different methods to rerank the chunks in the result set using Maximal Marginal Relevance. If not specified, this defaults to the score of the chunks.",
        "required": [
          "use_mmr"
        ],
        "properties": {
          "mmr_lambda": {
            "type": "number",
            "format": "float",
            "description": "Set mmr_lambda to a value between 0.0 and 1.0 to control the tradeoff between relevance and diversity. Closer to 1.0 will give more diverse results, closer to 0.0 will give more relevant results. If not specified, this defaults to 0.5.",
            "nullable": true
          },
          "use_mmr": {
            "type": "boolean",
            "description": "Set use_mmr to true to use the Maximal Marginal Relevance algorithm to rerank the results."
          }
        }
      },
      "MultiQuery": {
        "type": "object",
        "description": "MultiQuery allows you to construct a dense vector from multiple queries with a weighted sum. This is useful for when you want to emphasize certain features of the query. This only works with Semantic Search and is not compatible with cross encoder re-ranking or highlights.",
        "required": [
          "query",
          "weight"
        ],
        "properties": {
          "query": {
            "$ref": "#/components/schemas/SearchModalities"
          },
          "weight": {
            "type": "number",
            "format": "float",
            "description": "Float value which is applies as a multiplier to the query vector when summing."
          }
        }
      },
      "NewChunkMetadataTypes": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SlimChunkMetadataWithArrayTagSet"
          },
          {
            "$ref": "#/components/schemas/ChunkMetadata"
          },
          {
            "$ref": "#/components/schemas/ContentChunkMetadata"
          }
        ]
      },
      "NotFilterToolCallOptions": {
        "type": "object",
        "properties": {
          "toolDescription": {
            "type": "string",
            "nullable": true
          },
          "userMessageTextPrefix": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "OcrStrategy": {
        "type": "string",
        "description": "Controls the Optical Character Recognition (OCR) strategy.\n- `All`: Processes all pages with OCR. (Latency penalty: ~0.5 seconds per page)\n- `Auto`: Selectively applies OCR only to pages with missing or low-quality text. When text layer is present the bounding boxes from the text layer are used.",
        "enum": [
          "All",
          "Auto"
        ]
      },
      "OpenGraphMetadata": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "nullable": true
          },
          "image": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "OrderBy": {
        "type": "object",
        "required": [
          "columns"
        ],
        "properties": {
          "columns": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "direction": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Direction"
              }
            ],
            "nullable": true
          }
        }
      },
      "Organization": {
        "type": "object",
        "required": [
          "id",
          "name",
          "created_at",
          "updated_at",
          "deleted",
          "partner_configuration"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of the creation of the dataset"
          },
          "deleted": {
            "type": "integer",
            "format": "int32",
            "description": "Flag to indicate if the organization has been deleted. Deletes are handled async after the flag is set so as to avoid expensive search index compaction."
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the dataset, auto-generated uuid created by Trieve"
          },
          "name": {
            "type": "string",
            "description": "Name of the organization"
          },
          "partner_configuration": {
            "description": "Configuration of the organization for the Trieve partner program. Contact partnerships@trieve.ai for more details."
          },
          "registerable": {
            "type": "boolean",
            "description": "Flag to indicate whether or not new users may join the organization. Default is true.",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of the last update of the dataset"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "name": "Trieve",
          "partner_configuration": {
            "COMPANY_NAME": "Trieve",
            "DEMO_DOMAIN": "demos.trieve.ai",
            "FAVICON_URL": "https://cdn.trieve.ai/favicon.ico"
          },
          "registerable": true,
          "updated_at": "2021-01-01 00:00:00.000"
        }
      },
      "OrganizationUsageCount": {
        "type": "object",
        "required": [
          "id",
          "org_id",
          "dataset_count",
          "user_count",
          "file_storage",
          "message_count",
          "chunk_count"
        ],
        "properties": {
          "chunk_count": {
            "type": "integer",
            "format": "int32"
          },
          "dataset_count": {
            "type": "integer",
            "format": "int32"
          },
          "file_storage": {
            "type": "integer",
            "format": "int64"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "message_count": {
            "type": "integer",
            "format": "int32"
          },
          "org_id": {
            "type": "string",
            "format": "uuid"
          },
          "user_count": {
            "type": "integer",
            "format": "int32"
          }
        },
        "example": {
          "chunk_count": 1000,
          "dataset_count": 1,
          "file_storage": 512,
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "message_count": 1000,
          "org_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "user_count": 5
        }
      },
      "OrganizationWithSubAndPlan": {
        "type": "object",
        "required": [
          "organization"
        ],
        "properties": {
          "organization": {
            "$ref": "#/components/schemas/Organization"
          },
          "plan": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TrievePlan"
              }
            ],
            "nullable": true
          },
          "subscription": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TrieveSubscription"
              }
            ],
            "nullable": true
          }
        },
        "example": {
          "organization": {
            "created_at": "2021-01-01 00:00:00.000",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "name": "Trieve",
            "registerable": true,
            "updated_at": "2021-01-01 00:00:00.000"
          },
          "plan": {
            "amount": 1000,
            "chunk_count": 1000,
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_count": 1,
            "file_storage": 512,
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "message_count": 1000,
            "name": "Free",
            "stripe_id": "plan_123",
            "updated_at": "2021-01-01 00:00:00.000",
            "user_count": 5
          },
          "subscription": {
            "created_at": "2021-01-01 00:00:00.000",
            "current_period_end": "2021-01-01 00:00:00.000",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "organization_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "plan_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "stripe_id": "sub_123",
            "updated_at": "2021-01-01 00:00:00.000"
          }
        }
      },
      "PartnerConfiguration": {
        "type": "object",
        "required": [
          "COMPANY_NAME",
          "COMPANY_URL",
          "FAVICON_URL",
          "DEMO_DOMAIN",
          "CALENDAR_LINK",
          "SLACK_LINK",
          "LINKEDIN_LINK",
          "EMAIL",
          "PHONE"
        ],
        "properties": {
          "CALENDAR_LINK": {
            "type": "string"
          },
          "COMPANY_NAME": {
            "type": "string"
          },
          "COMPANY_URL": {
            "type": "string"
          },
          "DEMO_DOMAIN": {
            "type": "string"
          },
          "EMAIL": {
            "type": "string"
          },
          "FAVICON_URL": {
            "type": "string"
          },
          "LINKEDIN_LINK": {
            "type": "string"
          },
          "PHONE": {
            "type": "string"
          },
          "SLACK_LINK": {
            "type": "string"
          }
        },
        "example": {
          "COMPANY_NAME": "Trieve",
          "DEMO_DOMAIN": "demos.trieve.ai",
          "FAVICON_URL": "https://cdn.trieve.ai/favicon.ico"
        }
      },
      "Pdf2MdOptions": {
        "type": "object",
        "description": "We plan to deprecate pdf2md in favor of chunkr.ai. This is a legacy option for using a vision LLM to convert a given file into markdown and then ingest it.",
        "required": [
          "use_pdf2md_ocr"
        ],
        "properties": {
          "split_headings": {
            "type": "boolean",
            "description": "Split headings is an optional field which allows you to specify whether or not to split headings into separate chunks. Default is false.",
            "nullable": true
          },
          "system_prompt": {
            "type": "string",
            "description": "Prompt to use for the gpt-4o model. Default is None.",
            "nullable": true
          },
          "use_pdf2md_ocr": {
            "type": "boolean",
            "description": "Parameter to use pdf2md_ocr. If true, the file will be converted to markdown using gpt-4o. Default is false."
          }
        }
      },
      "PictureCroppingStrategy": {
        "type": "string",
        "description": "Controls the cropping strategy for an item (e.g. segment, chunk, etc.)\n- `All` crops all images in the item\n- `Auto` crops images only if required for post-processing",
        "enum": [
          "All",
          "Auto"
        ]
      },
      "PictureGenerationConfig": {
        "type": "object",
        "description": "Controls the processing and generation for the segment.\n- `crop_image` controls whether to crop the file's images to the segment's bounding box.\nThe cropped image will be stored in the segment's `image` field. Use `All` to always crop,\nor `Auto` to only crop when needed for post-processing.\n- `html` is the HTML output for the segment, generated either through huerstics (`Auto`) or using Chunkr fine-tuned models (`LLM`)\n- `llm` is the LLM-generated output for the segment, this uses off-the-shelf models to generate a custom output for the segment\n- `markdown` is the Markdown output for the segment, generated either through huerstics (`Auto`) or using Chunkr fine-tuned models (`LLM`)\n- `embed_sources` defines which content sources will be included in the chunk's embed field and counted towards the chunk length.\nThe array's order determines the sequence in which content appears in the embed field (e.g., [Markdown, LLM] means Markdown content\nis followed by LLM content). This directly affects what content is available for embedding and retrieval.",
        "properties": {
          "crop_image": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PictureCroppingStrategy"
              }
            ],
            "default": "All"
          },
          "embed_sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EmbedSource"
            },
            "default": "[Markdown]"
          },
          "html": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GenerationStrategy"
              }
            ],
            "default": "LLM"
          },
          "llm": {
            "type": "string",
            "description": "Prompt for the LLM model",
            "nullable": true
          },
          "markdown": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GenerationStrategy"
              }
            ],
            "default": "LLM"
          }
        }
      },
      "PipelineType": {
        "type": "string",
        "enum": [
          "Azure",
          "Chunkr"
        ]
      },
      "PopularChat": {
        "type": "object",
        "required": [
          "name",
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "type": "string"
          }
        }
      },
      "PopularChatsResponse": {
        "type": "object",
        "required": [
          "chats"
        ],
        "properties": {
          "chats": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PopularChat"
            }
          }
        }
      },
      "PopularFilters": {
        "type": "object",
        "required": [
          "clause",
          "field",
          "filter_type",
          "count",
          "common_values"
        ],
        "properties": {
          "clause": {
            "type": "string"
          },
          "common_values": {
            "type": "object",
            "additionalProperties": {
              "type": "integer",
              "format": "int32",
              "minimum": 0
            }
          },
          "count": {
            "type": "integer",
            "format": "int64"
          },
          "field": {
            "type": "string"
          },
          "filter_type": {
            "type": "string"
          }
        },
        "example": {
          "clause": "must",
          "common_values": {
            "130": 2,
            "198": 11
          },
          "count": 8,
          "field": "metadata.ep_num",
          "filter_type": "match_any"
        }
      },
      "PopularFiltersResponse": {
        "type": "object",
        "title": "PopularFiltersResponse",
        "required": [
          "popular_filters"
        ],
        "properties": {
          "popular_filters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PopularFilters"
            }
          }
        }
      },
      "PriceToolCallOptions": {
        "type": "object",
        "required": [
          "toolDescription"
        ],
        "properties": {
          "maxPriceDescription": {
            "type": "string",
            "nullable": true
          },
          "minPriceDescription": {
            "type": "string",
            "nullable": true
          },
          "toolDescription": {
            "type": "string"
          }
        }
      },
      "PublicDatasetOptions": {
        "type": "object",
        "required": [
          "enabled"
        ],
        "properties": {
          "enabled": {
            "type": "boolean"
          },
          "extra_params": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PublicPageParameters"
              }
            ],
            "nullable": true
          }
        }
      },
      "PublicPageParameters": {
        "type": "object",
        "properties": {
          "allowSwitchingModes": {
            "type": "boolean",
            "nullable": true
          },
          "analytics": {
            "type": "boolean",
            "nullable": true
          },
          "apiKey": {
            "type": "string",
            "nullable": true
          },
          "baseUrl": {
            "type": "string",
            "nullable": true
          },
          "brandColor": {
            "type": "string",
            "nullable": true
          },
          "brandFontFamily": {
            "type": "string",
            "nullable": true
          },
          "brandLogoImgSrcUrl": {
            "type": "string",
            "nullable": true
          },
          "brandName": {
            "type": "string",
            "nullable": true
          },
          "buttonTriggers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ButtonTrigger"
            },
            "nullable": true
          },
          "chat": {
            "type": "boolean",
            "nullable": true
          },
          "creatorLinkedInUrl": {
            "type": "string",
            "nullable": true
          },
          "creatorName": {
            "type": "string",
            "nullable": true
          },
          "currencyPosition": {
            "type": "string",
            "nullable": true
          },
          "datasetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "debounceMs": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "defaultAiQuestions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DefaultSearchQueryType"
            },
            "nullable": true
          },
          "defaultCurrency": {
            "type": "string",
            "nullable": true
          },
          "defaultImageQuestion": {
            "type": "string",
            "nullable": true
          },
          "defaultSearchMode": {
            "type": "string",
            "nullable": true
          },
          "defaultSearchQueries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DefaultSearchQueryType"
            },
            "nullable": true
          },
          "defaultSearchQuery": {
            "type": "string",
            "nullable": true
          },
          "floatingButtonPosition": {
            "type": "string",
            "nullable": true
          },
          "floatingButtonVersion": {
            "type": "string",
            "nullable": true
          },
          "floatingSearchIconPosition": {
            "type": "string",
            "nullable": true
          },
          "followupQuestions": {
            "type": "boolean",
            "nullable": true
          },
          "forBrandName": {
            "type": "string",
            "nullable": true
          },
          "headingPrefix": {
            "type": "string",
            "nullable": true
          },
          "heroPattern": {
            "allOf": [
              {
                "$ref": "#/components/schemas/HeroPattern"
              }
            ],
            "nullable": true
          },
          "hideDrawnText": {
            "type": "boolean",
            "nullable": true
          },
          "imageStarterText": {
            "type": "string",
            "nullable": true
          },
          "inline": {
            "type": "boolean",
            "nullable": true
          },
          "inlineHeader": {
            "type": "string",
            "nullable": true
          },
          "isTestMode": {
            "type": "boolean",
            "nullable": true
          },
          "navLogoImgSrcUrl": {
            "type": "string",
            "nullable": true
          },
          "notFilterToolCallOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/NotFilterToolCallOptions"
              }
            ],
            "nullable": true
          },
          "numberOfSuggestions": {
            "type": "integer",
            "nullable": true,
            "minimum": 0
          },
          "openGraphMetadata": {
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenGraphMetadata"
              }
            ],
            "nullable": true
          },
          "openLinksInNewTab": {
            "type": "boolean",
            "nullable": true
          },
          "placeholder": {
            "type": "string",
            "nullable": true
          },
          "priceToolCallOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PriceToolCallOptions"
              }
            ],
            "nullable": true
          },
          "problemLink": {
            "type": "string",
            "nullable": true
          },
          "relevanceToolCallOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RelevanceToolCallOptions"
              }
            ],
            "nullable": true
          },
          "responsive": {
            "type": "boolean",
            "nullable": true
          },
          "searchBar": {
            "type": "boolean",
            "nullable": true
          },
          "searchOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PublicPageSearchOptions"
              }
            ],
            "nullable": true
          },
          "searchPageProps": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchPageProps"
              }
            ],
            "nullable": true
          },
          "searchToolCallOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchToolCallOptions"
              }
            ],
            "nullable": true
          },
          "showFloatingButton": {
            "type": "boolean",
            "nullable": true
          },
          "showFloatingInput": {
            "type": "boolean",
            "nullable": true
          },
          "showFloatingSearchIcon": {
            "type": "boolean",
            "nullable": true
          },
          "showResultHighlights": {
            "type": "boolean",
            "nullable": true
          },
          "singleProductOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SingleProductOptions"
              }
            ],
            "nullable": true
          },
          "suggestedQueries": {
            "type": "boolean",
            "nullable": true
          },
          "tabMessages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PublicPageTabMessage"
            },
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PublicPageTag"
            },
            "nullable": true
          },
          "theme": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PublicPageTheme"
              }
            ],
            "nullable": true
          },
          "type": {
            "type": "string",
            "nullable": true
          },
          "useGroupSearch": {
            "type": "boolean",
            "nullable": true
          },
          "useLocal": {
            "type": "boolean",
            "nullable": true
          },
          "usePagefind": {
            "type": "boolean",
            "nullable": true
          },
          "videoLink": {
            "type": "string",
            "nullable": true
          },
          "videoPosition": {
            "type": "string",
            "nullable": true
          },
          "zIndex": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          }
        }
      },
      "PublicPageSearchOptions": {
        "type": "object",
        "properties": {
          "content_only": {
            "type": "boolean",
            "description": "Set content_only to true to only returning the chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.",
            "nullable": true
          },
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "get_total_pages": {
            "type": "boolean",
            "description": "Get total page count for the query accounting for the applied filters. Defaults to false, but can be set to true when the latency penalty is acceptable (typically 50-200ms).",
            "nullable": true
          },
          "page": {
            "type": "integer",
            "format": "int64",
            "description": "Page of chunks to fetch. Page is 1-indexed.",
            "nullable": true,
            "minimum": 0
          },
          "page_size": {
            "type": "integer",
            "format": "int64",
            "description": "Page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.",
            "nullable": true,
            "minimum": 0
          },
          "remove_stop_words": {
            "type": "boolean",
            "description": "If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.",
            "nullable": true
          },
          "score_threshold": {
            "type": "number",
            "format": "float",
            "description": "Set score_threshold to a float to filter out chunks with a score below the threshold for cosine distance metric. For Manhattan Distance, Euclidean Distance, and Dot Product, it will filter out scores above the threshold distance. This threshold applies before weight and bias modifications. If not specified, this defaults to no threshold. A threshold of 0 will default to no threshold.",
            "nullable": true
          },
          "scoring_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScoringOptions"
              }
            ],
            "nullable": true
          },
          "search_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchMethod"
              }
            ],
            "nullable": true
          },
          "slim_chunks": {
            "type": "boolean",
            "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.",
            "nullable": true
          },
          "sort_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SortOptions"
              }
            ],
            "nullable": true
          },
          "typo_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TypoOptions"
              }
            ],
            "nullable": true
          },
          "use_autocomplete": {
            "type": "boolean",
            "description": "Enables autocomplete on the search modal.",
            "nullable": true
          },
          "use_quote_negated_terms": {
            "type": "boolean",
            "description": "If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.",
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "description": "User ID is the id of the user who is making the request. This is used to track user interactions with the search results.",
            "nullable": true
          }
        },
        "example": {
          "filters": {
            "must": [
              {
                "field": "num_value",
                "range": {
                  "gt": 0.0,
                  "gte": 0.0,
                  "lt": 1.0,
                  "lte": 1.0
                }
              }
            ],
            "must_not": [
              {
                "field": "metadata.key3",
                "match": [
                  "value5",
                  "value6"
                ]
              }
            ],
            "should": [
              {
                "field": "metadata.key1",
                "match": [
                  "value1",
                  "value2"
                ]
              }
            ]
          },
          "score_threshold": 0.5,
          "search_type": "semantic"
        }
      },
      "PublicPageTabMessage": {
        "type": "object",
        "required": [
          "title",
          "tabInnerHtml",
          "showComponentCode"
        ],
        "properties": {
          "showComponentCode": {
            "type": "boolean"
          },
          "tabInnerHtml": {
            "type": "string"
          },
          "title": {
            "type": "string"
          }
        }
      },
      "PublicPageTag": {
        "type": "object",
        "required": [
          "tag"
        ],
        "properties": {
          "description": {
            "type": "string",
            "nullable": true
          },
          "iconClassName": {
            "type": "string",
            "nullable": true
          },
          "label": {
            "type": "string",
            "nullable": true
          },
          "selected": {
            "type": "boolean",
            "nullable": true
          },
          "tag": {
            "type": "string"
          }
        }
      },
      "PublicPageTheme": {
        "type": "string",
        "enum": [
          "light",
          "dark"
        ]
      },
      "PurchaseItem": {
        "type": "object",
        "required": [
          "tracking_id",
          "revenue"
        ],
        "properties": {
          "revenue": {
            "type": "number",
            "format": "double"
          },
          "tracking_id": {
            "type": "string"
          }
        }
      },
      "QdrantChunkMetadata": {
        "type": "object",
        "required": [
          "qdrant_point_id",
          "dataset_id",
          "weight"
        ],
        "properties": {
          "chunk_html": {
            "type": "string",
            "nullable": true
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "group_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true
          },
          "image_urls": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "link": {
            "type": "string",
            "nullable": true
          },
          "location": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GeoInfo"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "nullable": true
          },
          "num_value": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "qdrant_point_id": {
            "type": "string",
            "format": "uuid"
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "nullable": true
          },
          "weight": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "QdrantSortBy": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SortByField"
          },
          {
            "$ref": "#/components/schemas/SortBySearchType"
          }
        ],
        "description": "Sort by lets you specify a method to sort the results by. If not specified, this defaults to the score of the chunks. If specified, this can be any key in the chunk metadata. This key must be a numeric value within the payload."
      },
      "QueryCountResponse": {
        "type": "object",
        "title": "QueryCountResponse",
        "required": [
          "total_queries"
        ],
        "properties": {
          "total_queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchTypeCount"
            }
          }
        }
      },
      "QueryRatingRange": {
        "type": "object",
        "properties": {
          "gt": {
            "type": "integer",
            "format": "int32",
            "nullable": true,
            "minimum": 0
          },
          "gte": {
            "type": "integer",
            "format": "int32",
            "nullable": true,
            "minimum": 0
          },
          "lt": {
            "type": "integer",
            "format": "int32",
            "nullable": true,
            "minimum": 0
          },
          "lte": {
            "type": "integer",
            "format": "int32",
            "nullable": true,
            "minimum": 0
          }
        },
        "example": {
          "gt": 1,
          "gte": 1,
          "lt": 1,
          "lte": 1
        }
      },
      "QueryTypes": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SearchModalities"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MultiQuery"
            }
          }
        ],
        "description": "Query is the search query. This can be any string. The query will be used to create an embedding vector and/or SPLADE vector which will be used to find the result set.  You can either provide one query, or multiple with weights. Multi-query only works with Semantic Search and is not compatible with cross encoder re-ranking or highlights."
      },
      "RAGAnalytics": {
        "oneOf": [
          {
            "type": "object",
            "title": "RAGQueries",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RAGAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "has_clicks": {
                "type": "boolean",
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "sort_by": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RAGSortBy"
                  }
                ],
                "nullable": true
              },
              "sort_order": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SortOrder"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "rag_queries"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "RAGUsage",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RAGAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "rag_usage"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "RAGUsageGraph",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RAGAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "rag_usage_graph"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "QueryDetails",
            "required": [
              "request_id",
              "type"
            ],
            "properties": {
              "request_id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "rag_query_details"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "RAGQueryRatings",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RAGAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "rag_query_ratings"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "FollowupQueries",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RAGAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "followup_queries"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "TopicAnalytics",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TopicAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "sort_by": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RAGSortBy"
                  }
                ],
                "nullable": true
              },
              "sort_order": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SortOrder"
                  }
                ],
                "nullable": true
              },
              "topic_events_filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TopicEventFilter"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "topic_queries"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "TopicDetails",
            "required": [
              "topic_id",
              "type"
            ],
            "properties": {
              "topic_id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "topic_details"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "TopicsOverTime",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TopicAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "topics_over_time"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RAGAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "ctr_metrics_over_time"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RAGAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "messages_per_user"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RAGAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "chat_average_rating"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "ChatConversionRate",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TopicAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "chat_conversion_rate"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "EventFunnel",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TopicAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "event_funnel"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "EventsForTopic",
            "required": [
              "topic_id",
              "type"
            ],
            "properties": {
              "topic_id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "events_for_topic"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "ChatRevenue",
            "required": [
              "type"
            ],
            "properties": {
              "direct": {
                "type": "boolean",
                "nullable": true
              },
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EventAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "chat_revenue"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "PopularChats",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TopicAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "popular_chats"
                ]
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "RAGAnalyticsFilter": {
        "type": "object",
        "properties": {
          "component_name": {
            "type": "string",
            "nullable": true
          },
          "date_range": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DateRange"
              }
            ],
            "nullable": true
          },
          "query": {
            "type": "string",
            "nullable": true
          },
          "query_rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/QueryRatingRange"
              }
            ],
            "nullable": true
          },
          "rag_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RagTypes"
              }
            ],
            "nullable": true
          }
        }
      },
      "RAGAnalyticsResponse": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/RagQueryResponse"
          },
          {
            "$ref": "#/components/schemas/RAGUsageResponse"
          },
          {
            "$ref": "#/components/schemas/RAGUsageGraphResponse"
          },
          {
            "$ref": "#/components/schemas/RagQueryEvent"
          },
          {
            "$ref": "#/components/schemas/RagQueryRatingsResponse"
          },
          {
            "$ref": "#/components/schemas/FollowupQueriesResponse"
          },
          {
            "$ref": "#/components/schemas/TopicQueriesResponse"
          },
          {
            "$ref": "#/components/schemas/TopicDetailsResponse"
          },
          {
            "$ref": "#/components/schemas/TopicsOverTimeResponse"
          },
          {
            "$ref": "#/components/schemas/CTRMetricsOverTimeResponse"
          },
          {
            "$ref": "#/components/schemas/MessagesPerUserResponse"
          },
          {
            "$ref": "#/components/schemas/ChatAverageRatingResponse"
          },
          {
            "$ref": "#/components/schemas/ChatConversionRateResponse"
          },
          {
            "$ref": "#/components/schemas/EventNameAndCountsResponse"
          },
          {
            "$ref": "#/components/schemas/EventsForTopicResponse"
          },
          {
            "$ref": "#/components/schemas/ChatRevenueResponse"
          },
          {
            "$ref": "#/components/schemas/PopularChatsResponse"
          }
        ]
      },
      "RAGSortBy": {
        "type": "string",
        "enum": [
          "hallucination_score",
          "top_score",
          "created_at"
        ]
      },
      "RAGUsageGraphResponse": {
        "type": "object",
        "title": "RAGUsageGraphResponse",
        "required": [
          "points"
        ],
        "properties": {
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntegerTimePoint"
            }
          }
        }
      },
      "RAGUsageResponse": {
        "type": "object",
        "title": "RAGUsageResponse",
        "required": [
          "total_queries"
        ],
        "properties": {
          "total_queries": {
            "type": "integer",
            "format": "int32",
            "minimum": 0
          }
        }
      },
      "RagQueryEvent": {
        "type": "object",
        "title": "RagQueryEvent",
        "required": [
          "id",
          "rag_type",
          "user_message",
          "search_id",
          "topic_id",
          "results",
          "dataset_id",
          "llm_response",
          "top_score",
          "hallucination_score",
          "detected_hallucinations",
          "created_at",
          "user_id"
        ],
        "properties": {
          "created_at": {
            "type": "string"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "detected_hallucinations": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "hallucination_score": {
            "type": "number",
            "format": "double"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "llm_response": {
            "type": "string"
          },
          "metadata": {
            "nullable": true
          },
          "query_rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchQueryRating"
              }
            ],
            "nullable": true
          },
          "rag_type": {
            "$ref": "#/components/schemas/ClickhouseRagTypes"
          },
          "results": {
            "type": "array",
            "items": {}
          },
          "search_id": {
            "type": "string",
            "format": "uuid"
          },
          "top_score": {
            "type": "number",
            "format": "float"
          },
          "topic_id": {
            "type": "string",
            "format": "uuid"
          },
          "user_id": {
            "type": "string"
          },
          "user_message": {
            "type": "string"
          }
        }
      },
      "RagQueryRatingsResponse": {
        "type": "object",
        "title": "RagQueryRatingsResponse",
        "required": [
          "total_positive_ratings",
          "total_negative_ratings"
        ],
        "properties": {
          "total_negative_ratings": {
            "type": "integer",
            "format": "int64",
            "description": "Total number of negative RAG ratings"
          },
          "total_positive_ratings": {
            "type": "integer",
            "format": "int64",
            "description": "Total number of positive RAG ratings"
          }
        }
      },
      "RagQueryResponse": {
        "type": "object",
        "title": "RagQueryResponse",
        "required": [
          "queries"
        ],
        "properties": {
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RagQueryEvent"
            }
          }
        }
      },
      "RagTypes": {
        "type": "string",
        "enum": [
          "chosen_chunks",
          "all_chunks"
        ]
      },
      "Range": {
        "type": "object",
        "properties": {
          "gt": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RangeCondition"
              }
            ],
            "nullable": true
          },
          "gte": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RangeCondition"
              }
            ],
            "nullable": true
          },
          "lt": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RangeCondition"
              }
            ],
            "nullable": true
          },
          "lte": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RangeCondition"
              }
            ],
            "nullable": true
          }
        },
        "example": {
          "gt": 0.0,
          "gte": 0.0,
          "lt": 1.0,
          "lte": 1.0
        }
      },
      "RangeCondition": {
        "oneOf": [
          {
            "type": "number",
            "format": "double"
          },
          {
            "type": "integer",
            "format": "int64"
          }
        ]
      },
      "RangeSliderConfig": {
        "type": "object",
        "properties": {
          "max": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "min": {
            "type": "number",
            "format": "double",
            "nullable": true
          }
        }
      },
      "RateQueryRequest": {
        "type": "object",
        "required": [
          "query_id",
          "rating"
        ],
        "properties": {
          "metadata": {
            "nullable": true
          },
          "note": {
            "type": "string",
            "nullable": true
          },
          "query_id": {
            "type": "string",
            "format": "uuid"
          },
          "rating": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "ReRankOptions": {
        "type": "string",
        "enum": [
          "semantic",
          "fulltext",
          "bm25",
          "cross_encoder"
        ]
      },
      "RecommendChunksRequest": {
        "type": "object",
        "properties": {
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "The number of chunks to return. This is the number of chunks which will be returned in the response. The default is 10.",
            "nullable": true,
            "minimum": 0
          },
          "metadata": {
            "description": "Metadata is any metadata you want to associate w/ the event that is created from this request",
            "nullable": true
          },
          "negative_chunk_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "The ids of the chunks to be used as negative examples for the recommendation. The chunks in this array will be used to filter out similar chunks.",
            "nullable": true
          },
          "negative_tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The tracking_ids of the chunks to be used as negative examples for the recommendation. The chunks in this array will be used to filter out similar chunks.",
            "nullable": true
          },
          "positive_chunk_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "The ids of the chunks to be used as positive examples for the recommendation. The chunks in this array will be used to find similar chunks.",
            "nullable": true
          },
          "positive_tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The tracking_ids of the chunks to be used as positive examples for the recommendation. The chunks in this array will be used to find similar chunks.",
            "nullable": true
          },
          "recommend_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RecommendType"
              }
            ],
            "nullable": true
          },
          "slim_chunks": {
            "type": "boolean",
            "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typicall 10-50ms). Default is false.",
            "nullable": true
          },
          "strategy": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RecommendationStrategy"
              }
            ],
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "description": "User ID is the id of the user who is making the request. This is used to track user interactions with the recommendation results.",
            "nullable": true
          }
        }
      },
      "RecommendChunksResponseBody": {
        "type": "object",
        "title": "V2",
        "required": [
          "id",
          "chunks"
        ],
        "properties": {
          "chunks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScoreChunk"
            }
          },
          "id": {
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "RecommendGroupsReqPayload": {
        "type": "object",
        "properties": {
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "group_size": {
            "type": "integer",
            "format": "int32",
            "description": "The number of chunks to fetch for each group. This is the number of chunks which will be returned in the response for each group. The default is 3. If this is set to a large number, we recommend setting slim_chunks to true to avoid returning the content and chunk_html of the chunks so as to reduce latency due to content download and serialization.",
            "nullable": true,
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "The number of groups to return. This is the number of groups which will be returned in the response. The default is 10.",
            "nullable": true,
            "minimum": 0
          },
          "metadata": {
            "description": "Metadata is any metadata you want to associate w/ the event that is created from this request",
            "nullable": true
          },
          "negative_group_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "The ids of the groups to be used as negative examples for the recommendation. The groups in this array will be used to filter out similar groups.",
            "nullable": true
          },
          "negative_group_tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The ids of the groups to be used as negative examples for the recommendation. The groups in this array will be used to filter out similar groups.",
            "nullable": true
          },
          "positive_group_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "The ids of the groups to be used as positive examples for the recommendation. The groups in this array will be used to find similar groups.",
            "nullable": true
          },
          "positive_group_tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The ids of the groups to be used as positive examples for the recommendation. The groups in this array will be used to find similar groups.",
            "nullable": true
          },
          "recommend_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RecommendType"
              }
            ],
            "nullable": true
          },
          "slim_chunks": {
            "type": "boolean",
            "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typicall 10-50ms). Default is false.",
            "nullable": true
          },
          "strategy": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RecommendationStrategy"
              }
            ],
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "description": "The user_id is the id of the user who is making the request. This is used to track user interactions with the rrecommendation results.",
            "nullable": true
          }
        }
      },
      "RecommendGroupsResponse": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/RecommendGroupsResponseBody"
          },
          {
            "$ref": "#/components/schemas/GroupScoreChunk"
          }
        ]
      },
      "RecommendGroupsResponseBody": {
        "type": "object",
        "title": "V2",
        "required": [
          "id",
          "results"
        ],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchOverGroupsResults"
            }
          }
        }
      },
      "RecommendResponseTypes": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/RecommendChunksResponseBody"
          },
          {
            "$ref": "#/components/schemas/V1RecommendChunksResponseBody"
          }
        ]
      },
      "RecommendType": {
        "type": "string",
        "description": "The type of recommendation to make. This lets you choose whether to recommend based off of `semantic` or `fulltext` similarity. The default is `semantic`.",
        "enum": [
          "semantic",
          "fulltext",
          "bm25"
        ]
      },
      "RecommendationAnalytics": {
        "oneOf": [
          {
            "type": "object",
            "title": "LowConfidenceRecommendations",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RecommendationAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "threshold": {
                "type": "number",
                "format": "float",
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "low_confidence_recommendations"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "RecommendationQueries",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RecommendationAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "has_clicks": {
                "type": "boolean",
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "sort_by": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RecommendationSortBy"
                  }
                ],
                "nullable": true
              },
              "sort_order": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SortOrder"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "recommendation_queries"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "QueryDetails",
            "required": [
              "request_id",
              "type"
            ],
            "properties": {
              "request_id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "query_details"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "RecommendationUsageGraph",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RecommendationAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "recommendation_usage_graph"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "RecommendationsPerUser",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RecommendationAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "recommendations_per_user"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "RecommendationsCTRRate",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RecommendationAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "recommendations_ctr_rate"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "RecommendationConversionRate",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RecommendationAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "recommendation_conversion_rate"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "EventFunnel",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RecommendationAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "event_funnel"
                ]
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "RecommendationAnalyticsFilter": {
        "type": "object",
        "properties": {
          "component_name": {
            "type": "string",
            "nullable": true
          },
          "date_range": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DateRange"
              }
            ],
            "nullable": true
          },
          "recommendation_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RecommendationType"
              }
            ],
            "nullable": true
          },
          "top_score": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FloatRange"
              }
            ],
            "nullable": true
          }
        }
      },
      "RecommendationAnalyticsResponse": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/RecommendationsEventResponse"
          },
          {
            "$ref": "#/components/schemas/RecommendationsEventResponse"
          },
          {
            "$ref": "#/components/schemas/RecommendationEvent"
          },
          {
            "$ref": "#/components/schemas/RecommendationUsageGraphResponse"
          },
          {
            "$ref": "#/components/schemas/RecommendationsPerUserResponse"
          },
          {
            "$ref": "#/components/schemas/RecommendationsCTRRateResponse"
          },
          {
            "$ref": "#/components/schemas/RecommendationsConversionRateResponse"
          },
          {
            "$ref": "#/components/schemas/EventNameAndCountsResponse"
          }
        ]
      },
      "RecommendationCTRMetrics": {
        "type": "object",
        "title": "Recommendation CTR Metrics",
        "required": [
          "recommendations_with_clicks",
          "percent_recommendations_with_clicks",
          "percent_recommendations_without_clicks",
          "avg_position_of_click"
        ],
        "properties": {
          "avg_position_of_click": {
            "type": "number",
            "format": "double"
          },
          "percent_recommendations_with_clicks": {
            "type": "number",
            "format": "double"
          },
          "percent_recommendations_without_clicks": {
            "type": "number",
            "format": "double"
          },
          "recommendations_with_clicks": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "RecommendationEvent": {
        "type": "object",
        "required": [
          "id",
          "recommendation_type",
          "positive_ids",
          "negative_ids",
          "positive_tracking_ids",
          "negative_tracking_ids",
          "request_params",
          "results",
          "top_score",
          "dataset_id",
          "created_at",
          "user_id"
        ],
        "properties": {
          "created_at": {
            "type": "string"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "metadata": {
            "nullable": true
          },
          "negative_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            }
          },
          "negative_tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "positive_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            }
          },
          "positive_tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "recommendation_type": {
            "$ref": "#/components/schemas/ClickhouseRecommendationTypes"
          },
          "request_params": {},
          "results": {
            "type": "array",
            "items": {}
          },
          "top_score": {
            "type": "number",
            "format": "float"
          },
          "user_id": {
            "type": "string"
          }
        }
      },
      "RecommendationSortBy": {
        "type": "string",
        "enum": [
          "created_at",
          "top_score"
        ]
      },
      "RecommendationStrategy": {
        "type": "string",
        "description": "Strategy to use for recommendations, either \"average_vector\" or \"best_score\". The default is \"average_vector\". The \"average_vector\" strategy will construct a single average vector from the positive and negative samples then use it to perform a pseudo-search. The \"best_score\" strategy is more advanced and navigates the HNSW with a heuristic of picking edges where the point is closer to the positive samples than it is the negatives.",
        "enum": [
          "average_vector",
          "best_score"
        ]
      },
      "RecommendationType": {
        "type": "string",
        "enum": [
          "Chunk",
          "Group"
        ]
      },
      "RecommendationUsageGraphResponse": {
        "type": "object",
        "title": "RecommendationUsageGraphResponse",
        "required": [
          "total_requests",
          "points"
        ],
        "properties": {
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntegerTimePoint"
            }
          },
          "total_requests": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          }
        }
      },
      "RecommendationsCTRRateResponse": {
        "type": "object",
        "required": [
          "total_ctr",
          "points"
        ],
        "properties": {
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FloatTimePoint"
            }
          },
          "total_ctr": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "RecommendationsConversionRateResponse": {
        "type": "object",
        "required": [
          "conversion_rate",
          "points"
        ],
        "properties": {
          "conversion_rate": {
            "type": "number",
            "format": "double"
          },
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FloatTimePoint"
            }
          }
        }
      },
      "RecommendationsEventResponse": {
        "type": "object",
        "title": "RecommendationsWithClicks",
        "required": [
          "queries"
        ],
        "properties": {
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RecommendationEvent"
            }
          }
        }
      },
      "RecommendationsPerUserResponse": {
        "type": "object",
        "required": [
          "avg_recommendations_per_user",
          "points"
        ],
        "properties": {
          "avg_recommendations_per_user": {
            "type": "number",
            "format": "double"
          },
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FloatTimePoint"
            }
          }
        }
      },
      "RecommendationsWithClicksCTRResponse": {
        "type": "object",
        "required": [
          "results",
          "request_id",
          "clicked_chunk",
          "created_at"
        ],
        "properties": {
          "clicked_chunk": {
            "$ref": "#/components/schemas/ChunkMetadataWithPosition"
          },
          "created_at": {
            "type": "string"
          },
          "negative_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "negative_tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "positive_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "positive_tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "request_id": {
            "type": "string"
          },
          "results": {
            "type": "array",
            "items": {}
          }
        }
      },
      "RecommendationsWithoutClicksCTRResponse": {
        "type": "object",
        "required": [
          "request_id",
          "created_at"
        ],
        "properties": {
          "created_at": {
            "type": "string"
          },
          "negative_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "negative_tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "positive_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "positive_tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "request_id": {
            "type": "string"
          }
        }
      },
      "RegenerateMessageReqPayload": {
        "type": "object",
        "required": [
          "topic_id"
        ],
        "properties": {
          "concat_user_messages_query": {
            "type": "boolean",
            "description": "If concat user messages query is set to true, all of the user messages in the topic will be concatenated together and used as the search query. If not specified, this defaults to false. Default is false.",
            "nullable": true
          },
          "context_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContextOptions"
              }
            ],
            "nullable": true
          },
          "currency": {
            "type": "string",
            "description": "The currency symbol to use for the completion. If not specified, this defaults to \"$\".",
            "nullable": true
          },
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "highlight_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/HighlightOptions"
              }
            ],
            "nullable": true
          },
          "llm_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LLMOptions"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "description": "Metadata is any metadata you want to associate w/ the event that is created from this request",
            "nullable": true
          },
          "no_result_message": {
            "type": "string",
            "description": "No result message for when there are no chunks found above the score threshold.",
            "nullable": true
          },
          "only_include_docs_used": {
            "type": "boolean",
            "description": "Only include docs used in the completion. If not specified, this defaults to false.",
            "nullable": true
          },
          "page_size": {
            "type": "integer",
            "format": "int64",
            "description": "Page size is the number of chunks to fetch during RAG. If 0, then no search will be performed. If specified, this will override the N retrievals to include in the dataset configuration. Default is None.",
            "nullable": true,
            "minimum": 0
          },
          "rag_context": {
            "type": "string",
            "description": "Overrides what the way chunks are placed into the context window",
            "nullable": true
          },
          "remove_stop_words": {
            "type": "boolean",
            "description": "If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.",
            "nullable": true
          },
          "score_threshold": {
            "type": "number",
            "format": "float",
            "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
            "nullable": true
          },
          "search_query": {
            "type": "string",
            "description": "Query is the search query. This can be any string. The search_query will be used to create a dense embedding vector and/or sparse vector which will be used to find the result set. If not specified, will default to the last user message or HyDE if HyDE is enabled in the dataset configuration. Default is None.",
            "nullable": true
          },
          "search_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchMethod"
              }
            ],
            "nullable": true
          },
          "sort_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SortOptions"
              }
            ],
            "nullable": true
          },
          "topic_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the topic to regenerate the last message for."
          },
          "typo_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TypoOptions"
              }
            ],
            "nullable": true
          },
          "use_group_search": {
            "type": "boolean",
            "description": "If use_group_search is set to true, the search will be conducted using the `search_over_groups` api. If not specified, this defaults to false.",
            "nullable": true
          },
          "use_quote_negated_terms": {
            "type": "boolean",
            "description": "If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.",
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "description": "The user_id is the id of the user who is making the request. This is used to track user interactions with the RAG results.",
            "nullable": true
          }
        }
      },
      "RelevanceToolCallOptions": {
        "type": "object",
        "required": [
          "toolDescription"
        ],
        "properties": {
          "highDescription": {
            "type": "string",
            "nullable": true
          },
          "includeImages": {
            "type": "boolean",
            "nullable": true
          },
          "lowDescription": {
            "type": "string",
            "nullable": true
          },
          "mediumDescription": {
            "type": "string",
            "nullable": true
          },
          "toolDescription": {
            "type": "string"
          },
          "userMessageTextPrefix": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "RemoveChunkFromGroupReqPayload": {
        "type": "object",
        "required": [
          "chunk_id"
        ],
        "properties": {
          "chunk_id": {
            "type": "string",
            "format": "uuid",
            "description": "Id of the chunk to remove from the group."
          }
        }
      },
      "RequestInfo": {
        "type": "object",
        "required": [
          "request_type",
          "request_id"
        ],
        "properties": {
          "request_id": {
            "type": "string",
            "format": "uuid"
          },
          "request_type": {
            "$ref": "#/components/schemas/CTRType"
          }
        }
      },
      "ReturnQueuedChunk": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SingleQueuedChunkResponse"
          },
          {
            "$ref": "#/components/schemas/BatchQueuedChunkResponse"
          }
        ]
      },
      "RoleProxy": {
        "type": "string",
        "enum": [
          "system",
          "user",
          "assistant"
        ]
      },
      "ScoreChunk": {
        "type": "object",
        "title": "V2",
        "required": [
          "chunk",
          "score"
        ],
        "properties": {
          "chunk": {
            "$ref": "#/components/schemas/NewChunkMetadataTypes"
          },
          "highlights": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "score": {
            "type": "number",
            "format": "float"
          }
        },
        "example": {
          "chunk": {
            "chunk_html": "<p>Some HTML content</p>",
            "content": "Some content",
            "id": "d290f1ee-6c54-4b01-90e6-d701748f0851",
            "link": "https://example.com",
            "metadata": {
              "key1": "value1",
              "key2": "value2"
            },
            "time_stamp": "2021-01-01 00:00:00.000",
            "weight": 0.5
          },
          "highlights": [
            "highlight is two tokens: high, light",
            "whereas hello is only one token: hello"
          ],
          "score": 0.5
        }
      },
      "ScoreChunkDTO": {
        "type": "object",
        "required": [
          "metadata",
          "score"
        ],
        "properties": {
          "highlights": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "metadata": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChunkMetadataTypes"
            }
          },
          "score": {
            "type": "number",
            "format": "double"
          }
        },
        "example": {
          "highlights": [
            "highlight is two tokens: high, light",
            "whereas hello is only one token: hello"
          ],
          "metadata": [
            {
              "chunk_html": "<p>Some HTML content</p>",
              "content": "Some content",
              "id": "d290f1ee-6c54-4b01-90e6-d701748f0851",
              "link": "https://example.com",
              "metadata": {
                "key1": "value1",
                "key2": "value2"
              },
              "time_stamp": "2021-01-01 00:00:00.000",
              "weight": 0.5
            }
          ],
          "score": 0.5
        }
      },
      "ScoringOptions": {
        "type": "object",
        "description": "Scoring options provides ways to modify the sparse or dense vector created for the query in order to change how potential matches are scored. If not specified, this defaults to no modifications.",
        "properties": {
          "fulltext_boost": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FullTextBoost"
              }
            ],
            "nullable": true
          },
          "semantic_boost": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SemanticBoost"
              }
            ],
            "nullable": true
          }
        }
      },
      "ScrapeOptions": {
        "oneOf": [
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/CrawlOpenAPIOptions"
              },
              {
                "type": "object",
                "required": [
                  "type"
                ],
                "properties": {
                  "type": {
                    "type": "string",
                    "enum": [
                      "openapi"
                    ]
                  }
                }
              }
            ]
          },
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/CrawlShopifyOptions"
              },
              {
                "type": "object",
                "required": [
                  "type"
                ],
                "properties": {
                  "type": {
                    "type": "string",
                    "enum": [
                      "shopify"
                    ]
                  }
                }
              }
            ]
          },
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/CrawlYoutubeOptions"
              },
              {
                "type": "object",
                "required": [
                  "type"
                ],
                "properties": {
                  "type": {
                    "type": "string",
                    "enum": [
                      "youtube"
                    ]
                  }
                }
              }
            ]
          }
        ],
        "description": "Options for including an openapi spec or shopify settigns",
        "discriminator": {
          "propertyName": "type"
        }
      },
      "ScrollChunksReqPayload": {
        "type": "object",
        "properties": {
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "offset_chunk_id": {
            "type": "string",
            "format": "uuid",
            "description": "Offset chunk id is the id of the chunk to start the page from. If not specified, this defaults to the first chunk in the dataset sorted by id ascending.",
            "nullable": true
          },
          "page_size": {
            "type": "integer",
            "format": "int64",
            "description": "Page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.",
            "nullable": true,
            "minimum": 0
          },
          "sort_by": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SortByField"
              }
            ],
            "nullable": true
          }
        }
      },
      "ScrollChunksResponseBody": {
        "type": "object",
        "required": [
          "chunks"
        ],
        "properties": {
          "chunks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChunkMetadata"
            }
          }
        }
      },
      "SearchAnalytics": {
        "oneOf": [
          {
            "type": "object",
            "title": "LatencyGraph",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "latency_graph"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "SearchUsageGraph",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "search_usage_graph"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "SearchMetrics",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "search_metrics"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "HeadQueries",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "head_queries"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "LowConfidenceQueries",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "threshold": {
                "type": "number",
                "format": "float",
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "low_confidence_queries"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "NoResultQueries",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "no_result_queries"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "SearchQueries",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "has_clicks": {
                "type": "boolean",
                "nullable": true
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "nullable": true,
                "minimum": 0
              },
              "sort_by": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchSortBy"
                  }
                ],
                "nullable": true
              },
              "sort_order": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SortOrder"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "search_queries"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "CountQueries",
            "required": [
              "type"
            ],
            "properties": {
              "count_collapsed_queries": {
                "type": "boolean",
                "nullable": true
              },
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "count_queries"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "QueryDetails",
            "required": [
              "request_id",
              "type"
            ],
            "properties": {
              "request_id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "query_details"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "PopularFilters",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "popular_filters"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "CTRMetricsOverTime",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "ctr_metrics_over_time"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "SearchConversionRate",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "search_conversion_rate"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "SearchesPerUser",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "searches_per_user"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "SearchAverageRating",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "search_average_rating"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "EventFunnel",
            "required": [
              "type"
            ],
            "properties": {
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "event_funnel"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "SearchRevenue",
            "required": [
              "type"
            ],
            "properties": {
              "direct": {
                "type": "boolean",
                "nullable": true
              },
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchAnalyticsFilter"
                  }
                ],
                "nullable": true
              },
              "granularity": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Granularity"
                  }
                ],
                "nullable": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "search_revenue"
                ]
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "SearchAnalyticsFilter": {
        "type": "object",
        "properties": {
          "component_name": {
            "type": "string",
            "nullable": true
          },
          "date_range": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DateRange"
              }
            ],
            "nullable": true
          },
          "query": {
            "type": "string",
            "nullable": true
          },
          "query_rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/QueryRatingRange"
              }
            ],
            "nullable": true
          },
          "search_method": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchMethod"
              }
            ],
            "nullable": true
          },
          "search_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchType"
              }
            ],
            "nullable": true
          },
          "top_score": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FloatRange"
              }
            ],
            "nullable": true
          }
        }
      },
      "SearchAnalyticsResponse": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/LatencyGraphResponse"
          },
          {
            "$ref": "#/components/schemas/SearchUsageGraphResponse"
          },
          {
            "$ref": "#/components/schemas/DatasetAnalytics"
          },
          {
            "$ref": "#/components/schemas/HeadQueryResponse"
          },
          {
            "$ref": "#/components/schemas/SearchQueryResponse"
          },
          {
            "$ref": "#/components/schemas/SearchQueryResponse"
          },
          {
            "$ref": "#/components/schemas/SearchQueryResponse"
          },
          {
            "$ref": "#/components/schemas/QueryCountResponse"
          },
          {
            "$ref": "#/components/schemas/SearchQueryEvent"
          },
          {
            "$ref": "#/components/schemas/PopularFiltersResponse"
          },
          {
            "$ref": "#/components/schemas/CTRMetricsOverTimeResponse"
          },
          {
            "$ref": "#/components/schemas/SearchConversionRateResponse"
          },
          {
            "$ref": "#/components/schemas/SearchesPerUserResponse"
          },
          {
            "$ref": "#/components/schemas/SearchAverageRatingResponse"
          },
          {
            "$ref": "#/components/schemas/EventNameAndCountsResponse"
          },
          {
            "$ref": "#/components/schemas/SearchRevenueResponse"
          }
        ]
      },
      "SearchAverageRatingResponse": {
        "type": "object",
        "required": [
          "avg_search_rating",
          "points"
        ],
        "properties": {
          "avg_search_rating": {
            "type": "number",
            "format": "double"
          },
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FloatTimePoint"
            }
          }
        }
      },
      "SearchCTRMetrics": {
        "type": "object",
        "title": "Search CTR Metrics",
        "required": [
          "searches_with_clicks",
          "percent_searches_with_clicks",
          "percent_searches_without_clicks",
          "avg_position_of_click"
        ],
        "properties": {
          "avg_position_of_click": {
            "type": "number",
            "format": "double"
          },
          "percent_searches_with_clicks": {
            "type": "number",
            "format": "double"
          },
          "percent_searches_without_clicks": {
            "type": "number",
            "format": "double"
          },
          "searches_with_clicks": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "SearchChunkQueryResponseBody": {
        "type": "object",
        "title": "V1",
        "required": [
          "score_chunks",
          "total_chunk_pages"
        ],
        "properties": {
          "corrected_query": {
            "type": "string",
            "nullable": true
          },
          "score_chunks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScoreChunkDTO"
            }
          },
          "total_chunk_pages": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "SearchChunksReqPayload": {
        "type": "object",
        "required": [
          "search_type",
          "query"
        ],
        "properties": {
          "content_only": {
            "type": "boolean",
            "description": "Set content_only to true to only returning the chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.",
            "nullable": true
          },
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "get_total_pages": {
            "type": "boolean",
            "description": "Get total page count for the query accounting for the applied filters. Defaults to false, but can be set to true when the latency penalty is acceptable (typically 50-200ms).",
            "nullable": true
          },
          "highlight_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/HighlightOptions"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "description": "Metadata is any metadata you want to associate w/ the event that is created from this request",
            "nullable": true
          },
          "page": {
            "type": "integer",
            "format": "int64",
            "description": "Page of chunks to fetch. Page is 1-indexed.",
            "nullable": true,
            "minimum": 0
          },
          "page_size": {
            "type": "integer",
            "format": "int64",
            "description": "Page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.",
            "nullable": true,
            "minimum": 0
          },
          "query": {
            "$ref": "#/components/schemas/QueryTypes"
          },
          "remove_stop_words": {
            "type": "boolean",
            "description": "If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.",
            "nullable": true
          },
          "score_threshold": {
            "type": "number",
            "format": "float",
            "description": "Set score_threshold to a float to filter out chunks with a score below the threshold for cosine distance metric. For Manhattan Distance, Euclidean Distance, and Dot Product, it will filter out scores above the threshold distance. This threshold applies before weight and bias modifications. If not specified, this defaults to no threshold. A threshold of 0 will default to no threshold.",
            "nullable": true
          },
          "scoring_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScoringOptions"
              }
            ],
            "nullable": true
          },
          "search_type": {
            "$ref": "#/components/schemas/SearchMethod"
          },
          "slim_chunks": {
            "type": "boolean",
            "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.",
            "nullable": true
          },
          "sort_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SortOptions"
              }
            ],
            "nullable": true
          },
          "typo_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TypoOptions"
              }
            ],
            "nullable": true
          },
          "use_quote_negated_terms": {
            "type": "boolean",
            "description": "If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.",
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "description": "User ID is the id of the user who is making the request. This is used to track user interactions with the search results.",
            "nullable": true
          }
        },
        "example": {
          "filters": {
            "must": [
              {
                "field": "num_value",
                "range": {
                  "gt": 0.0,
                  "gte": 0.0,
                  "lt": 1.0,
                  "lte": 1.0
                }
              }
            ],
            "must_not": [
              {
                "field": "metadata.key3",
                "match": [
                  "value5",
                  "value6"
                ]
              }
            ],
            "should": [
              {
                "field": "metadata.key1",
                "match": [
                  "value1",
                  "value2"
                ]
              }
            ]
          },
          "highlight_delimiters": [
            "?",
            ",",
            ".",
            "!"
          ],
          "highlight_results": true,
          "page": 1,
          "page_size": 10,
          "query": "Some search query",
          "score_threshold": 0.5,
          "search_type": "semantic",
          "use_weights": true
        }
      },
      "SearchClusterResponse": {
        "type": "object",
        "title": "SearchClusterResponse",
        "required": [
          "clusters"
        ],
        "properties": {
          "clusters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchClusterTopics"
            }
          }
        }
      },
      "SearchClusterTopics": {
        "type": "object",
        "required": [
          "id",
          "dataset_id",
          "topic",
          "density",
          "avg_score",
          "created_at"
        ],
        "properties": {
          "avg_score": {
            "type": "number",
            "format": "float"
          },
          "created_at": {
            "type": "string"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "density": {
            "type": "integer",
            "format": "int32"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "topic": {
            "type": "string"
          }
        }
      },
      "SearchConversionRateResponse": {
        "type": "object",
        "required": [
          "conversion_rate",
          "points"
        ],
        "properties": {
          "conversion_rate": {
            "type": "number",
            "format": "double"
          },
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FloatTimePoint"
            }
          }
        }
      },
      "SearchGroupResponseTypes": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SearchWithinGroupResponseBody"
          },
          {
            "$ref": "#/components/schemas/SearchWithinGroupResults"
          }
        ]
      },
      "SearchMethod": {
        "type": "string",
        "enum": [
          "fulltext",
          "semantic",
          "hybrid",
          "bm25"
        ]
      },
      "SearchModalities": {
        "oneOf": [
          {
            "type": "object",
            "title": "Image",
            "required": [
              "image_url"
            ],
            "properties": {
              "image_url": {
                "type": "string"
              },
              "llm_prompt": {
                "type": "string",
                "nullable": true
              }
            }
          },
          {
            "type": "string",
            "title": "Text"
          },
          {
            "type": "object",
            "title": "Audio",
            "required": [
              "audio_base64"
            ],
            "properties": {
              "audio_base64": {
                "type": "string"
              }
            }
          }
        ]
      },
      "SearchOverGroupsReqPayload": {
        "type": "object",
        "required": [
          "search_type",
          "query"
        ],
        "properties": {
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "get_total_pages": {
            "type": "boolean",
            "description": "Get total page count for the query accounting for the applied filters. Defaults to false, but can be set to true when the latency penalty is acceptable (typically 50-200ms).",
            "nullable": true
          },
          "group_size": {
            "type": "integer",
            "format": "int64",
            "description": "Group_size is the number of chunks to fetch for each group. The default is 3. If a group has less than group_size chunks, all chunks will be returned. If this is set to a large number, we recommend setting slim_chunks to true to avoid returning the content and chunk_html of the chunks so as to lower the amount of time required for content download and serialization.",
            "nullable": true,
            "minimum": 0
          },
          "highlight_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/HighlightOptions"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "description": "Metadata is any metadata you want to associate w/ the event that is created from this request",
            "nullable": true
          },
          "page": {
            "type": "integer",
            "format": "int64",
            "description": "Page of group results to fetch. Page is 1-indexed.",
            "nullable": true,
            "minimum": 0
          },
          "page_size": {
            "type": "integer",
            "format": "int64",
            "description": "Page size is the number of group results to fetch. The default is 10.",
            "nullable": true,
            "minimum": 0
          },
          "query": {
            "$ref": "#/components/schemas/QueryTypes"
          },
          "remove_stop_words": {
            "type": "boolean",
            "description": "If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be\npreserved.",
            "nullable": true
          },
          "score_threshold": {
            "type": "number",
            "format": "float",
            "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
            "nullable": true
          },
          "scoring_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScoringOptions"
              }
            ],
            "nullable": true
          },
          "search_type": {
            "$ref": "#/components/schemas/SearchMethod"
          },
          "slim_chunks": {
            "type": "boolean",
            "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typicall 10-50ms). Default is false.",
            "nullable": true
          },
          "sort_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SortOptions"
              }
            ],
            "nullable": true
          },
          "typo_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TypoOptions"
              }
            ],
            "nullable": true
          },
          "use_quote_negated_terms": {
            "type": "boolean",
            "description": "If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.",
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "description": "The user_id is the id of the user who is making the request. This is used to track user interactions with the search results.",
            "nullable": true
          }
        }
      },
      "SearchOverGroupsResponseBody": {
        "type": "object",
        "title": "V2",
        "required": [
          "id",
          "results",
          "total_pages"
        ],
        "properties": {
          "corrected_query": {
            "type": "string",
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchOverGroupsResults"
            }
          },
          "total_pages": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "SearchOverGroupsResponseTypes": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SearchOverGroupsResponseBody"
          },
          {
            "$ref": "#/components/schemas/DeprecatedSearchOverGroupsResponseBody"
          }
        ]
      },
      "SearchOverGroupsResults": {
        "type": "object",
        "title": "V2",
        "required": [
          "group",
          "chunks"
        ],
        "properties": {
          "chunks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScoreChunk"
            }
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "group": {
            "$ref": "#/components/schemas/ChunkGroup"
          }
        }
      },
      "SearchPageProps": {
        "type": "object",
        "properties": {
          "display": {
            "type": "boolean",
            "nullable": true
          },
          "filterSidebarProps": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SidebarFilters"
              }
            ],
            "nullable": true
          }
        }
      },
      "SearchQueriesWithClicksCTRResponse": {
        "type": "object",
        "required": [
          "query",
          "results",
          "clicked_chunk",
          "request_id",
          "created_at"
        ],
        "properties": {
          "clicked_chunk": {
            "$ref": "#/components/schemas/ChunkMetadataWithPosition"
          },
          "created_at": {
            "type": "string"
          },
          "query": {
            "type": "string"
          },
          "request_id": {
            "type": "string"
          },
          "results": {
            "type": "array",
            "items": {}
          }
        }
      },
      "SearchQueriesWithoutClicksCTRResponse": {
        "type": "object",
        "required": [
          "query",
          "request_id",
          "created_at"
        ],
        "properties": {
          "created_at": {
            "type": "string"
          },
          "query": {
            "type": "string"
          },
          "request_id": {
            "type": "string"
          }
        }
      },
      "SearchQueryEvent": {
        "type": "object",
        "title": "SearchQueryEvent",
        "required": [
          "id",
          "search_type",
          "query",
          "request_params",
          "latency",
          "top_score",
          "results",
          "dataset_id",
          "created_at",
          "user_id"
        ],
        "properties": {
          "created_at": {
            "type": "string"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "latency": {
            "type": "number",
            "format": "float"
          },
          "metadata": {
            "nullable": true
          },
          "query": {
            "type": "string"
          },
          "query_rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchQueryRating"
              }
            ],
            "nullable": true
          },
          "request_params": {},
          "results": {
            "type": "array",
            "items": {}
          },
          "search_type": {
            "$ref": "#/components/schemas/ClickhouseSearchTypes"
          },
          "top_score": {
            "type": "number",
            "format": "float"
          },
          "user_id": {
            "type": "string"
          }
        }
      },
      "SearchQueryRating": {
        "type": "object",
        "required": [
          "rating"
        ],
        "properties": {
          "metadata": {
            "nullable": true
          },
          "note": {
            "type": "string",
            "nullable": true
          },
          "rating": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "SearchQueryResponse": {
        "type": "object",
        "title": "SearchQueryResponse",
        "required": [
          "queries"
        ],
        "properties": {
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchQueryEvent"
            }
          }
        }
      },
      "SearchResponseBody": {
        "type": "object",
        "title": "V2",
        "required": [
          "id",
          "chunks",
          "total_pages"
        ],
        "properties": {
          "chunks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScoreChunk"
            }
          },
          "corrected_query": {
            "type": "string",
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "total_pages": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "SearchResponseTypes": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SearchResponseBody"
          },
          {
            "$ref": "#/components/schemas/SearchChunkQueryResponseBody"
          }
        ]
      },
      "SearchResultType": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/ScoreChunkDTO"
          },
          {
            "$ref": "#/components/schemas/GroupScoreChunk"
          }
        ]
      },
      "SearchRevenueResponse": {
        "type": "object",
        "required": [
          "avg_revenue",
          "points"
        ],
        "properties": {
          "avg_revenue": {
            "type": "number",
            "format": "double"
          },
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FloatTimePoint"
            }
          }
        }
      },
      "SearchSortBy": {
        "type": "string",
        "enum": [
          "created_at",
          "latency",
          "top_score"
        ]
      },
      "SearchToolCallOptions": {
        "type": "object",
        "properties": {
          "noSearchRagContext": {
            "type": "string",
            "nullable": true
          },
          "toolDescription": {
            "type": "string",
            "nullable": true
          },
          "userMessageTextPrefix": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "SearchType": {
        "type": "string",
        "enum": [
          "search",
          "autocomplete",
          "search_over_groups",
          "search_within_groups"
        ]
      },
      "SearchTypeCount": {
        "type": "object",
        "required": [
          "search_type",
          "search_method",
          "search_count"
        ],
        "properties": {
          "search_count": {
            "type": "integer",
            "format": "int64"
          },
          "search_method": {
            "type": "string"
          },
          "search_type": {
            "type": "string"
          }
        },
        "example": {
          "search_count": 8,
          "search_type": "search"
        }
      },
      "SearchUsageGraphResponse": {
        "type": "object",
        "title": "SearchUsageGraphResponse",
        "required": [
          "total_searches",
          "points"
        ],
        "properties": {
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntegerTimePoint"
            }
          },
          "total_searches": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "SearchWithinGroupReqPayload": {
        "type": "object",
        "required": [
          "query",
          "search_type"
        ],
        "properties": {
          "content_only": {
            "type": "boolean",
            "description": "Set content_only to true to only returning the chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.",
            "nullable": true
          },
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "get_total_pages": {
            "type": "boolean",
            "description": "Get total page count for the query accounting for the applied filters. Defaults to false, but can be set to true when the latency penalty is acceptable (typically 50-200ms).",
            "nullable": true
          },
          "group_id": {
            "type": "string",
            "format": "uuid",
            "description": "Group specifies the group to search within. Results will only consist of chunks which are bookmarks within the specified group.",
            "nullable": true
          },
          "group_tracking_id": {
            "type": "string",
            "description": "Group_tracking_id specifies the group to search within by tracking id. Results will only consist of chunks which are bookmarks within the specified group. If both group_id and group_tracking_id are provided, group_id will be used.",
            "nullable": true
          },
          "highlight_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/HighlightOptions"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "description": "Metadata is any metadata you want to associate w/ the event that is created from this request",
            "nullable": true
          },
          "page": {
            "type": "integer",
            "format": "int64",
            "description": "The page of chunks to fetch. Page is 1-indexed.",
            "nullable": true,
            "minimum": 0
          },
          "page_size": {
            "type": "integer",
            "format": "int64",
            "description": "The page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.",
            "nullable": true,
            "minimum": 0
          },
          "query": {
            "$ref": "#/components/schemas/QueryTypes"
          },
          "remove_stop_words": {
            "type": "boolean",
            "description": "If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.",
            "nullable": true
          },
          "score_threshold": {
            "type": "number",
            "format": "float",
            "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
            "nullable": true
          },
          "scoring_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScoringOptions"
              }
            ],
            "nullable": true
          },
          "search_type": {
            "$ref": "#/components/schemas/SearchMethod"
          },
          "slim_chunks": {
            "type": "boolean",
            "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typicall 10-50ms). Default is false.",
            "nullable": true
          },
          "sort_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SortOptions"
              }
            ],
            "nullable": true
          },
          "typo_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TypoOptions"
              }
            ],
            "nullable": true
          },
          "use_quote_negated_terms": {
            "type": "boolean",
            "description": "If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.",
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "description": "The user_id is the id of the user who is making the request. This is used to track user interactions with the search results.",
            "nullable": true
          }
        }
      },
      "SearchWithinGroupResponseBody": {
        "type": "object",
        "title": "V2",
        "required": [
          "id",
          "chunks",
          "total_pages"
        ],
        "properties": {
          "chunks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScoreChunk"
            }
          },
          "corrected_query": {
            "type": "string",
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "total_pages": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "SearchWithinGroupResults": {
        "type": "object",
        "title": "V1",
        "required": [
          "bookmarks",
          "group",
          "total_pages"
        ],
        "properties": {
          "bookmarks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScoreChunkDTO"
            }
          },
          "corrected_query": {
            "type": "string",
            "nullable": true
          },
          "group": {
            "$ref": "#/components/schemas/ChunkGroupAndFileId"
          },
          "total_pages": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "SearchesPerUserResponse": {
        "type": "object",
        "required": [
          "avg_searches_per_user",
          "points"
        ],
        "properties": {
          "avg_searches_per_user": {
            "type": "number",
            "format": "double"
          },
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FloatTimePoint"
            }
          }
        }
      },
      "SegmentProcessing": {
        "type": "object",
        "description": "Controls the post-processing of each segment type.\n\nAllows you to generate HTML and Markdown from chunkr models for each segment type.\nBy default, the HTML and Markdown are generated manually using the segmentation information except for `Table`, `Formula` and `Picture`.\nYou can optionally configure custom LLM prompts and models to generate an additional `llm` field with LLM-processed content for each segment type.\n\nThe configuration of which content sources (HTML, Markdown, LLM, Content) of the segment\nshould be included in the chunk's `embed` field and counted towards the chunk length can be configured through the `embed_sources` setting.",
        "properties": {
          "Caption": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AutoGenerationConfig"
              }
            ],
            "nullable": true
          },
          "Footnote": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AutoGenerationConfig"
              }
            ],
            "nullable": true
          },
          "Formula": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LlmGenerationConfig"
              }
            ],
            "nullable": true
          },
          "ListItem": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AutoGenerationConfig"
              }
            ],
            "nullable": true
          },
          "Page": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LlmGenerationConfig"
              }
            ],
            "nullable": true
          },
          "PageFooter": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AutoGenerationConfig"
              }
            ],
            "nullable": true
          },
          "PageHeader": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AutoGenerationConfig"
              }
            ],
            "nullable": true
          },
          "Picture": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PictureGenerationConfig"
              }
            ],
            "nullable": true
          },
          "SectionHeader": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AutoGenerationConfig"
              }
            ],
            "nullable": true
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LlmGenerationConfig"
              }
            ],
            "nullable": true
          },
          "Text": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AutoGenerationConfig"
              }
            ],
            "nullable": true
          },
          "Title": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AutoGenerationConfig"
              }
            ],
            "nullable": true
          }
        }
      },
      "SegmentationStrategy": {
        "type": "string",
        "description": "Controls the segmentation strategy:\n- `LayoutAnalysis`: Analyzes pages for layout elements (e.g., `Table`, `Picture`, `Formula`, etc.) using bounding boxes. Provides fine-grained segmentation and better chunking. (Latency penalty: ~TBD seconds per page).\n- `Page`: Treats each page as a single segment. Faster processing, but without layout element detection and only simple chunking.",
        "enum": [
          "LayoutAnalysis",
          "Page"
        ]
      },
      "SemanticBoost": {
        "type": "object",
        "description": "Semantic boosting moves the dense vector of the chunk in the direction of the distance phrase for semantic search. I.e. you can force a cluster by moving every chunk for a PDF closer to its title or push a chunk with a chunk_html of \"iphone\" 25% closer to the term \"flagship\" by using the distance phrase \"flagship\" and a distance factor of 0.25. Conceptually it's drawing a line (euclidean/L2 distance) between the vector for the innerText of the chunk_html and distance_phrase then moving the vector of the chunk_html distance_factor*L2Distance closer to or away from the distance_phrase point along the line between the two points.",
        "required": [
          "phrase",
          "distance_factor"
        ],
        "properties": {
          "distance_factor": {
            "type": "number",
            "format": "float",
            "description": "Arbitrary float (positive or negative) specifying the multiplicate factor to apply before summing the phrase vector with the chunk_html embedding vector"
          },
          "phrase": {
            "type": "string",
            "description": "Terms to embed in order to create the vector which is weighted summed with the chunk_html embedding vector"
          }
        }
      },
      "ShopifyCustomerEvent": {
        "type": "object",
        "required": [
          "organization_id",
          "store_name",
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid"
          },
          "store_name": {
            "type": "string"
          }
        }
      },
      "ShopifyPlan": {
        "type": "object",
        "required": [
          "handle",
          "status"
        ],
        "properties": {
          "current_period_end": {
            "type": "string",
            "nullable": true
          },
          "handle": {
            "type": "string"
          },
          "status": {
            "type": "string"
          }
        }
      },
      "ShopifyPlanChangePayload": {
        "type": "object",
        "required": [
          "organization_id",
          "idempotency_key",
          "shopify_plan"
        ],
        "properties": {
          "idempotency_key": {
            "type": "string"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid"
          },
          "shopify_plan": {
            "$ref": "#/components/schemas/ShopifyPlan"
          }
        }
      },
      "SidebarFilters": {
        "type": "object",
        "properties": {
          "sections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FilterSidebarSection"
            },
            "nullable": true
          }
        }
      },
      "SingleProductOptions": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "nullable": true
          },
          "groupTrackingId": {
            "type": "string",
            "nullable": true
          },
          "pdpPrompt": {
            "type": "string",
            "nullable": true
          },
          "productDescriptionHtml": {
            "type": "string",
            "nullable": true
          },
          "productName": {
            "type": "string",
            "nullable": true
          },
          "productPrimaryImageUrl": {
            "type": "string",
            "nullable": true
          },
          "productQuestions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DefaultSearchQuery"
            },
            "nullable": true
          },
          "productTrackingId": {
            "type": "string",
            "nullable": true
          },
          "recSearchQuery": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "SingleQueuedChunkResponse": {
        "type": "object",
        "required": [
          "chunk_metadata"
        ],
        "properties": {
          "chunk_metadata": {
            "$ref": "#/components/schemas/ChunkMetadata"
          }
        },
        "example": {
          "chunk_metadata": [
            {
              "content": "Some content",
              "link": "https://example.com",
              "metadata": {
                "key1": "value1",
                "key2": "value2"
              },
              "tag_set": [
                "tag1",
                "tag2"
              ],
              "time_stamp": "2021-01-01 00:00:00.000",
              "tracking_id": "tracking_id",
              "weight": 0.5
            }
          ],
          "pos_in_queue": 1
        }
      },
      "Sitemap": {
        "type": "object",
        "required": [
          "changefreq"
        ],
        "properties": {
          "changefreq": {
            "type": "string"
          }
        }
      },
      "SlimChunkMetadata": {
        "type": "object",
        "required": [
          "id",
          "created_at",
          "updated_at",
          "dataset_id",
          "weight"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "image_urls": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "link": {
            "type": "string",
            "nullable": true
          },
          "location": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GeoInfo"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "nullable": true
          },
          "num_value": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "tag_set": {
            "type": "string",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "weight": {
            "type": "number",
            "format": "double"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "link": "https://trieve.ai",
          "metadata": {
            "key": "value"
          },
          "tag_set": "tag1,tag2",
          "time_stamp": "2021-01-01 00:00:00.000",
          "tracking_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "updated_at": "2021-01-01 00:00:00.000",
          "weight": 0.5
        }
      },
      "SlimChunkMetadataWithArrayTagSet": {
        "type": "object",
        "title": "SlimChunkMetadataWithArrayTagSet",
        "required": [
          "id",
          "created_at",
          "updated_at",
          "dataset_id",
          "weight"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "image_urls": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "link": {
            "type": "string",
            "nullable": true
          },
          "location": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GeoInfo"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "nullable": true
          },
          "num_value": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "weight": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "SlimChunkMetadataWithScore": {
        "type": "object",
        "required": [
          "id",
          "created_at",
          "updated_at",
          "weight",
          "score"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "link": {
            "type": "string",
            "nullable": true
          },
          "metadata": {
            "nullable": true
          },
          "score": {
            "type": "number",
            "format": "float"
          },
          "tag_set": {
            "type": "string",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "weight": {
            "type": "number",
            "format": "double"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "link": "https://trieve.ai",
          "metadata": {
            "key": "value"
          },
          "score": 0.9,
          "tag_set": "tag1,tag2",
          "time_stamp": "2021-01-01 00:00:00.000",
          "tracking_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "updated_at": "2021-01-01 00:00:00.000",
          "weight": 0.5
        }
      },
      "SlimUser": {
        "type": "object",
        "required": [
          "id",
          "email",
          "created_at",
          "user_orgs",
          "orgs"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "email": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "orgs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Organization"
            }
          },
          "user_orgs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UserOrganization"
            }
          }
        },
        "example": {
          "email": "developers@trieve.ai",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "name": "Trieve",
          "orgs": [
            {
              "created_at": "2021-01-01 00:00:00.000",
              "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
              "name": "Trieve",
              "registerable": true,
              "updated_at": "2021-01-01 00:00:00.000"
            }
          ],
          "user_orgs": [
            {
              "created_at": "2021-01-01 00:00:00.000",
              "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
              "org_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
              "role": 0,
              "updated_at": "2021-01-01 00:00:00.000",
              "user_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3"
            }
          ]
        }
      },
      "SortByField": {
        "type": "object",
        "required": [
          "field"
        ],
        "properties": {
          "direction": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SortOrder"
              }
            ],
            "nullable": true
          },
          "field": {
            "type": "string",
            "description": "Field to sort by. This has to be a numeric field with a Qdrant `Range` index on it. i.e. num_value and timestamp"
          },
          "prefetch_amount": {
            "type": "integer",
            "format": "int64",
            "description": "How many results to pull in before the sort",
            "nullable": true,
            "minimum": 0
          }
        }
      },
      "SortBySearchType": {
        "type": "object",
        "required": [
          "rerank_type"
        ],
        "properties": {
          "prefetch_amount": {
            "type": "integer",
            "format": "int64",
            "description": "How many results to pull in before the rerabj",
            "nullable": true,
            "minimum": 0
          },
          "rerank_query": {
            "type": "string",
            "description": "Query to use for prefetching defaults to the search query",
            "nullable": true
          },
          "rerank_type": {
            "$ref": "#/components/schemas/ReRankOptions"
          }
        }
      },
      "SortOptions": {
        "type": "object",
        "description": "Sort Options lets you specify different methods to rerank the chunks in the result set. If not specified, this defaults to the score of the chunks.",
        "properties": {
          "location_bias": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GeoInfoWithBias"
              }
            ],
            "nullable": true
          },
          "mmr": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MmrOptions"
              }
            ],
            "nullable": true
          },
          "recency_bias": {
            "type": "number",
            "format": "float",
            "description": "Recency Bias lets you determine how much of an effect the recency of chunks will have on the search results. If not specified, this defaults to 0.0. We recommend setting this to 1.0 for a gentle reranking of the results, >3.0 for a strong reranking of the results.",
            "nullable": true
          },
          "sort_by": {
            "allOf": [
              {
                "$ref": "#/components/schemas/QdrantSortBy"
              }
            ],
            "nullable": true
          },
          "tag_weights": {
            "type": "object",
            "description": "Tag weights is a JSON object which can be used to boost the ranking of chunks with certain tags. This is useful for when you want to be able to bias towards chunks with a certain tag on the fly. The keys are the tag names and the values are the weights.",
            "additionalProperties": {
              "type": "number",
              "format": "float"
            },
            "nullable": true
          },
          "use_weights": {
            "type": "boolean",
            "description": "Set use_weights to true to use the weights of the chunks in the result set in order to sort them. If not specified, this defaults to true.",
            "nullable": true
          }
        }
      },
      "SortOrder": {
        "type": "string",
        "enum": [
          "desc",
          "asc"
        ]
      },
      "SplitHtmlResponse": {
        "type": "object",
        "required": [
          "chunks"
        ],
        "properties": {
          "chunks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChunkedContent"
            }
          }
        },
        "example": {
          "chunks": [
            {
              "body": "This is the body of the content",
              "headings": [
                "Title Heading",
                "Sub Heading 1",
                "Sub Sub Heading 1"
              ]
            },
            {
              "body": "This is the body of the content",
              "headings": [
                "Title Heading",
                "Sub Heading 1",
                "Sub Sub Heading 2"
              ]
            }
          ]
        }
      },
      "StripeInvoice": {
        "type": "object",
        "required": [
          "id",
          "org_id",
          "total",
          "created_at",
          "status",
          "hosted_invoice_url"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "hosted_invoice_url": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "org_id": {
            "type": "string",
            "format": "uuid"
          },
          "status": {
            "type": "string"
          },
          "stripe_id": {
            "type": "string",
            "nullable": true
          },
          "total": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "StripePlan": {
        "type": "object",
        "required": [
          "id",
          "stripe_id",
          "chunk_count",
          "user_count",
          "dataset_count",
          "message_count",
          "amount",
          "created_at",
          "updated_at",
          "name",
          "visible",
          "file_storage"
        ],
        "properties": {
          "amount": {
            "type": "integer",
            "format": "int64"
          },
          "chunk_count": {
            "type": "integer",
            "format": "int32"
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_count": {
            "type": "integer",
            "format": "int32"
          },
          "file_storage": {
            "type": "integer",
            "format": "int64"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "message_count": {
            "type": "integer",
            "format": "int32"
          },
          "messages_per_month": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "name": {
            "type": "string"
          },
          "stripe_id": {
            "type": "string"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "user_count": {
            "type": "integer",
            "format": "int32"
          },
          "visible": {
            "type": "boolean"
          }
        },
        "example": {
          "amount": 1000,
          "chunk_count": 1000,
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_count": 1,
          "file_storage": 512,
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "message_count": 1000,
          "messages_per_month": 1000,
          "name": "Free",
          "stripe_id": "plan_123",
          "updated_at": "2021-01-01 00:00:00.000",
          "user_count": 5
        }
      },
      "StripeSubscription": {
        "type": "object",
        "required": [
          "id",
          "stripe_id",
          "plan_id",
          "organization_id",
          "created_at",
          "updated_at"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "current_period_end": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid"
          },
          "plan_id": {
            "type": "string",
            "format": "uuid"
          },
          "stripe_id": {
            "type": "string"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "current_period_end": "2021-01-01 00:00:00.000",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "organization_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "plan_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "stripe_id": "sub_123",
          "updated_at": "2021-01-01 00:00:00.000"
        }
      },
      "StripeUsageBasedPlan": {
        "type": "object",
        "required": [
          "id",
          "name",
          "visible",
          "ingest_tokens_price_id",
          "bytes_ingested_price_id",
          "search_tokens_price_id",
          "message_tokens_price_id",
          "analytics_events_price_id",
          "ocr_pages_price_id",
          "pages_crawls_price_id",
          "datasets_price_id",
          "users_price_id",
          "chunks_stored_price_id",
          "files_storage_price_id",
          "created_at"
        ],
        "properties": {
          "analytics_events_price_id": {
            "type": "string"
          },
          "bytes_ingested_price_id": {
            "type": "string"
          },
          "chunks_stored_price_id": {
            "type": "string"
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "datasets_price_id": {
            "type": "string"
          },
          "files_storage_price_id": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "ingest_tokens_price_id": {
            "type": "string"
          },
          "message_tokens_price_id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "ocr_pages_price_id": {
            "type": "string"
          },
          "pages_crawls_price_id": {
            "type": "string"
          },
          "platform_price_amount": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "platform_price_id": {
            "type": "string",
            "nullable": true
          },
          "search_tokens_price_id": {
            "type": "string"
          },
          "users_price_id": {
            "type": "string"
          },
          "visible": {
            "type": "boolean"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "current_period_end": "2021-01-01 00:00:00.000",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "organization_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "plan_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "stripe_id": "sub_123",
          "updated_at": "2021-01-01 00:00:00.000"
        }
      },
      "StripeUsageBasedSubscription": {
        "type": "object",
        "required": [
          "id",
          "organization_id",
          "stripe_subscription_id",
          "usage_based_plan_id",
          "created_at",
          "last_recorded_meter",
          "last_cycle_timestamp",
          "last_cycle_dataset_count",
          "last_cycle_users_count",
          "last_cycle_chunks_stored_mb",
          "last_cycle_files_storage_mb"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "current_period_end": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "last_cycle_chunks_stored_mb": {
            "type": "integer",
            "format": "int64"
          },
          "last_cycle_dataset_count": {
            "type": "integer",
            "format": "int64"
          },
          "last_cycle_files_storage_mb": {
            "type": "integer",
            "format": "int64"
          },
          "last_cycle_timestamp": {
            "type": "string",
            "format": "date-time"
          },
          "last_cycle_users_count": {
            "type": "integer",
            "format": "int32"
          },
          "last_recorded_meter": {
            "type": "string",
            "format": "date-time"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid"
          },
          "stripe_subscription_id": {
            "type": "string"
          },
          "usage_based_plan_id": {
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "SubQuery": {
        "type": "object",
        "description": "Represents a complete ClickHouse query with parameters",
        "required": [
          "columns",
          "table"
        ],
        "properties": {
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Column"
            },
            "description": "Simple columns to select"
          },
          "expressions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Expression"
            },
            "description": "Complex expressions to select",
            "nullable": true
          },
          "filter_conditions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FilterCondition"
            },
            "description": "WHERE clause conditions",
            "nullable": true
          },
          "group_by": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GroupBy"
              }
            ],
            "nullable": true
          },
          "joins": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/JoinClause"
            },
            "description": "Tables to join with",
            "nullable": true
          },
          "limit": {
            "type": "integer",
            "format": "int32",
            "description": "LIMIT clause",
            "nullable": true,
            "minimum": 0
          },
          "offset": {
            "type": "integer",
            "format": "int32",
            "description": "OFFSET clause",
            "nullable": true,
            "minimum": 0
          },
          "order_by": {
            "allOf": [
              {
                "$ref": "#/components/schemas/OrderBy"
              }
            ],
            "nullable": true
          },
          "table": {
            "$ref": "#/components/schemas/TableName"
          }
        }
      },
      "SuggestType": {
        "type": "string",
        "enum": [
          "question",
          "keyword",
          "semantic"
        ]
      },
      "SuggestedQueriesReqPayload": {
        "type": "object",
        "properties": {
          "context": {
            "type": "string",
            "description": "Context is the context of the query. This can be any string under 15 words and 200 characters. The context will be used to generate the suggested queries. Defaults to None.",
            "nullable": true
          },
          "filters": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkFilter"
              }
            ],
            "nullable": true
          },
          "is_ecommerce": {
            "type": "boolean",
            "description": "Whether of not the suggested queries are being generated for ecomm. If true, the suggested queries will be generated for ecomm. If false, the suggested queries will be generated for non-ecomm.",
            "nullable": true
          },
          "is_followup": {
            "type": "boolean",
            "description": "Whether or not the suggested queries are being generated for a followup question. If true, the suggested queries will be generated for a followup question. If false, the suggested queries will be generated for a new question.",
            "nullable": true
          },
          "query": {
            "type": "string",
            "description": "The query to base the generated suggested queries off of using RAG. A hybrid search for 10 chunks from your dataset using this query will be performed and the context of the chunks will be used to generate the suggested queries.",
            "nullable": true
          },
          "search_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchMethod"
              }
            ],
            "nullable": true
          },
          "suggestion_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SuggestType"
              }
            ],
            "nullable": true
          },
          "suggestions_to_create": {
            "type": "integer",
            "description": "The number of suggested queries to create, defaults to 10",
            "nullable": true,
            "minimum": 0
          }
        }
      },
      "SuggestedQueriesResponse": {
        "type": "object",
        "required": [
          "queries"
        ],
        "properties": {
          "queries": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "TableName": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "search_queries"
            ]
          },
          {
            "type": "string",
            "enum": [
              "rag_queries"
            ]
          },
          {
            "type": "string",
            "enum": [
              "recommendations"
            ]
          },
          {
            "type": "string",
            "enum": [
              "events"
            ]
          },
          {
            "type": "string",
            "enum": [
              "cluster_topics"
            ]
          },
          {
            "type": "string",
            "enum": [
              "search_cluster_memberships"
            ]
          },
          {
            "type": "string",
            "enum": [
              "topics"
            ]
          },
          {
            "type": "string",
            "enum": [
              "experiments"
            ]
          },
          {
            "type": "string",
            "enum": [
              "experiment_user_assignments"
            ]
          },
          {
            "type": "object",
            "required": [
              "Custom"
            ],
            "properties": {
              "Custom": {
                "type": "string"
              }
            }
          }
        ]
      },
      "TagProp": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "nullable": true
          },
          "label": {
            "type": "string",
            "nullable": true
          },
          "range": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RangeSliderConfig"
              }
            ],
            "nullable": true
          },
          "tag": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "TagsWithCount": {
        "type": "object",
        "required": [
          "tag",
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "format": "int64",
            "description": "Number of chunks in the dataset with that tag"
          },
          "tag": {
            "type": "string",
            "description": "Content of the tag"
          }
        }
      },
      "Tokenizer": {
        "type": "string",
        "description": "Common tokenizers used for text processing.\n\nThese values represent standard tokenization approaches and popular pre-trained\ntokenizers from the Hugging Face ecosystem.",
        "enum": [
          "Word",
          "Cl100kBase",
          "XlmRobertaBase",
          "BertBaseUncased"
        ]
      },
      "TokenizerType": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "Enum"
            ],
            "properties": {
              "Enum": {
                "$ref": "#/components/schemas/Tokenizer"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "String"
            ],
            "properties": {
              "String": {
                "type": "string",
                "description": "Use any Hugging Face tokenizer by specifying its model ID\nExamples: \"Qwen/Qwen-tokenizer\", \"facebook/bart-large\""
              }
            }
          }
        ],
        "description": "Specifies which tokenizer to use for the chunking process.\n\nThis type supports two ways of specifying a tokenizer:\n1. Using a predefined tokenizer from the `Tokenizer` enum\n2. Using any Hugging Face tokenizer by providing its model ID as a string\n(e.g. \"facebook/bart-large\", \"Qwen/Qwen-tokenizer\", etc.)\n\nWhen using a string, any valid Hugging Face tokenizer ID can be specified,\nwhich will be loaded using the Hugging Face tokenizers library."
      },
      "ToolFunction": {
        "type": "object",
        "description": "Function for a LLM tool call",
        "required": [
          "name",
          "description",
          "parameters"
        ],
        "properties": {
          "description": {
            "type": "string",
            "description": "Description of the function."
          },
          "name": {
            "type": "string",
            "description": "Name of the function."
          },
          "parameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolFunctionParameter"
            },
            "description": "Parameters of the function."
          }
        },
        "example": {
          "description": "Decide on which filters to apply to available catalog being used within the knowledge base to respond. Always get filters.",
          "name": "get_filters",
          "parameters": [
            {
              "description": "Whether or not the user is looking for jackets.",
              "name": "jackets",
              "parameter_type": "boolean"
            },
            {
              "description": "Whether or not the user is looking for shirts.",
              "name": "shirts",
              "parameter_type": "boolean"
            }
          ]
        }
      },
      "ToolFunctionParameter": {
        "type": "object",
        "description": "Function parameter for a LLM tool call",
        "required": [
          "name",
          "parameter_type",
          "description"
        ],
        "properties": {
          "description": {
            "type": "string",
            "description": "The description of the tag."
          },
          "name": {
            "type": "string",
            "description": "Name of the parameter."
          },
          "parameter_type": {
            "$ref": "#/components/schemas/ToolFunctionParameterType"
          }
        },
        "example": {
          "description": "Whether or not the user is looking for jackets.",
          "name": "jackets",
          "parameter_type": "boolean"
        }
      },
      "ToolFunctionParameterType": {
        "type": "string",
        "description": "Type of a given parameter for a LLM tool call",
        "enum": [
          "number",
          "boolean"
        ]
      },
      "TopComponents": {
        "type": "object",
        "required": [
          "component_name",
          "count",
          "cart_count",
          "checkout_count"
        ],
        "properties": {
          "cart_count": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "checkout_count": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "component_name": {
            "type": "string"
          },
          "count": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          }
        }
      },
      "TopComponentsResponse": {
        "type": "object",
        "required": [
          "top_components"
        ],
        "properties": {
          "top_components": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TopComponents"
            }
          }
        }
      },
      "TopDatasetsRequestTypes": {
        "type": "string",
        "enum": [
          "search",
          "rag",
          "recommendation"
        ]
      },
      "TopDatasetsResponse": {
        "type": "object",
        "required": [
          "dataset_id",
          "total_queries"
        ],
        "properties": {
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "dataset_tracking_id": {
            "type": "string",
            "nullable": true
          },
          "total_queries": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "TopPages": {
        "type": "object",
        "required": [
          "page",
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "page": {
            "type": "string"
          }
        }
      },
      "TopPagesResponse": {
        "type": "object",
        "required": [
          "top_pages"
        ],
        "properties": {
          "top_pages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TopPages"
            }
          }
        }
      },
      "Topic": {
        "type": "object",
        "required": [
          "id",
          "name",
          "deleted",
          "created_at",
          "updated_at",
          "dataset_id",
          "owner_id"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "deleted": {
            "type": "boolean"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string"
          },
          "owner_id": {
            "type": "string"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "deleted": false,
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "name": "Trieve",
          "owner_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "updated_at": "2021-01-01 00:00:00.000"
        }
      },
      "TopicAnalyticsFilter": {
        "type": "object",
        "properties": {
          "component_name": {
            "type": "string",
            "nullable": true
          },
          "date_range": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DateRange"
              }
            ],
            "nullable": true
          },
          "hallucination_score": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FloatRange"
              }
            ],
            "nullable": true
          },
          "query": {
            "type": "string",
            "nullable": true
          },
          "query_rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/QueryRatingRange"
              }
            ],
            "nullable": true
          },
          "rag_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RagTypes"
              }
            ],
            "nullable": true
          },
          "top_score": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FloatRange"
              }
            ],
            "nullable": true
          }
        }
      },
      "TopicDetailsResponse": {
        "type": "object",
        "required": [
          "topic",
          "messages"
        ],
        "properties": {
          "messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RagQueryEvent"
            }
          },
          "topic": {
            "$ref": "#/components/schemas/TopicQuery"
          }
        }
      },
      "TopicEventFilter": {
        "type": "object",
        "required": [
          "event_names",
          "inverted"
        ],
        "properties": {
          "event_names": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EventNamesFilter"
            },
            "description": "Filter by event type"
          },
          "inverted": {
            "type": "boolean"
          }
        }
      },
      "TopicQueriesResponse": {
        "type": "object",
        "required": [
          "topics"
        ],
        "properties": {
          "topics": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ClickhouseTopicAnalyticsSummary"
            }
          }
        }
      },
      "TopicQuery": {
        "type": "object",
        "required": [
          "id",
          "name",
          "topic_id",
          "dataset_id",
          "owner_id",
          "created_at",
          "updated_at"
        ],
        "properties": {
          "created_at": {
            "type": "string"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "metadata": {
            "nullable": true
          },
          "name": {
            "type": "string"
          },
          "owner_id": {
            "type": "string"
          },
          "topic_id": {
            "type": "string",
            "format": "uuid"
          },
          "updated_at": {
            "type": "string"
          }
        }
      },
      "TopicsOverTimeResponse": {
        "type": "object",
        "required": [
          "total_topics",
          "points"
        ],
        "properties": {
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntegerTimePoint"
            }
          },
          "total_topics": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "TotalUniqueUsersResponse": {
        "type": "object",
        "required": [
          "total_unique_users",
          "points"
        ],
        "properties": {
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntegerTimePoint"
            }
          },
          "total_unique_users": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          }
        }
      },
      "TranscribeAudioReqPayload": {
        "type": "object",
        "required": [
          "base64_audio"
        ],
        "properties": {
          "base64_audio": {
            "type": "string",
            "description": "The base64 encoded audio input of the user's input message."
          }
        }
      },
      "TrievePlan": {
        "oneOf": [
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/StripePlan"
              },
              {
                "type": "object",
                "required": [
                  "type"
                ],
                "properties": {
                  "type": {
                    "type": "string",
                    "enum": [
                      "flat"
                    ]
                  }
                }
              }
            ]
          },
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/StripeUsageBasedPlan"
              },
              {
                "type": "object",
                "required": [
                  "type"
                ],
                "properties": {
                  "type": {
                    "type": "string",
                    "enum": [
                      "usage_based"
                    ]
                  }
                }
              }
            ]
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "TrieveSubscription": {
        "oneOf": [
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/StripeSubscription"
              },
              {
                "type": "object",
                "required": [
                  "type"
                ],
                "properties": {
                  "type": {
                    "type": "string",
                    "enum": [
                      "flat"
                    ]
                  }
                }
              }
            ]
          },
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/StripeUsageBasedSubscription"
              },
              {
                "type": "object",
                "required": [
                  "type"
                ],
                "properties": {
                  "type": {
                    "type": "string",
                    "enum": [
                      "usage_based"
                    ]
                  }
                }
              }
            ]
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "TypoOptions": {
        "type": "object",
        "description": "Typo Options lets you specify different methods to correct typos in the query. If not specified, typos will not be corrected.",
        "properties": {
          "correct_typos": {
            "type": "boolean",
            "description": "Set correct_typos to true to correct typos in the query. If not specified, this defaults to false.",
            "nullable": true
          },
          "disable_on_word": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Words that should not be corrected. If not specified, this defaults to an empty list.",
            "nullable": true
          },
          "one_typo_word_range": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TypoRange"
              }
            ],
            "nullable": true
          },
          "prioritize_domain_specifc_words": {
            "type": "boolean",
            "description": "Auto-require non-english words present in the dataset to exist in each results chunk_html text. If not specified, this defaults to true.",
            "nullable": true
          },
          "two_typo_word_range": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TypoRange"
              }
            ],
            "nullable": true
          }
        }
      },
      "TypoRange": {
        "type": "object",
        "description": "The TypoRange struct is used to specify the range of which the query will be corrected if it has a typo.",
        "required": [
          "min"
        ],
        "properties": {
          "max": {
            "type": "integer",
            "format": "int32",
            "description": "The maximum number of characters that the query will be corrected if it has a typo. If not specified, this defaults to 8.",
            "nullable": true,
            "minimum": 0
          },
          "min": {
            "type": "integer",
            "format": "int32",
            "description": "The minimum number of characters that the query will be corrected if it has a typo. If not specified, this defaults to 5.",
            "minimum": 0
          }
        }
      },
      "UpdateAllOrgDatasetConfigsReqPayload": {
        "type": "object",
        "required": [
          "to_configuration"
        ],
        "properties": {
          "match_configuration": {
            "description": "The configuration to provide a filter on what datasets to update.",
            "nullable": true
          },
          "to_configuration": {
            "description": "The new configuration for all datasets in the organization. Only the specified keys in the configuration object will be changed per dataset such that you can preserve dataset unique values."
          }
        },
        "example": {
          "organization_id": "00000000-0000-0000-0000-000000000000",
          "server_configuration": {
            "AIMON_RERANKER_TASK_DEFINITION": "Your task is to grade the relevance of context document(s) against the specified user query.",
            "BM25_AVG_LEN": 256.0,
            "BM25_B": 0.75,
            "BM25_ENABLED": true,
            "BM25_K": 0.75,
            "EMBEDDING_BASE_URL": "https://api.openai.com/v1",
            "EMBEDDING_MODEL_NAME": "text-embedding-3-small",
            "EMBEDDING_QUERY_PREFIX": "",
            "EMBEDDING_SIZE": 1536,
            "FREQUENCY_PENALTY": 0.0,
            "FULLTEXT_ENABLED": true,
            "INDEXED_ONLY": false,
            "LLM_BASE_URL": "https://api.openai.com/v1",
            "LLM_DEFAULT_MODEL": "gpt-3.5-turbo-1106",
            "LOCKED": false,
            "MAX_LIMIT": 10000,
            "MESSAGE_TO_QUERY_PROMPT": "Write a 1-2 sentence semantic search query along the lines of a hypothetical response to: \n\n",
            "N_RETRIEVALS_TO_INCLUDE": 8,
            "PRESENCE_PENALTY": 0.0,
            "QDRANT_ONLY": false,
            "RAG_PROMPT": "Use the following retrieved documents to respond briefly and accurately:",
            "SEMANTIC_ENABLED": true,
            "STOP_TOKENS": [
              "\n\n",
              "\n"
            ],
            "SYSTEM_PROMPT": "You are a helpful assistant",
            "TEMPERATURE": 0.5,
            "USE_MESSAGE_TO_QUERY_PROMPT": false
          }
        }
      },
      "UpdateChunkByTrackingIdData": {
        "type": "object",
        "required": [
          "tracking_id"
        ],
        "properties": {
          "chunk_html": {
            "type": "string",
            "description": "HTML content of the chunk you want to update. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content. If no chunk_html is provided, the existing chunk_html will be used.",
            "nullable": true
          },
          "convert_html_to_text": {
            "type": "boolean",
            "description": "Convert HTML to raw text before processing to avoid adding noise to the vector embeddings. By default this is true. If you are using HTML content that you want to be included in the vector embeddings, set this to false.",
            "nullable": true
          },
          "group_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Group ids are the ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.",
            "nullable": true
          },
          "group_tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Group tracking_ids are the tracking_ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.",
            "nullable": true
          },
          "link": {
            "type": "string",
            "description": "Link of the chunk you want to update. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation. If no link is provided, the existing link will be used.",
            "nullable": true
          },
          "metadata": {
            "description": "The metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. If no metadata is provided, the existing metadata will be used.",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "description": "Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results. If no time_stamp is provided, the existing time_stamp will be used.",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "description": "Tracking_id of the chunk you want to update. This is required to match an existing chunk."
          },
          "weight": {
            "type": "number",
            "format": "double",
            "description": "Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk's dataset dataset. If no weight is provided, the existing weight will be used.",
            "nullable": true
          }
        }
      },
      "UpdateChunkGroupReqPayload": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "description": "Description to assign to the chunk_group. Convenience field for you to avoid having to remember what the group is for. If not provided, the description will not be updated.",
            "nullable": true
          },
          "group_id": {
            "type": "string",
            "format": "uuid",
            "description": "Id of the chunk_group to update.",
            "nullable": true
          },
          "metadata": {
            "description": "Optional metadata to assign to the chunk_group. This is a JSON object that can store any additional information you want to associate with the chunks inside of the chunk_group.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Name to assign to the chunk_group. Does not need to be unique. If not provided, the name will not be updated.",
            "nullable": true
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Optional tags to assign to the chunk_group. This is a list of strings that can be used to categorize the chunks inside the chunk_group.",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "description": "Tracking Id of the chunk_group to update.",
            "nullable": true
          },
          "update_chunks": {
            "type": "boolean",
            "description": "Flag to update the chunks in the group. If true, each chunk in the group will be updated\nby appending the group's tags to the chunk's tags. Default is false.",
            "nullable": true
          }
        }
      },
      "UpdateChunkReqPayload": {
        "type": "object",
        "properties": {
          "chunk_html": {
            "type": "string",
            "description": "HTML content of the chunk you want to update. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content. If no chunk_html is provided, the existing chunk_html will be used.",
            "nullable": true
          },
          "chunk_id": {
            "type": "string",
            "format": "uuid",
            "description": "Id of the chunk you want to update. You can provide either the chunk_id or the tracking_id. If both are provided, the chunk_id will be used.",
            "nullable": true
          },
          "convert_html_to_text": {
            "type": "boolean",
            "description": "Convert HTML to raw text before processing to avoid adding noise to the vector embeddings. By default this is true. If you are using HTML content that you want to be included in the vector embeddings, set this to false.",
            "nullable": true
          },
          "fulltext_boost": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FullTextBoost"
              }
            ],
            "nullable": true
          },
          "group_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Group ids are the ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.",
            "nullable": true
          },
          "group_tracking_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Group tracking_ids are the tracking_ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.",
            "nullable": true
          },
          "image_urls": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Image urls are a list of urls to images that are associated with the chunk. This is useful for when you want to associate images with a chunk. If no image_urls are provided, the existing image_urls will be used.",
            "nullable": true
          },
          "link": {
            "type": "string",
            "description": "Link of the chunk you want to update. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation. If no link is provided, the existing link will be used.",
            "nullable": true
          },
          "location": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GeoInfo"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "description": "The metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. If no metadata is provided, the existing metadata will be used.",
            "nullable": true
          },
          "num_value": {
            "type": "number",
            "format": "double",
            "description": "Num value is an arbitrary numerical value that can be used to filter chunks. This is useful for when you want to filter chunks by numerical value. If no num_value is provided, the existing num_value will be used.",
            "nullable": true
          },
          "semantic_boost": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SemanticBoost"
              }
            ],
            "nullable": true
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tag set is a list of tags. This can be used to filter chunks by tag. Unlike with metadata filtering, HNSW indices will exist for each tag such that there is not a performance hit for filtering on them. If no tag_set is provided, the existing tag_set will be used.",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "description": "Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results. If no time_stamp is provided, the existing time_stamp will be used.",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "description": "Tracking_id of the chunk you want to update. This is required to match an existing chunk.",
            "nullable": true
          },
          "weight": {
            "type": "number",
            "format": "double",
            "description": "Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk's dataset dataset. If no weight is provided, the existing weight will be used.",
            "nullable": true
          }
        },
        "example": {
          "chunk_html": "<p>Some HTML content</p>",
          "chunk_id": "d290f1ee-6c54-4b01-90e6-d701748f0851",
          "group_ids": [
            "d290f1ee-6c54-4b01-90e6-d701748f0851"
          ],
          "link": "https://example.com",
          "metadata": {
            "key1": "value1",
            "key2": "value2"
          },
          "time_stamp": "2021-01-01 00:00:00.000",
          "weight": 0.5
        }
      },
      "UpdateCrawlReqPayload": {
        "type": "object",
        "required": [
          "crawl_id",
          "crawl_options"
        ],
        "properties": {
          "crawl_id": {
            "type": "string",
            "format": "uuid",
            "description": "Crawl ID to update"
          },
          "crawl_options": {
            "$ref": "#/components/schemas/CrawlOptions"
          }
        }
      },
      "UpdateDatasetReqPayload": {
        "type": "object",
        "properties": {
          "dataset_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the dataset you want to update.",
            "nullable": true
          },
          "dataset_name": {
            "type": "string",
            "description": "The new name of the dataset. Must be unique within the organization. If not provided, the name will not be updated.",
            "nullable": true
          },
          "new_tracking_id": {
            "type": "string",
            "description": "Optional new tracking ID for the dataset. Can be used to track the dataset in external systems. Must be unique within the organization. If not provided, the tracking ID will not be updated. Strongly recommended to not use a valid uuid value as that will not work with the TR-Dataset header.",
            "nullable": true
          },
          "server_configuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DatasetConfigurationDTO"
              }
            ],
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "description": "The tracking ID of the dataset you want to update.",
            "nullable": true
          }
        },
        "example": {
          "dataset_id": "00000000-0000-0000-0000-000000000000",
          "dataset_name": "My Dataset",
          "server_configuration": {
            "AIMON_RERANKER_TASK_DEFINITION": "Your task is to grade the relevance of context document(s) against the specified user query.",
            "BM25_AVG_LEN": 256.0,
            "BM25_B": 0.75,
            "BM25_ENABLED": true,
            "BM25_K": 0.75,
            "EMBEDDING_BASE_URL": "https://api.openai.com/v1",
            "EMBEDDING_MODEL_NAME": "text-embedding-3-small",
            "EMBEDDING_QUERY_PREFIX": "",
            "EMBEDDING_SIZE": 1536,
            "FREQUENCY_PENALTY": 0.0,
            "FULLTEXT_ENABLED": true,
            "INDEXED_ONLY": false,
            "LLM_BASE_URL": "https://api.openai.com/v1",
            "LLM_DEFAULT_MODEL": "gpt-3.5-turbo-1106",
            "LOCKED": false,
            "MAX_LIMIT": 10000,
            "MESSAGE_TO_QUERY_PROMPT": "Write a 1-2 sentence semantic search query along the lines of a hypothetical response to: \n\n",
            "N_RETRIEVALS_TO_INCLUDE": 8,
            "PRESENCE_PENALTY": 0.0,
            "QDRANT_ONLY": false,
            "RAG_PROMPT": "Use the following retrieved documents to respond briefly and accurately:",
            "SEMANTIC_ENABLED": true,
            "STOP_TOKENS": [
              "\n\n",
              "\n"
            ],
            "SYSTEM_PROMPT": "You are a helpful assistant",
            "TEMPERATURE": 0.5,
            "USE_MESSAGE_TO_QUERY_PROMPT": false
          }
        }
      },
      "UpdateExperimentReqBody": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "experiment_config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ExperimentConfig"
              }
            ],
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "UpdateGroupByTrackingIDReqPayload": {
        "type": "object",
        "required": [
          "tracking_id"
        ],
        "properties": {
          "description": {
            "type": "string",
            "description": "Description to assign to the chunk_group. Convenience field for you to avoid having to remember what the group is for. If not provided, the description will not be updated.",
            "nullable": true
          },
          "metadata": {
            "description": "Optional metadata to assign to the chunk_group. This is a JSON object that can store any additional information you want to associate with the chunks inside of the chunk_group.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Name to assign to the chunk_group. Does not need to be unique. If not provided, the name will not be updated.",
            "nullable": true
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Optional tags to assign to the chunk_group. This is a list of strings that can be used to categorize the chunks inside the chunk_group.",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "description": "Tracking Id of the chunk_group to update."
          }
        }
      },
      "UpdateOrganizationReqPayload": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The new name of the organization. If not provided, the name will not be updated.",
            "nullable": true
          },
          "partner_configuration": {
            "description": "New details for the partnership configuration. If not provided, the partnership configuration will not be updated.",
            "nullable": true
          }
        }
      },
      "UpdateTopicReqPayload": {
        "type": "object",
        "required": [
          "topic_id",
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The new name of the topic. A name is not generated from this field, it is used as-is."
          },
          "topic_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the topic to target."
          }
        }
      },
      "UpdateUserReqPayload": {
        "type": "object",
        "properties": {
          "role": {
            "type": "integer",
            "format": "int32",
            "description": "Either 0 (user), 1 (admin), or 2 (owner). If not provided, the current role will be used. The auth'ed user must have a role greater than or equal to the role being assigned.",
            "nullable": true
          },
          "scopes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The scopes the user will have in the organization.",
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the user to update, if not provided, the auth'ed user will be updated. If provided, the role of the auth'ed user or api key must be an admin (1) or owner (2) of the organization.",
            "nullable": true
          }
        }
      },
      "UploadFileReqPayload": {
        "type": "object",
        "required": [
          "base64_file",
          "file_name"
        ],
        "properties": {
          "base64_file": {
            "type": "string",
            "description": "Base64 encoded file."
          },
          "chunkr_create_task_req_payload": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateFormWithoutFile"
              }
            ],
            "nullable": true
          },
          "create_chunks": {
            "type": "boolean",
            "description": "Create chunks is a boolean which determines whether or not to create chunks from the file. If false, you can manually chunk the file and send the chunks to the create_chunk endpoint with the file_id to associate chunks with the file. Meant mostly for advanced users.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "Description is an optional convience field so you do not have to remember what the file contains or is about. It will be included on the group resulting from the file which will hold its chunk.",
            "nullable": true
          },
          "file_name": {
            "type": "string",
            "description": "Name of the file being uploaded, including the extension."
          },
          "group_tracking_id": {
            "type": "string",
            "description": "Group tracking id is an optional field which allows you to specify the tracking id of the group that is created from the file. Chunks created will be created with the tracking id of `group_tracking_id|<index of chunk>`",
            "nullable": true
          },
          "link": {
            "type": "string",
            "description": "Link to the file. This can also be any string. This can be used to filter when searching for the file's resulting chunks. The link value will not affect embedding creation.",
            "nullable": true
          },
          "metadata": {
            "description": "Metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. Will be passed down to the file's chunks.",
            "nullable": true
          },
          "pdf2md_options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Pdf2MdOptions"
              }
            ],
            "nullable": true
          },
          "rebalance_chunks": {
            "type": "boolean",
            "description": "Rebalance chunks is an optional field which allows you to specify whether or not to rebalance the chunks created from the file. If not specified, the default true is used. If true, Trieve will evenly distribute remainder splits across chunks such that 66 splits with a `target_splits_per_chunk` of 20 will result in 3 chunks with 22 splits each.",
            "nullable": true
          },
          "split_avg": {
            "type": "boolean",
            "description": "Split average will automatically split your file into multiple chunks and average all of the resulting vectors into a single output chunk. Default is false. Explicitly enabling this will cause each file to only produce a single chunk.",
            "nullable": true
          },
          "split_delimiters": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Split delimiters is an optional field which allows you to specify the delimiters to use when splitting the file before chunking the text. If not specified, the default [.!?\\n] are used to split into sentences. However, you may want to use spaces or other delimiters.",
            "nullable": true
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tag set is a comma separated list of tags which will be passed down to the chunks made from the file. Tags are used to filter chunks when searching. HNSW indices are created for each tag such that there is no performance loss when filtering on them.",
            "nullable": true
          },
          "target_splits_per_chunk": {
            "type": "integer",
            "description": "Target splits per chunk. This is an optional field which allows you to specify the number of splits you want per chunk. If not specified, the default 20 is used. However, you may want to use a different number.",
            "nullable": true,
            "minimum": 0
          },
          "time_stamp": {
            "type": "string",
            "description": "Time stamp should be an ISO 8601 combined date and time without timezone. Time_stamp is used for time window filtering and recency-biasing search results. Will be passed down to the file's chunks.",
            "nullable": true
          },
          "webhook_url": {
            "type": "string",
            "description": "Optional webhook URL to receive notifications for each page processed.",
            "nullable": true
          }
        },
        "example": {
          "base64_file": "<base64_encoded_file>",
          "create_chunks": true,
          "description": "This is an example file",
          "file_name": "example.pdf",
          "link": "https://example.com",
          "metadata": {
            "key1": "value1",
            "key2": "value2"
          },
          "split_delimiters": [
            ",",
            ".",
            "\n"
          ],
          "tag_set": [
            "tag1",
            "tag2"
          ],
          "target_splits_per_chunk": 20,
          "time_stamp": "2021-01-01 00:00:00.000Z",
          "use_pdf2md_ocr": false
        }
      },
      "UploadFileResponseBody": {
        "type": "object",
        "required": [
          "file_metadata"
        ],
        "properties": {
          "file_metadata": {
            "$ref": "#/components/schemas/File"
          }
        }
      },
      "UploadHtmlPageReqPayload": {
        "type": "object",
        "required": [
          "data",
          "metadata",
          "scrapeId"
        ],
        "properties": {
          "data": {
            "$ref": "#/components/schemas/Document"
          },
          "metadata": {},
          "scrapeId": {
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "UserApiKey": {
        "type": "object",
        "required": [
          "id",
          "user_id",
          "name",
          "created_at",
          "updated_at",
          "role"
        ],
        "properties": {
          "api_key_hash": {
            "type": "string",
            "nullable": true
          },
          "blake3_hash": {
            "type": "string",
            "nullable": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "expires_at": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string"
          },
          "organization_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "params": {
            "nullable": true
          },
          "role": {
            "type": "integer",
            "format": "int32"
          },
          "scopes": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "user_id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "example": {
          "api_key_hash": "hash",
          "blake3_hash": "hash",
          "created_at": "2021-01-01 00:00:00.000",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "name": "Trieve",
          "role": 1,
          "updated_at": "2021-01-01 00:00:00.000",
          "user_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3"
        }
      },
      "UserOrganization": {
        "type": "object",
        "required": [
          "id",
          "user_id",
          "organization_id",
          "role",
          "created_at",
          "updated_at"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid"
          },
          "role": {
            "type": "integer",
            "format": "int32"
          },
          "scopes": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "user_id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "organization_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "role": 2,
          "updated_at": "2021-01-01 00:00:00.000",
          "user_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3"
        }
      },
      "UserTreatmentResponse": {
        "type": "object",
        "required": [
          "treatment_name",
          "experiment_id",
          "user_id"
        ],
        "properties": {
          "experiment_id": {
            "type": "string",
            "format": "uuid"
          },
          "treatment_name": {
            "type": "string"
          },
          "user_id": {
            "type": "string"
          }
        }
      },
      "V1RecommendChunksResponseBody": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/ChunkMetadataWithScore"
        }
      },
      "WorkerEvent": {
        "type": "object",
        "required": [
          "id",
          "created_at",
          "dataset_id",
          "event_type",
          "event_data"
        ],
        "properties": {
          "created_at": {
            "type": "string"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "event_data": {
            "type": "string"
          },
          "event_type": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          }
        },
        "example": {
          "created_at": "2021-01-01 00:00:00.000",
          "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "event_data": {
            "file_name": "file.txt",
            "group_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3"
          },
          "event_type": "file_uploaded",
          "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
          "updated_at": "2021-01-01 00:00:00.000"
        }
      }
    },
    "securitySchemes": {
      "ApiKey": {
        "type": "apiKey",
        "in": "header",
        "name": "Authorization"
      },
      "X-API-KEY": {
        "type": "apiKey",
        "in": "header",
        "name": "X-API-KEY"
      }
    }
  },
  "tags": [
    {
      "name": "Invitation",
      "description": "Invitation endpoint. Exists to invite users to an organization."
    },
    {
      "name": "Auth",
      "description": "Authentication endpoint. Serves to register and authenticate users."
    },
    {
      "name": "User",
      "description": "User endpoint. Enables you to modify user roles and information."
    },
    {
      "name": "Organization",
      "description": "Organization endpoint. Enables you to modify organization roles and information."
    },
    {
      "name": "Dataset",
      "description": "Dataset endpoint. Datasets belong to organizations and hold configuration information for both client and server. Datasets contain chunks and chunk groups."
    },
    {
      "name": "Chunk",
      "description": "Chunk endpoint. Think of chunks as individual searchable units of information. The majority of your integration will likely be with the Chunk endpoint."
    },
    {
      "name": "Chunk Group",
      "description": "Chunk groups endpoint. Think of a chunk_group as a bookmark folder within the dataset."
    },
    {
      "name": "Crawl",
      "description": "Crawl endpoint. Used to create and manage crawls for datasets."
    },
    {
      "name": "File",
      "description": "File endpoint. When files are uploaded, they are stored in S3 and broken up into chunks with text extraction from Apache Tika. You can upload files of pretty much any type up to 1GB in size. See chunking algorithm details at `docs.trieve.ai` for more information on how chunking works. Improved default chunking is on our roadmap."
    },
    {
      "name": "Events",
      "description": "Notifications endpoint. Files are uploaded asynchronously and events are sent to the user when the upload is complete."
    },
    {
      "name": "Topic",
      "description": "Topic chat endpoint. Think of topics as the storage system for gen-ai chat memory. Gen AI messages belong to topics."
    },
    {
      "name": "Message",
      "description": "Message chat endpoint. Messages are units belonging to a topic in the context of a chat with a LLM. There are system, user, and assistant messages."
    },
    {
      "name": "Stripe",
      "description": "Stripe endpoint. Used for the managed SaaS version of this app. Eventually this will become a micro-service. Reach out to the team using contact info found at `docs.trieve.ai` for more information."
    },
    {
      "name": "Health",
      "description": "Health check endpoint. Used to check if the server is up and running."
    },
    {
      "name": "Metrics",
      "description": "Metrics endpoint. Used to get information for monitoring"
    },
    {
      "name": "Analytics",
      "description": "Analytics endpoint. Used to get information for search and RAG analytics"
    },
    {
      "name": "Experiment",
      "description": "Experiment endpoint. Used to create and manage experiments"
    }
  ]
}
